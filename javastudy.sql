/*
 Navicat MySQL Data Transfer

 Source Server         : 139.9.135.240
 Source Server Type    : MySQL
 Source Server Version : 50562 (5.5.62-log)
 Source Host           : 139.9.135.240:3306
 Source Schema         : javastudy

 Target Server Type    : MySQL
 Target Server Version : 50562 (5.5.62-log)
 File Encoding         : 65001

 Date: 10/12/2022 15:35:10
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for kidmenu
-- ----------------------------
DROP TABLE IF EXISTS `kidmenu`;
CREATE TABLE `kidmenu`  (
  `id` int(11) NOT NULL,
  `title` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '菜单名称',
  `path` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '地址',
  `mid` int(11) NULL DEFAULT NULL COMMENT '上级id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `mid`(`mid`) USING BTREE,
  CONSTRAINT `kidmenu_ibfk_1` FOREIGN KEY (`mid`) REFERENCES `menu` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of kidmenu
-- ----------------------------
INSERT INTO `kidmenu` VALUES (101, '用户列表', '/user', 100);
INSERT INTO `kidmenu` VALUES (102, '角色管理', '/rights', 100);
INSERT INTO `kidmenu` VALUES (108, '知识点管理', '/course', 200);
INSERT INTO `kidmenu` VALUES (109, '题库管理', '/question', 200);
INSERT INTO `kidmenu` VALUES (110, '考试管理', '/paper', 200);
INSERT INTO `kidmenu` VALUES (111, '在线考试', '/exam', 200);
INSERT INTO `kidmenu` VALUES (112, '试卷批改', '/correc', 200);
INSERT INTO `kidmenu` VALUES (113, '在线学习', '/study', 200);

-- ----------------------------
-- Table structure for knowledge
-- ----------------------------
DROP TABLE IF EXISTS `knowledge`;
CREATE TABLE `knowledge`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `level` int(11) NULL DEFAULT NULL COMMENT '级别 1:章节 2：知识点',
  `point` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '知识点',
  `parent_id` int(11) NULL DEFAULT NULL COMMENT '父级id',
  `create_user` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '创建者',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '内容',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1017 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of knowledge
-- ----------------------------
INSERT INTO `knowledge` VALUES (1, 2, 'Java 入门教程', 1001, 'teacher', '2022-12-09 08:09:33', '<h2><strong>Java入门教程</strong></h2><p class=\"ql-align-center\"><br></p><p>Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。</p><p>Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。</p><p>本教程通过简单的实例将让大家更好的了解JAVA编程语言。</p><p><strong>Java 在线工具</strong>&nbsp;&nbsp;<strong>JDK 在线中文手册</strong></p><hr><h1>我的第一个JAVA程序</h1><p>以下我们通过一个简单的实例来展示Java编程，本实例输出\"Hello World\"，这也是所有语言入门的第一个实例程序：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Main{\npublic static void main(String []args) {\nSystem.out.println(\"Hello World\");\n}\n} \n</pre><p><br></p><p><br></p>');
INSERT INTO `knowledge` VALUES (2, 2, 'Java 简介', 1001, 'system', '2022-12-10 07:28:20', '<h2>Java简介</h2><h2>\n</h2><p>Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由詹姆斯·高斯林(James Gosling)和同事们共同研发，并在1995年正式推出。</p><p>Java分为三个体系：</p><ul><li>JavaSE(J2SE)(Java2 Platform Standard Edition，java平台标准版)</li><li>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</li><li>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)</li></ul><p>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字\"2\"：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。</p><p>2009年，sun公司被oracle收购.</p><p>2018年，开源组织Eclipse基金会宣布将JavaEE(Enterprise Edition)被更名为JakartaEE(雅加达)。</p><hr><h2>主要特性</h2><ul><li><strong>Java语言是简单的：</strong></li><li>Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的内存回收管理机制，使得程序员不必为内存管理而担忧。</li><li><strong>Java语言是面向对象的：</strong></li><li>Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。</li><li><strong>Java语言是分布式的：</strong></li><li>Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</li><li><strong>Java语言是健壮的：</strong></li><li>Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。</li><li><strong>Java语言是安全的：</strong></li><li>Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。</li><li><strong>Java语言是体系结构中立的：</strong></li><li>Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</li><li><strong>Java语言是可移植的：</strong></li><li>这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。</li><li><strong>Java语言是解释型的：</strong></li><li>如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</li><li><strong>Java是高性能的：</strong></li><li>与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。</li><li><strong>Java语言是多线程的：</strong></li><li>在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。</li><li><strong>Java语言是动态的：</strong></li><li>Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</li></ul><hr><h2>发展历史</h2><ul><li>1995年5月23日，Java语言诞生</li><li>1996年1月，第一个JDK-JDK1.0诞生</li><li>1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术</li><li>1996年9月，约8.3万个网页应用了JAVA技术来制作</li><li>1997年2月18日，JDK1.1发布</li><li>1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录</li><li>1997年9月，JavaDeveloperConnection社区成员超过十万</li><li>1998年2月，JDK1.1被下载超过2,000,000次</li><li>1998年12月8日，JAVA2企业平台J2EE发布</li><li>1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）</li><li>2000年5月8日，JDK1.3发布</li><li>2000年5月29日，JDK1.4发布</li><li>2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机</li><li>2001年9月24日，J2EE1.3发布</li><li>2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升</li><li>2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0</li><li>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字\"2\"：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME</li><li>2006年12月，SUN公司发布JRE6.0</li><li>2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。</li><li>2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP。</li><li>2011年7月28日，甲骨文发布java7.0的正式版。</li><li>2014 年 3 月 18 日，Oracle 公司发表 Java SE 8。</li><li>2017 年 9 月 21 日，Oracle 公司发表 Java SE 9</li><li>2018 年 3 月 21 日，Oracle 公司发表 Java SE 10</li><li>2018 年 9 月 25 日，Java SE 11 发布</li><li>2019 年 3 月 20 日，Java SE 12 发布</li></ul><hr><h2>Java开发工具</h2><p>Java语言尽量保证系统内存在1G以上，其他工具如下所示：</p><ul><li>Linux 系统或者Windows 95/98/2000/XP，WIN 7/8/10/11系统</li><li>Java JDK 8以上版本（这是必须的）</li><li>Notepad编辑器或者其他编辑器（虽然使用记事本也可以进行代码编写，但一个舒适的工具可以提高编程的效率，小编这里推荐使用vscode）。</li><li>IDE：Eclipse或者IntelliJ IDEA（对于初学者而言，这两款IDE都很不错，但却不是必要的（初学者使用到的功能比较少，不需要用到这么多功能））</li></ul><p>安装好以上的工具后，我们就可以输出Java的第一个程序\"Hello World！\"</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class MyFirstJavaProgram {\npublic static void main(String []args) {\nSystem.out.println(\"Hello World\");\n}\n} \n</pre><p>在下一章节我们将介绍如何配置java开发环境。</p><p>\n    </p><p><br></p><p>\n    </p><p><br></p><p>\n\n</p>');
INSERT INTO `knowledge` VALUES (3, 2, 'Java 开发环境配置', 1001, 'teacher', '2022-12-09 08:09:54', '<h2><strong style=\"background-color: rgb(240, 247, 255);\">Java 开发环境配置</strong></h2><p>在本章节中我们将为大家介绍如何搭建Java开发环境，以及不同系统下的环境变量怎么配置。</p><blockquote>&nbsp;本站提供java在线运行工具：https://www.w3cschool.cn/tryrun/runcode?lang=java-openjdk，但由于在线环境权限不足，大部分代码都不能直接在线运行，所以搭好一个本地可运行的环境相当重要！！！</blockquote><hr><h2>window系统安装java</h2><h3>下载JDK</h3><p>首先我们需要下载java开发工具包JDK，下载地址：<span style=\"background-color: rgb(255, 255, 255);\">https://www.oracle.com/java/technologies/downloads/#java11-windows</span></p><p>点击如下下载按钮：</p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1631525908322869.png\" alt=\"java下载页面\"></p><p>在下载页面中你需要选择接受许可，并根据自己的系统选择对应的版本，本文以 Window 64位系统为例：</p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1631526164892057.png\" alt=\"选择版本\"></p><p>下载后JDK的安装根据提示进行，还有安装JDK的时候也会安装JRE，一并安装就可以了。</p><p>安装JDK，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为&nbsp;C:\\Program Files (x86)\\Java\\jdk11.0.1。</p><h3>配置环境变量</h3><p>1.右击“我的电脑”→“属性”→“高级系统设置”→“高级”→“环境变量”；</p><p><br></p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1631526265603140.png\" alt=\"高级系统设置\"></p><p><br></p><p>2.选择\"高级\"选项卡，点击\"环境变量\"；</p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1603272507505864.png\" alt=\"4\"></p><p><br></p><p>3. 新建“JAVA_HOME”系统变量（点击“系统变量”下方的“新建”按钮，填写变量名与变量值，点击“确定”）</p><p><br></p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1603274075961624.png\" alt=\"12\"></p><p><br></p><p><br></p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1603273317346390.png\" alt=\"8\"></p><p><br></p><p><br></p><p>4. 同上，新建“CLASSPATH”系统变量，变量值为<code>“.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;”</code>。（引号内的全部内容，注意最前方是点不是逗号）</p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1603273582503862.png\" alt=\"9\"></p><p><br></p><p>5. 双击“系统变量”下的“Path”变量进行编辑。（此时可以看到JAVA_HOME已经存在于系统变量中），（有的电脑\"Path\"也写作“PATH”）</p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1603273710690393.png\" alt=\"10\"></p><p><br></p><p>这是 Java 的环境配置，配置完成后，你可以启动 Eclipse 来编写代码，它会自动完成java环境的配置。</p><p>在\"系统变量\"中设置3项属性，JAVA_HOME,PATH,CLASSPATH(大小写无所谓),若已存在则点击\"编辑\"，不存在则点击\"新建\"。</p><p>变量设置参数如下：</p><ul><li>变量名：JAVA_HOME</li><li>变量值：C:\\Program Files (x86)\\Java\\jdk1.8.0_91&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 要根据自己的实际路径配置</li><li>变量名：CLASSPATH</li><li>变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//记得前面有个\".\"</li><li>变量名：Path</li><li>变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;</li></ul><blockquote><strong>注意：</strong>如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。</blockquote><h3>通过控制台测试JDK是否安装成功</h3><p>1、同时按键盘上“win”、“R”两个键打开运行，输入“cmd”确定打开控制台。</p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1603273841886149.png\" alt=\"11\"></p><p>2、键入命令:&nbsp;<strong>java -version</strong>、<strong>java</strong>、<strong>javac</strong>&nbsp;几个命令，出现以下信息，说明环境变量配置成功；</p><p><br></p><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1472175877561324.png\" alt=\"jdk安装\"></p><p><br></p><h2>Linux，UNIX，Solaris，FreeBSD环境变量设置</h2><p>环境变量PATH应该设定为指向Java二进制文件安装的位置。如果设置遇到困难，请参考shell文档。</p><p>例如，假设你使用bash作为shell，你可以把下面的内容添加到你的 .bashrc文件结尾: export PATH=/path/to/java:$PATH</p><hr><h2>流行JAVA开发工具</h2><p>正所谓工欲善其事必先利其器，我们在开发java语言过程中同样需要一款不错的开发工具，目前市场上的IDE很多，本文为大家推荐以下几款java开发工具：</p><ul><li><strong>Eclipse:</strong>另一个免费开源的java IDE，下载地址：&nbsp;<span style=\"background-color: rgb(255, 255, 255);\">https://www.eclipse.org/eclipseide/</span></li><li>选择&nbsp;<strong>Eclipse IDE for Java Developers</strong>：</li></ul><p class=\"ql-align-center\"><img src=\"http://localhost:8080/static/picture/1603274243492401.jpg\" alt=\"13\"></p><p><br></p><ul><li>IntelliJ IDEA（推荐）：一个好用的java IDE，专业版功能强大但需要付费，开源版基础功能足够雄厚让你有更好的代码开发体验</li></ul><p>&nbsp;&nbsp;&nbsp;下载地址：https://www.jetbrains.com/zh-cn/idea/</p><p>Notepad++ : Notepad++ 是在微软windows环境之下的一个免费的代码编辑器，下载地址：&nbsp;http://notepad-plus-plus.org/</p><p>此外还有很多优秀的代码编辑器，比如vscode，sublime，vim等，在此不做过多介绍。</p><h2>使用 Eclipse 运行第一个 Java 程序</h2><p>HelloWorld.java 文件代码：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class HelloWorld {\npublic static void main(String []args) {\nSystem.out.println(\"Hello World\");\n}\n}\n</pre><p><br></p><p>\n</p><p><br></p>');
INSERT INTO `knowledge` VALUES (4, 2, 'Java 基础语法', 1002, 'teacher', '2022-12-09 08:10:01', '<h2><strong style=\"background-color: rgb(240, 247, 255);\">Java 基础语法</strong></h2><p><span style=\"background-color: rgb(240, 247, 255);\"><span class=\"ql-cursor\">﻿﻿</span></span></p><p>一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p><ul><li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li><li><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li><li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li></ul><h2>第一个Java程序</h2><p>下面看一个简单的 Java 程序，它将打印字符串<em>&nbsp;Hello World</em></p><pre class=\"ql-syntax\" spellcheck=\"false\">public class MyFirstJavaProgram {\n   /* 第一个Java程序.  \n    * 它将打印字符串 Hello World\n    */\n    public static void main(String []args) {\n       System.out.println(\"Hello World\"); // 打印 Hello World\n    }\n} \n</pre><p>下面将逐步介绍如何保存、编译以及运行这个程序：</p><ul><li>打开Notepad，把上面的代码添加进去；</li><li>把文件名保存为：MyFirstJavaProgram.java；</li><li>打开cmd命令窗口，进入目标文件所在的位置，假设是C:\\</li><li>在命令行窗口键入 javac MyFirstJavaProgram.java&nbsp;按下 enter 键编译代码。如果代码没有错误，cmd 命令提示符会进入下一行。（假设环境变量都设置好了）。</li><li>再键入 java MyFirstJavaProgram 按下 Enter 键就可以运行程序了</li></ul><p>你将会在窗口看到 Hello World</p><pre class=\"ql-syntax\" spellcheck=\"false\">C : &gt; javac MyFirstJavaProgram.java\nC : &gt; java MyFirstJavaProgram \nHello World\n</pre><hr><h2>基本语法</h2><p>编写Java程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如&nbsp;MyFirstJavaClass 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（<strong>如果文件名和类名不相同则会导致编译错误</strong>）。</li><li><strong>主方法入口</strong>：所有的Java 程序由<strong>​</strong><code><strong>public static void main(String[]&nbsp;args)</strong></code><strong>​&nbsp;</strong>方法开始执行。</li></ul><hr><h2>Java标识符</h2><p>Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于Java标识符，有以下几点需要注意：</p><ul><li>所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><hr><h2>Java修饰符</h2><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static，synchronized 和 volatile</li></ul><p>在后面的章节中我们会深入讨论Java修饰符。</p><h2>Java变量</h2><p>Java中主要有如下几种类型的变量</p><ul><li>局部变量</li><li>类变量（静态变量）</li><li>成员变量（非静态变量）</li></ul><hr><h2>Java数组</h2><p>数组是储存在堆上的对象，可以保存多个同类型变量。在后面的章节中，我们将会学到如何声明、构造以及初始化一个数组。</p><hr><h2>Java枚举</h2><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug 。</p><p>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p><hr><h2>实例</h2><pre class=\"ql-syntax\" spellcheck=\"false\">class FreshJuice {\n   enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }\n   FreshJuiceSize size;\n}\n\npublic class FreshJuiceTest {\n   public static void main(String args[]){\n      FreshJuice juice = new FreshJuice();\n      juice.size = FreshJuice. FreshJuiceSize.MEDIUM ;\n   }\n}\n</pre><p><strong>注意：</strong>枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。</p><hr><h2>Java关键字</h2><p>下面列出了Java保留字。这些保留字不能用于常量、变量、和任何标识符的名称。</p><p>关键字描述abstract抽象方法，抽象类的修饰符assert断言条件是否满足boolean布尔数据类型break跳出循环或者label代码段byte8-bit 有符号数据类型caseswitch语句的一个条件catch和try搭配捕捉异常信息char16-bit Unicode字符数据类型class定义类const未使用continue不执行循环体剩余部分defaultswitch语句中的默认分支do循环语句，循环体至少会执行一次double64-bit双精度浮点数elseif条件不成立时执行的分支enum枚举类型extends表示一个类是另一个类的子类final表示一个值在初始化之后就不能再改变了</p><p>表示方法不能被重写，或者一个类不能有子类finally为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。float32-bit单精度浮点数forfor循环语句goto未使用if条件语句implements表示一个类实现了接口import导入类instanceof测试一个对象是否是某个类的实例int32位整型数interface接口，一种抽象的类型，仅有方法和常量的定义long64位整型数native表示方法用非java代码实现new分配新的类实例package一系列相关类组成一个包private表示私有字段，或者方法等，只能从类内部访问protected表示字段只能通过类或者其子类访问</p><p>子类或者在同一个包内的其他类public表示共有属性或者方法return方法返回值short16位数字static表示在类级别定义，所有实例共享的strictfp浮点数比较使用严格的规则super表示基类switch选择语句synchronized表示同一时间只能由一个线程访问的代码块this表示调用当前实例</p><p>或者调用另一个构造函数throw抛出异常throws定义方法可能抛出的异常transient修饰不要序列化的字段try表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码void标记方法不返回任何值volatile标记字段可能会被多个线程同时访问，而不做同步whilewhile循环</p><h2>Java注释</h2><p>类似于C/C++，Java也支持单行以及多行注释。注释中的字符将被Java编译器忽略。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class MyFirstJavaProgram{\n   /* 这是第一个Java程序\n    *它将打印Hello World\n    * 这是一个多行注释的示例\n    */\n    public static void main(String []args){\n       // 这是单行注释的示例\n       /* 这个也是单行注释的示例 */\n       System.out.println(\"Hello World\"); \n    }\n} \n</pre><hr><h2>Java 空行</h2><p>空白行，或者只有注释的行，Java编译器都会忽略掉。</p><hr><h2>继承</h2><p>在Java中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p><p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p><h2>接口</h2><p>在Java中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p><p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p><p>下一节介绍Java编程中的类和对象。之后你将会对Java中的类和对象有更清楚的认识。</p><p><br></p><hr><p><br></p>');
INSERT INTO `knowledge` VALUES (5, 2, 'Java 对象和类', 1003, 'teacher', '2022-12-09 08:10:09', '<h2><strong>Java对象和类</strong></h2><p class=\"ql-align-center\"><br></p><p>在理解Java的类和对象之前，先简单介绍一下面向对象的程序设计。程序设计是通过对象对程序进行设计，对象代表一个实体，实体可以清楚地被识别。</p><p>Java作为一种面向对象语言。支持以下基本概念：</p><ul><li>多态</li><li>继承</li><li>封装</li><li>抽象</li><li>类</li><li>对象</li><li>实例</li><li>方法</li><li>消息解析</li></ul><p>本节我们重点研究对象和类的概念。</p><ul><li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li></ul><hr><h2>Java中的对象</h2><p>现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。</p><p>拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。</p><p>对比现实对象和软件对象，它们之间十分相似。</p><p>软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。</p><p>在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p><h2>Java中的类</h2><p>类可以看成是创建 Java 对象的模板。</p><p>通过下面一个简单的类来理解下 Java 中类的定义：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Dog{\n   String breed;\n   int age;\n   String color;\n   void barking(){\n   }\n   \n   void hungry(){\n   }\n   \n   void sleeping(){\n   }\n}\n</pre><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><p>一个类可以拥有多个方法，在上面的例子中：​<code>barking()</code>​、​<code>hungry()</code>​和​<code>sleeping()</code>​都是 Dog 类的方法。</p><hr><h2>构造方法</h2><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</p><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p><p>下面是一个构造方法示例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Puppy{\n   public Puppy(){\n   }\n\n   public Puppy(String name){\n      // 这个构造器仅有一个参数：name\n   }\n}\n</pre><hr><h2>创建对象</h2><p>对象是根据类创建的。在 Java 中，使用关键字 ​<code>new</code>​ 来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 ​<code>new</code>​ 来创建一个对象。</li><li><strong>初始化</strong>：使用 ​<code>new</code>​ 创建对象时，会调用构造方法初始化对象。</li></ul><p>下面是一个创建对象的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Puppy{\n   public Puppy(String name){\n      //这个构造器仅有一个参数：name\n      System.out.println(\"Puppy Name is :\" + name ); \n   }\n   public static void main(String []args){\n      // 下面的语句将创建一个Puppy对象\n      Puppy myPuppy = new Puppy( \"tommy\" );\n   }\n}\n</pre><p>编译并运行上面的程序，会打印出下面的结果：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Puppy Name is :tommy\n</pre><hr><h2>访问实例变量和方法</h2><p>通过已创建的对象来访问成员变量和成员方法，如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 实例化对象 */\nObjectReference = new Constructor();\n/* 访问其中的变量 */\nObjectReference.variableName;\n/* 访问类中的方法 */\nObjectReference.MethodName();\n</pre><hr><h2>实例</h2><p>下面的例子展示如何访问实例变量和调用成员方法：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Puppy{\n   int puppyAge;\n   public Puppy(String name){\n      // 这个构造器仅有一个参数：name\n      System.out.println(\"Passed Name is :\" + name ); \n   }\n\n   public void setAge( int age ){\n       puppyAge = age;\n   }\n\n   public int getAge( ){\n       System.out.println(\"Puppy\'s age is :\" + puppyAge ); \n       return puppyAge;\n   }\n\n   public static void main(String []args){\n      /* 创建对象 */\n      Puppy myPuppy = new Puppy( \"tommy\" );\n      /* 通过方法来设定age */\n      myPuppy.setAge( 2 );\n      /* 调用另一个方法获取age */\n      myPuppy.getAge( );\n      /*你也可以像下面这样访问成员变量 */\n      System.out.println(\"Variable Value :\" + myPuppy.puppyAge ); \n   }\n}\n</pre><p>编译并运行上面的程序，产生如下结果：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Passed Name is :tommy\nPuppy\'s age is :2\nVariable Value :2\n</pre><hr><h2>源文件声明规则</h2><p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有​<code>import</code>​语句和​<code>package</code>​语句时，要特别注意这些规则。</p><ul><li>一个源文件中只能有一个 ​<code>public</code>​ 类</li><li>一个源文件可以有多个非​<code>public</code>​类</li><li>源文件的名称应该和​<code>public</code>​类的类名保持一致。例如：源文件中​<code>public</code>​类的类名是​<code>Employee</code>​，那么源文件应该命名为​<code>Employee.java</code>​。</li><li>如果一个类定义在某个包中，那么​<code>package</code>​语句应该在源文件的首行。</li><li>如果源文件包含​<code>import</code>​语句，那么应该放在​<code>package</code>​语句和类定义之间。如果没有​<code>package</code>​语句，那么​<code>import</code>​语句应该在源文件中最前面。</li><li>​<code>import</code>​语句和​<code>package</code>​语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul><p>类有若干种访问级别，并且类也分不同的类型：抽象类和​<code>final</code>​类等。这些将在访问控制章节介绍。</p><p>除了上面提到的几种类型，Java 还有一些特殊的类，如：内部类、匿名类。</p><hr><h2>Java包</h2><p>包主要用来对类和接口进行分类。当开发 Java 程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p><h2>Import语句</h2><p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。​<code>Import</code>​语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p><p>例如，下面的命令行将会命令编译器载入 java_installation/java/io 路径下的所有类</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.io.*;\n</pre><hr><h2>一个简单的例子</h2><p>在该例子中，我们创建两个类：Employee 和 EmployeeTest。</p><p>首先打开文本编辑器，把下面的代码粘贴进去。注意将文件保存为 Employee.java。</p><p>Employee 类有四个成员变量：name、age、designation 和 salary。该类显式声明了一个构造方法，该方法只有一个参数。</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.io.*;\npublic class Employee{\n   String name;\n   int age;\n   String designation;\n   double salary;\n   // Employee 类的构造器\n   public Employee(String name){\n      this.name = name;\n   }\n   // 设置age的值\n   public void empAge(int empAge){\n      age =  empAge;\n   }\n   /* 设置designation的值*/\n   public void empDesignation(String empDesig){\n      designation = empDesig;\n   }\n   /* 设置salary的值*/\n   public void empSalary(double empSalary){\n      salary = empSalary;\n   }\n   /* 打印信息 */\n   public void printEmployee(){\n      System.out.println(\"Name:\"+ name );\n      System.out.println(\"Age:\" + age );\n      System.out.println(\"Designation:\" + designation );\n      System.out.println(\"Salary:\" + salary);\n   }\n}\n</pre><p>程序都是从 ​<code>main</code>​方法开始执行。为了能运行这个程序，必须包含 ​<code>main</code>​ 方法并且创建一个实例对象。</p><p>下面给出 EmployeeTest 类，该类实例化2个 Employee 类的实例，并调用方法设置变量的值。</p><p>将下面的代码保存在 EmployeeTest.java 文件中。</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.io.*;\npublic class EmployeeTest{\n\n   public static void main(String args[]){\n      /* 使用构造器创建两个对象 */\n      Employee empOne = new Employee(\"James Smith\");\n      Employee empTwo = new Employee(\"Mary Anne\");\n\n      // 调用这两个对象的成员方法\n      empOne.empAge(26);\n      empOne.empDesignation(\"Senior Software Engineer\");\n      empOne.empSalary(1000);\n      empOne.printEmployee();\n\n      empTwo.empAge(21);\n      empTwo.empDesignation(\"Software Engineer\");\n      empTwo.empSalary(500);\n      empTwo.printEmployee();\n   }\n}\n</pre><p>编译这两个文件并且运行 EmployeeTest 类，可以看到如下结果：</p><pre class=\"ql-syntax\" spellcheck=\"false\">C :&gt; javac Employee.java\nC :&gt; vi EmployeeTest.java\nC :&gt; javac  EmployeeTest.java\nC :&gt; java EmployeeTest\nName:James Smith\nAge:26\nDesignation:Senior Software Engineer\nSalary:1000.0\nName:Mary Anne\nAge:21\nDesignation:Software Engineer\nSalary:500.0\n</pre><p><br></p><p><br></p>');
INSERT INTO `knowledge` VALUES (6, 2, 'Java 基本数据类型', 1002, 'teacher', '2022-12-09 08:10:16', '<h2><strong>Java基本数据类型</strong></h2><p class=\"ql-align-center\"><br></p><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p><p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p><p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p><p>Java的两大数据类型：</p><ul><li>内置数据类型</li><li>引用数据类型</li></ul><hr><h2>内置数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><p>byte型：</p><ul><li>byte数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是-128（-2^7）；</li><li>最大值是127（2^7-1）；</li><li>默认值是0；</li><li>byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；</li><li>例子：byte a = 100，byte b = -50。</li></ul><p>short型（短整型）：</p><ul><li>short数据类型是16位、有符号的以二进制补码表示的整数</li><li>最小值是-32768（-2^15）；</li><li>最大值是32767（2^15 - 1）；</li><li>Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是0；</li><li>例子：short s = 1000，short r = -20000。</li></ul><p>int型（整型）：</p><ul><li>int数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是-2,147,483,648（-2^31）；</li><li>最大值是2,147,483,647（2^31 - 1）；</li><li>一般地整型变量默认为int类型；</li><li>默认值是0；</li><li>例子：int a = 100000, int b = -200000。</li></ul><p>long（长整型）：</p><ul><li>long数据类型是64位、有符号的以二进制补码表示的整数；</li><li>最小值是-9,223,372,036,854,775,808（-2^63）；</li><li>最大值是9,223,372,036,854,775,807（2^63 -1）；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是0L；</li><li>例子： long a = 100000L，long b = -200000L。</li></ul><p>float（单精度浮点型）：</p><ul><li>float数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float在储存大型浮点数组的时候可节省内存空间；</li><li>默认值是0.0f；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 = 234.5f。</li></ul><p>double（双精度浮点型）：</p><ul><li>double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</li><li>浮点数的默认类型为double类型；</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是0.0d；</li><li>例子：double d1 = 123.4。</li></ul><p>boolean（布尔型）：</p><ul><li>boolean数据类型表示一位的信息；</li><li>只有两个取值：true和false；</li><li>这种类型只作为一种标志来记录true/false情况；</li><li>默认值是false；</li><li>例子：boolean one = true。</li></ul><p>char（字符型）：</p><ul><li>char类型是一个单一的16位Unicode字符；</li><li>最小值是’\\u0000’（即为0）；</li><li>最大值是’\\uffff’（即为65,535）；</li><li>char数据类型可以储存任何字符；</li><li>例子：char letter = ‘A’。</li></ul><h3>实例</h3><p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。请看下面的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class PrimitiveTypeTest {\n    public static void main(String[] args) {\n    // byte\n    System.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE);\n    System.out.println(\"包装类：java.lang.Byte\");\n    System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE);\n    System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE);\n    System.out.println();\n    \n&nbsp;&nbsp;&nbsp;&nbsp;// short\n    System.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE);\n    System.out.println(\"包装类：java.lang.Short\");\n    System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE);\n    System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE);\n    System.out.println();\n\n    // int\n    System.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE);\n    System.out.println(\"包装类：java.lang.Integer\");\n    System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE);\n    System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n    System.out.println();\n\n    // long\n    System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE);\n    System.out.println(\"包装类：java.lang.Long\");\n    System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE);\n    System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE);\n    System.out.println();\n\n    // float\n    System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE);\n    System.out.println(\"包装类：java.lang.Float\");\n    System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE);\n    System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE);\n    System.out.println();\n\n    // double\n    System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE);\n    System.out.println(\"包装类：java.lang.Double\");\n    System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE);\n    System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE);\n    System.out.println();\n\n    // char\n    System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE);\n    System.out.println(\"包装类：java.lang.Character\");\n    // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台\n    System.out.println(\"最小值：Character.MIN_VALUE=\"\n            + (int) Character.MIN_VALUE);\n    // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台\n    System.out.println(\"最大值：Character.MAX_VALUE=\"\n            + (int) Character.MAX_VALUE);\n}\n}  \n</pre><p>编译以上代码输出结果如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">基本类型：byte 二进制位数：8\n包装类：java.lang.Byte\n最小值：Byte.MIN_VALUE=-128\n最大值：Byte.MAX_VALUE=127\n基本类型：short 二进制位数：16\n包装类：java.lang.Short\n最小值：Short.MIN_VALUE=-32768\n最大值：Short.MAX_VALUE=32767\n\n\n基本类型：int 二进制位数：32\n包装类：java.lang.Integer\n最小值：Integer.MIN_VALUE=-2147483648\n最大值：Integer.MAX_VALUE=2147483647\n\n\n基本类型：long 二进制位数：64\n包装类：java.lang.Long\n最小值：Long.MIN_VALUE=-9223372036854775808\n最大值：Long.MAX_VALUE=9223372036854775807\n\n\n基本类型：float 二进制位数：32\n包装类：java.lang.Float\n最小值：Float.MIN_VALUE=1.4E-45\n最大值：Float.MAX_VALUE=3.4028235E38\n\n\n基本类型：double 二进制位数：64\n包装类：java.lang.Double\n最小值：Double.MIN_VALUE=4.9E-324\n最大值：Double.MAX_VALUE=1.7976931348623157E308\n\n\n基本类型：char 二进制位数：16\n包装类：java.lang.Character\n最小值：Character.MIN_VALUE=0\n最大值：Character.MAX_VALUE=65535\n</pre><p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的\"E+数字\"表示E之前的数字要乘以10的“数字”次幂。比如3.14E3就是3.14×1000=3140，3.14E-3就是3.14/1000=0.00314。</p><p>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p><hr><h2>引用类型</h2><ul><li>引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。变量一旦声明后，类型就不能被改变了。</li><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用与任何与之兼容的类型。</li><li>例子：Animal animal = new Animal(“giraffe”)。</li></ul><hr><h2>Java常量</h2><p>常量就是一个固定值。它们不需要计算，直接代表相应的值。</p><p>常量指不能改变的量。 在Java中用final标志，声明方式和变量类似：</p><pre class=\"ql-syntax\" spellcheck=\"false\">final double PI = 3.1415927;\n</pre><p>虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p><p>字面量可以赋给任何内置类型的变量。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">byte a = 68;\nchar a = \'A\'\n</pre><p>byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。</p><p>当使用常量的时候，前缀0表明是8进制，而前缀0x代表16进制。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">int decimal = 100;\nint octal = 0144;\nint hexa =  0x64;\n</pre><p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">\"Hello World\"\n\"two\\nlines\"\n\"\\\"This is in quotes\\\"\"\n</pre><p>字符串常量和字符常量都可以包含任何Unicode字符。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">char a = \'\\u0001\';\nString a = \"\\u0001\";\n</pre><p>Java语言支持一些特殊的转义字符序列。</p><p>符号字符含义\\n换行 (0x0a)\\r回车 (0x0d)\\f换页符(0x0c)\\b退格 (0x08)\\0空字符（0x0）\\s字符串</p><p>\\t制表符\\\"双引号\\\'单引号\\\\反斜杠\\ddd八进制字符 (ddd)\\uxxxx16进制Unicode字符 (xxxx)</p><p>这一节讲解了Java的基本数据类型。下一节将探讨不同的变量类型以及它们的用法。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (7, 2, 'Java 变量类型', 1002, 'teacher', '2022-12-09 08:10:24', '<h2><strong>Java变量类型</strong></h2><p><br></p><p>在 Java 语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">type identifier [ = value][, identifier [= value] ...] ;\n</pre><p>格式说明：type 为 Java 数据类型。identifier 是变量名。可以使用逗号隔开来声明多个同类型变量。</p><p>以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p><pre class=\"ql-syntax\" spellcheck=\"false\">int a, b, c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 声明三个int型整数：a、b、c。\nint d = 3, e, f = 5; // 声明三个整数并赋予初值。\nbyte z = 22;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 声明并初始化z。\ndouble pi = 3.14159; // 声明了pi。\nchar x = \'x\';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 变量x的值是字符\'x\'。\n</pre><p>Java 语言支持的变量类型有：</p><ul><li>局部变量：类的方法中的变量。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>类变量：独立于方法之外的变量，用 static 修饰。</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">public class Variable{\n    static int allClicks=0;    // 类变量\n\n    String str=\"hello world\";  // 实例变量\n \n    public void method(){\n        int i =0;  // 局部变量\n    }\n}\n</pre><h2>Java局部变量</h2><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><h3>实例1</h3><p>在以下实例中 age 是一个局部变量。定义在 pupAge() 方法中，它的作用域就限制在这个方法中。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test{ \n   public void pupAge(){\n      int age = 0;\n      age = age + 7;\n      System.out.println(\"Puppy age is : \" + age);\n   }\n   \n   public static void main(String args[]){\n      Test test = new Test();\n      test.pupAge();\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Puppy age is: 7\n</pre><h3>实例2</h3><p>在下面的例子中 age 变量没有初始化，所以在编译时出错。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test{ \n   public void pupAge(){\n      int age;\n      age = age + 7;\n      System.out.println(\"Puppy age is : \" + age);\n   }\n   \n   public static void main(String args[]){\n      Test test = new Test();\n      test.pupAge();\n   }\n}\n</pre><p>以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Test.java:4:variable number might not have been initialized\nage = age + 7;\n         ^\n1 error\n</pre><h2>实例变量</h2><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li></ul><p>实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.io.*;\npublic class Employee{\n&nbsp;&nbsp; // 这个成员变量对子类可见\n&nbsp;&nbsp; public String name;\n&nbsp;&nbsp; // 私有变量，仅在该类可见\n&nbsp;&nbsp; private double salary;\n&nbsp;&nbsp; //在构造器中对name赋值\n&nbsp;&nbsp; public Employee (String empName){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name = empName;\n&nbsp;&nbsp; }\n&nbsp;&nbsp; //设定salary的值\n&nbsp;&nbsp; public void setSalary(double empSal){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; salary = empSal;\n&nbsp;&nbsp; }&nbsp;&nbsp;\n&nbsp;&nbsp; // 打印信息\n&nbsp;&nbsp; public void printEmp(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"name&nbsp; : \" + name );\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"salary :\" + salary);\n&nbsp;&nbsp; }\n\n&nbsp;&nbsp; public static void main(String args[]){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Employee empOne = new Employee(\"Ransika\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empOne.setSalary(1000);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empOne.printEmp();\n&nbsp;&nbsp; }\n}\n\n</pre><p>以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">name  : Ransika\nsalary :1000.0\n</pre><h2>类变量（静态变量）</h2><ul><li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法、构造方法和语句块之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用。常量是指声明为 public/private，final 和 static 类型的变量。常量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li><li>静态变量在程序开始时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：ClassName.VariableName 的方式访问。</li><li>类变量被声明为 public static final 类型时，类变量名称必须使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul><p>实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.io.*;\npublic class Employee{\n&nbsp;&nbsp; //salary是静态的私有变量\n&nbsp;&nbsp; private static double salary;\n&nbsp;&nbsp; // DEPARTMENT是一个常量\n&nbsp;&nbsp; public static final String DEPARTMENT = \"Development \";\n&nbsp;&nbsp; public static void main(String args[]){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; salary = 1000;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(DEPARTMENT+\"average salary:\"+salary);\n&nbsp;&nbsp; }\n}\n</pre><p>以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Development average salary:1000\n</pre><p>注意：如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT。</p><p>本章节中我们学习了 Java 的变量类型，下一章节中我们将介绍Java修饰符的使用。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (8, 2, 'Java 修饰符', 1002, 'teacher', '2022-12-09 08:10:31', '<h2><strong>Java修饰符</strong></h2><p class=\"ql-align-center\"><br></p><p>Java 语言提供了很多修饰符，主要分为以下两类：</p><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class className {\n   // ...\n}\nprivate boolean myFlag;\nstatic final double weeks = 9.5;\nprotected static final int BOXWIDTH = 42;\npublic static void main(String[] arguments) {\n   // 方法体\n}\n</pre><hr><h2>访问控制修饰符</h2><p>Java 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持4种不同的访问权限。</p><p>默认的，也称为 default，在同一包内可见，不使用任何修饰符。</p><p>私有的，以 private 修饰符指定，在同一类内可见。</p><p>公有的，以 public 修饰符指定，对所有类可见。</p><p>受保护的，以 protected 修饰符指定，对同一包内的类和所有子类可见。</p><h3>默认访问修饰符-不使用任何关键字</h3><p>使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为​<code>public static final</code>​,而接口里的方法默认情况下访问权限为​<code>public</code>​。</p><p>实例：</p><p>如下例所示，变量和方法的声明可以不使用任何修饰符。</p><pre class=\"ql-syntax\" spellcheck=\"false\">String version = \"1.5.1\";\nboolean processOrder() {\n   return true;\n}\n</pre><h3>私有访问修饰符-private</h3><p>私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p><p>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。</p><p>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p><p>下面的类使用了私有访问修饰符：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Logger {\n   private String format;\n   public String getFormat() {\n      return this.format;\n   }\n   public void setFormat(String format) {\n      this.format = format;\n   }\n}\n</pre><p>实例中，Logger 类中的 format 变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个​<code>public</code>​方法：​<code>getFormat()&nbsp;</code>​（返回format的值）和​<code>setFormat(String)</code>​（设置format的值）</p><h3>公有访问修饰符-public</h3><p>被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。</p><p>如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p><p>以下函数使用了公有访问控制：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public static void main(String[] arguments) {\n   // ...\n}\n</pre><p>Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。</p><h3>受保护的访问修饰符-protected</h3><p>被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。</p><p>Protected 访问修饰符不能修饰类和接口，方法和成员变量能够声明为 protected，但是接口的成员变量和成员方法不能声明为 protected。</p><p>子类能访问 Protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p><p>下面的父类使用了 protected 访问修饰符，子类重载了父类的 openSpeaker() 方法。</p><pre class=\"ql-syntax\" spellcheck=\"false\">class AudioPlayer {\n   protected boolean openSpeaker(Speaker sp) {\n      // 实现细节\n   }\n}\n\nclass StreamingAudioPlayer {\n   boolean openSpeaker(Speaker sp) {\n      // 实现细节\n   }\n}\n</pre><p>如果把 openSpeaker() 方法声明为private，那么除了 AudioPlayer 之外的类将不能访问该方法。</p><p>如果把 openSpeaker() 声明为 public，那么所有的类都能够访问该方法。</p><p>如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。</p><h3>访问控制和继承</h3><p>请注意以下方法继承的规则：</p><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public。不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><hr><h2>非访问修饰符</h2><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><p>static 修饰符，用来创建类方法和类变量。</p><p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p><p>abstract 修饰符，用来创建抽象类和抽象方法。</p><p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p><h3>static修饰符</h3><ul><li><strong>静态变量：</strong></li><li>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。</li><li><strong>静态方法：</strong></li><li>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li></ul><p>对类变量和方法的访问可以直接使用 ​<code>classname.variablename</code>​ 和 ​<code>classname.methodname</code>​的方式访问。</p><p>如下例所示，static 修饰符用来创建类方法和类变量。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class InstanceCounter {\n   private static int numInstances = 0;\n   protected static int getCount() {\n      return numInstances;\n   }\n\n   private static void addInstance() {\n      numInstances++;\n   }\n\n   InstanceCounter() {\n      InstanceCounter.addInstance();\n   }\n\n   public static void main(String[] arguments) {\n      System.out.println(\"Starting with \" +\n      InstanceCounter.getCount() + \" instances\");\n      for (int i = 0; i &lt; 500; ++i){\n          new InstanceCounter();\n      }\n      System.out.println(\"Created \" +\n       InstanceCounter.getCount() + \" instances\");\n&nbsp;&nbsp;&nbsp;}\n} \n</pre><p>以上实例运行编辑结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Started with 0 instances\nCreated 500 instances\n</pre><h3>final 修饰符</h3><p><strong>final 变量：</strong></p><p>final 变量能被显式地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。</p><p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p><p>实例:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test{\n  final int value = 10;\n  // 下面是声明常量的实例\n  public static final int BOXWIDTH = 6;\n  static final String TITLE = \"Manager\";\n\n  public void changeValue(){\n     value = 12; //将输出一个错误\n  }\n}\n</pre><h3>final 方法</h3><p>类中的 Final 方法可以被子类继承，但是不能被子类修改。</p><p>声明 final 方法的主要目的是防止该方法的内容被修改。</p><p>如下所示，使用 final 修饰符声明方法。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test{\n    public final void changeName(){\n       // 方法体\n    }\n}\n</pre><h3>final 类</h3><p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p><p>实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public final class Test {\n   // 类体\n}\n</pre><h3>abstract 修饰符</h3><p><strong>抽象类：</strong></p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p><p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><p>抽象类可以包含抽象方法和非抽象方法。</p><p>实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">abstract class Caravan{\n   private double price;\n   private String model;\n   private String year;\n   public abstract void goFast(); //抽象方法\n   public abstract void changeColor();\n}\n</pre><h3>抽象方法</h3><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。</p><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p>抽象方法的声明以分号结尾，例如：public abstract sample();</p><p>实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public abstract class SuperClass{\n    abstract void m(); //抽象方法\n}\n \nclass SubClass extends SuperClass{\n     //实现抽象方法\n      void m(){\n          .........\n      }\n}\n</pre><h3>synchronized 修饰符</h3><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。Synchronized 修饰符可以应用于四个访问修饰符。</p><p>实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public synchronized void showDetails(){\n.......\n} \n</pre><h3>transient 修饰符</h3><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机 (JVM) 跳过该特定的变量。</p><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p><p>实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public transient int limit = 55;   // will not persist\npublic int b; // will persist\n</pre><h3>volatile修饰符</h3><p>volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>一个 volatile 对象引用可能是 null。</p><p>实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class MyRunnable implements Runnable\n{\n    private volatile boolean active;\n    public void run()\n    {\n        active = true;\n        while (active) // line 1\n        {\n            // 代码\n        }\n    }\n    public void stop()\n    {\n        active = false; // line 2\n    }\n}\n</pre><p>一般地，在一个线程中调用run()方法，在另一个线程中调用stop()方法。如果line 1中的active位于缓冲区的值被使用，那么当把line 2中的active设置成false时，循环也不会停止。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (9, 2, 'Java 运算符', 1002, 'teacher', '2022-12-09 08:08:50', '<h2 class=\"ql-align-center\"><strong>Java运算符</strong></h2><p class=\"ql-align-center\"><br></p><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p><ul><li>算术运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><h2>算术运算符</h2><p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p><p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p><p>操作符描述例子+加法 - 相加运算符两侧的值A + B等于30-减法 - 左操作数减去右操作数A – B等于-10*乘法 - 相乘操作符两侧的值A * B等于200/除法 - 左操作数除以右操作数B / A等于2％取模 - 左操作数除以右操作数的余数B%A等于0++自增 - 操作数的值增加1B++ 或 ++B 等于 21--自减 - 操作数的值减少1B-- 或 --B 等于 19</p><blockquote>&nbsp;虽然都是自增（他们的运算结果都是等于B+1），但B++和++B还是有所区别，++B是左值，直接原地操作（可以理解为直接在变量B上+1），B++是右值，在编译器中运算的时候会先构建一个临时变量，用临时变量运算+1后再赋值给B。</blockquote><blockquote>所以，在下面实例代码中，打印d++的时候发现结果并没有+1（这个时候打印的是d这个变量，运算的是d的临时变量），但是后一条打印的语句显示的结果又是+1后的结果（临时变量的值赋给变量d了）。而打印++d的结果是直接+1的。</blockquote><h3>实例</h3><p>下面的简单示例程序演示了算术运算符。复制并粘贴下面的Java程序并保存为Test.java文件，然后编译并运行这个程序：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n  public static void main(String args[]) {\n     int a = 10;\n     int b = 20;\n     int c = 25;\n     int d = 25;\n     System.out.println(\"a + b = \" + (a + b) );\n     System.out.println(\"a - b = \" + (a - b) );\n     System.out.println(\"a * b = \" + (a * b) );\n     System.out.println(\"b / a = \" + (b / a) );\n     System.out.println(\"b % a = \" + (b % a) );\n     System.out.println(\"c % a = \" + (c % a) );\n     System.out.println(\"a++   = \" +  (a++) );\n     System.out.println(\"a--   = \" +  (a--) );\n     // 查看  d++ 与 ++d 的不同\n     System.out.println(\"d++   = \" +  (d++) );\n     System.out.println(\"d     = \" +  d);\n     System.out.println(\"++d   = \" +  (++d) );\n  }\n} \n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">a + b = 30\na - b = -10\na * b = 200\nb / a = 2\nb % a = 0\nc % a = 5\na++   = 10\na--   = 11\nd++   = 25\nd     =26\n++d   = 27\n</pre><hr><h2>关系运算符</h2><p>下表为Java支持的关系运算符</p><p>表格中的实例整数变量A的值为10，变量B的值为20：</p><p>运算符描述例子==检查如果两个操作数的值是否相等，如果相等则条件为真。（A == B）为假(非真)。!=检查如果两个操作数的值是否相等，如果值不相等则条件为真。(A != B) 为真。&gt;&nbsp;检查左操作数的值是否大于右操作数的值，如果是那么条件为真。（A&gt; B）非真。&lt;&nbsp;检查左操作数的值是否小于右操作数的值，如果是那么条件为真。（A &lt;B）为真。&gt;=检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。（A&gt; = B）为假。&lt;=检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。（A &lt;= B）为真。</p><h3>实例</h3><p>下面的简单示例程序演示了关系运算符。复制并粘贴下面的Java程序并保存为Test.java文件，然后编译并运行这个程序：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n  public static void main(String args[]) {\n     int a = 10;\n     int b = 20;\n     System.out.println(\"a == b = \" + (a == b) );\n     System.out.println(\"a != b = \" + (a != b) );\n     System.out.println(\"a &gt; b = \" + (a &gt; b) );\n     System.out.println(\"a &lt; b = \" + (a &lt; b) );\n     System.out.println(\"b &gt;= a = \" + (b &gt;= a) );\n     System.out.println(\"b &lt;= a = \" + (b &lt;= a) );\n   } \n}  \n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">a == b = false\na != b = true\na &gt; b = false\na &lt; b = true b &gt;= a = true\nb &lt;= a = false \n</pre><hr><h2>位运算符</h2><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p><p>位运算符作用在所有的位上，并且按位运算。假设a = 60，和b = 13;它们的二进制格式表示将如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">A = 0011 1100\nB = 0000 1101\n-----------------\nA&amp;B = 0000 1100\nA | B = 0011 1101\nA ^ B = 0011 0001\n~A= 1100 0011\n</pre><p>下表列出了位运算符的基本运算,假设整数变量A的值为60和变量B的值为13：</p><p>操作符描述例子＆按位与操作符，当且仅当两个操作数的某一位都非0时候结果的该位才为1。（A＆B），得到12，即0000 1100|按位或操作符，只要两个操作数的某一位有一个非0时候结果的该位就为1。（A | B）得到61，即 0011 1101^按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。（A ^ B）得到49，即 0011 0001〜按位补运算符翻转操作数的每一位。（〜A）得到-61，即1100 0011&lt;&lt;&nbsp;按位左移运算符。左操作数按位左移右操作数指定的位数。A &lt;&lt; 2得到240，即 1111 0000&gt;&gt;&nbsp;按位右移运算符。左操作数按位右移右操作数指定的位数。A &gt;&gt; 2得到15即 1111&gt;&gt;&gt;&nbsp;按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。A&gt;&gt;&gt;2得到15即0000 1111</p><h3>实例</h3><p>下面的简单示例程序演示了位运算符。复制并粘贴下面的Java程序并保存为Test.java文件，然后编译并运行这个程序：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n&nbsp; public static void main(String args[]) {\n&nbsp;&nbsp;&nbsp;  int a = 60; /* 60 = 0011 1100 */&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp; int b = 13; /* 13 = 0000 1101 */\n&nbsp;&nbsp;&nbsp;&nbsp; int c = 0;\n&nbsp;&nbsp;&nbsp;&nbsp; c = a &amp; b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 12 = 0000 1100 */\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"a &amp; b = \" + c );\n\n&nbsp;&nbsp;&nbsp;&nbsp; c = a | b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 61 = 0011 1101 */\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"a | b = \" + c );\n\n&nbsp;&nbsp;&nbsp;&nbsp; c = a ^ b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 49 = 0011 0001 */\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"a ^ b = \" + c );\n\n&nbsp;&nbsp;&nbsp;&nbsp; c = ~a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*-61 = 1100 0011 */\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"~a = \" + c );\n\n&nbsp;&nbsp;&nbsp;&nbsp; c = a &lt;&lt; 2;&nbsp;&nbsp;&nbsp;&nbsp; /* 240 = 1111 0000 */\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"a &lt;&lt; 2 = \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; c = a &gt;&gt; 2;&nbsp;&nbsp;&nbsp;&nbsp; /* 215 = 1111 */\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"a &gt;&gt; 2&nbsp; = \" + c );\n&nbsp;&nbsp;\n  &nbsp;&nbsp; c = a &gt;&gt;&gt; 2;&nbsp;&nbsp;&nbsp;&nbsp; /* 215 = 0000 1111 */\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"a &gt;&gt;&gt; 2 = \" + c );\n&nbsp; }\n}&nbsp;\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">a &amp; b = 12\na | b = 61\na ^ b = 49\n~a = -61\na &lt;&lt; 2 = 240 \na &gt;&gt; 2 = 15\na &gt;&gt;&gt; 2 = 15\n</pre><hr><h2>逻辑运算符</h2><p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p><p>操作符描述例子&amp;&amp;称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。（A &amp;&amp; B）为假。| |称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。（A | | B）为真。！称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。！（A &amp;&amp; B）为真。</p><h3>实例</h3><p>下面的简单示例程序演示了逻辑运算符。复制并粘贴下面的Java程序并保存为Test.java文件，然后编译并运行这个程序：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n&nbsp; public static void main(String args[]) {\n&nbsp;&nbsp;&nbsp;&nbsp; boolean a = true;\n&nbsp;&nbsp;&nbsp;&nbsp; boolean b = false;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"a &amp;&amp; b = \" + (a&amp;&amp;b));\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"a || b = \" + (a||b) );\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"!(a &amp;&amp; b) = \" + !(a &amp;&amp; b));\n&nbsp; }\n}&nbsp;\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">a &amp;&amp; b = false\na || b = true\n!(a &amp;&amp; b) = true\n</pre><hr><h2>赋值运算符</h2><p>下面是Java语言支持的赋值运算符：</p><p>操作符描述例子=简单的赋值运算符，将右操作数的值赋给左侧操作数C = A + B将把A + B得到的值赋给C+ =加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数C + = A等价于C = C + A- =减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数C - = A等价于C = C -</p><p>&nbsp;A* =乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数C * = A等价于C = C * A/ =除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数C / = A等价于C = C / A（％）=取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数C％= A等价于C = C％A&lt;&lt; =左移位赋值运算符C &lt;&lt; = 2等价于C = C &lt;&lt; 2&gt;&gt; =右移位赋值运算符C &gt;&gt; = 2等价于C = C &gt;&gt; 2＆=按位与赋值运算符C＆= 2等价于C = C＆2^ =按位异或赋值操作符C ^ = 2等价于C = C ^ 2| =按位或赋值操作符C | = 2等价于C = C | 2</p><h3>实例</h3><p>下面的简单示例程序演示了赋值运算符。复制并粘贴下面的Java程序并保存为Test.java文件，然后编译并运行这个程序：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n&nbsp; public static void main(String args[]) {\n&nbsp;&nbsp;&nbsp;&nbsp; int a = 10;\n&nbsp;&nbsp;&nbsp;&nbsp; int b = 20;\n&nbsp;&nbsp;&nbsp;&nbsp; int c = 0;\n&nbsp;&nbsp;&nbsp;&nbsp; c = a + b;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c = a + b = \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; c += a ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c += a&nbsp; = \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; c -= a ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c -= a = \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; c *= a ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c *= a = \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; a = 10;\n&nbsp;&nbsp;&nbsp;&nbsp; c = 15;\n&nbsp;&nbsp;&nbsp;&nbsp; c /= a ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c /= a = \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; a = 10;\n&nbsp;&nbsp;&nbsp;&nbsp; c = 15;\n&nbsp;&nbsp;&nbsp;&nbsp; c %= a ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c %= a&nbsp; = \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; c &lt;&lt;= 2 ; \n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c &lt;&lt;= 2 = \" + c ); \n&nbsp;&nbsp;&nbsp;&nbsp; c &gt;&gt;= 2 ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c &gt;&gt;= 2 = \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; c &gt;&gt;= 2 ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c &gt;&gt;= a = \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; c &amp;= a ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c &amp;= a&nbsp;= \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; c ^= a ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c ^= a&nbsp;= \" + c );\n&nbsp;&nbsp;&nbsp;&nbsp; c |= a ;\n&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"c |= a&nbsp;= \" + c );\n&nbsp; }\n}&nbsp;\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">c = a + b = 30\nc += a  = 40\nc -= a = 30\nc *= a = 300\nc /= a = 1\nc %= a  = 5\nc &lt;&lt;= 2 = 20 c &gt;&gt;= 2 = 5\nc &gt;&gt;= 2 = 1\nc &amp;= a  = 0\nc ^= a   = 10\nc |= a   = 10\n</pre><hr><h2>条件运算符（?:）</h2><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p><pre class=\"ql-syntax\" spellcheck=\"false\">variable x = (expression) ? value if true : value if false\n</pre><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n   public static void main(String args[]){\n      int a , b;   \n      a = 10;    \n      b = (a == 1) ? 20: 30;    \n      System.out.println( \"Value of b is : \" +  b );\n      b = (a == 10) ? 20: 30;    \n      System.out.println( \"Value of b is : \" + b );\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Value of b is : 30\nValue of b is : 20\n</pre><hr><h2>instanceof 运算符</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p>instanceof运算符使用格式如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">( Object reference variable ) instanceof  (class/interface type)\n</pre><p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p><p>下面是一个例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">String name = \'James\';\nboolean result = name instanceof String; // 由于name是String类型，所以返回真\n</pre><p>如果被比较的对象兼容于右侧类型,该运算符仍然返回true。</p><p>看下面的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">class Vehicle {}\n\npublic class Car extends Vehicle {\n   public static void main(String args[]){\n      Vehicle a = new Car();\n      boolean result =  a instanceof Car;\n      System.out.println( result);\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">true\n</pre><hr><h2>Java运算符优先级</h2><p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</p><p>例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。</p><p>再如，x = 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。</p><p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p><p>类别操作符关联性后缀() [] . (点操作符)左到右一元+ + - ！〜从右到左乘性&nbsp;* /％左到右加性&nbsp;+ -左到右移位&nbsp;&gt;&gt; &gt;&gt;&gt;&nbsp;&lt;&lt;&nbsp;左到右关系&nbsp;&gt;&gt; = &lt;&lt; =&nbsp;左到右相等&nbsp;==&nbsp;!=左到右按位与＆左到右按位异或^左到右按位或|左到右逻辑与&amp;&amp;左到右逻辑或| |左到右条件？：从右到左赋值= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =从右到左逗号，左到右</p>');
INSERT INTO `knowledge` VALUES (10, 2, 'Java 循环结构 - for, while 及 do…while', 1002, 'teacher', '2022-12-09 08:09:23', '<h2><strong>Java循环结构</strong></h2><p><br></p><p>顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。</p><p>Java中有三种主要的循环结构：</p><ul><li>while循环</li><li>do…while循环</li><li>for循环</li></ul><p>在Java5中引入了一种主要用于数组的增强型for循环。</p><hr><h2>while循环</h2><p>while是最基本的循环，它的结构为：</p><pre class=\"ql-syntax\" spellcheck=\"false\">while( 布尔表达式 ) {\n	//循环内容\n}\n</pre><p>只要布尔表达式为true，循环体会一直执行下去。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n   public static void main(String args[]) {\n      int x = 10;\n      while( x &lt; 20 ) {\n          System.out.print(\"value of x : \" + x );\n          x++;\n          System.out.print(\"\\n\");\n      }\n   } \n} \n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">value of x : 10\nvalue of x : 11\nvalue of x : 12\nvalue of x : 13\nvalue of x : 14\nvalue of x : 15\nvalue of x : 16\nvalue of x : 17\nvalue of x : 18\nvalue of x : 19\n</pre><hr><h2>do…while循环</h2><p>对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p>do…while循环和while循环相似，不同的是，do…while循环至少会执行一次。</p><pre class=\"ql-syntax\" spellcheck=\"false\">do {\n       //代码语句\n}while(布尔表达式);\n</pre><p><strong>注意：</strong>布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为true，则语句块一直执行，直到布尔表达式的值为false。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]){\n      int x = 10;\n\n      do{\n         System.out.print(\"value of x : \" + x );\n         x++;\n         System.out.print(\"\\n\");\n      }while( x &lt; 20 );    } } \n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">value of x : 10\nvalue of x : 11\nvalue of x : 12\nvalue of x : 13\nvalue of x : 14\nvalue of x : 15\nvalue of x : 16\nvalue of x : 17\nvalue of x : 18\nvalue of x : 19\n</pre><hr><h2>for循环</h2><p>虽然所有循环结构都可以用while或者do...while表示，但Java提供了另一种语句 —— for循环，使一些循环结构变得更加简单。</p><p>for循环执行的次数是在执行前就确定的。语法格式如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">for(初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n</pre><p>关于for循环有以下几点说明：</p><ul><li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li><li>然后，检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li><li>执行一次循环后，更新循环控制变量。</li><li>再次检测布尔表达式。循环执行上面的过程。</li></ul><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n   public static void main(String args[]) {\n      for(int x = 10; x &lt; 20; x = x+1) {\n          System.out.print(\"value of x : \" + x );\n          System.out.print(\"\\n\");\n      }\n   } \n} \n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">value of x : 10\nvalue of x : 11\nvalue of x : 12\nvalue of x : 13\nvalue of x : 14\nvalue of x : 15\nvalue of x : 16\nvalue of x : 17\nvalue of x : 18\nvalue of x : 19\n</pre><hr><h2>Java增强for循环</h2><p>Java5引入了一种主要用于数组的增强型for循环。</p><p>Java增强for循环语法格式如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">for(声明语句 : 表达式)\n{\n   //代码句子\n}\n</pre><p><strong>声明语句：</strong>声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p><p><strong>表达式：</strong>表达式是要访问的数组名，或者是返回值为数组的方法。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]){\n      int [] numbers = {10, 20, 30, 40, 50};\n\n      for(int x : numbers ){\n         System.out.print( x );\n         System.out.print(\",\");\n      }\n      System.out.print(\"\\n\");\n      String [] names ={\"James\", \"Larry\", \"Tom\", \"Lacy\"};\n      for( String name : names ) {\n         System.out.print( name );\n         System.out.print(\",\");\n      }\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">10,20,30,40,50,\nJames,Larry,Tom,Lacy,\n</pre><hr><h2>break关键字</h2><p>break主要用在循环语句或者switch语句中，用来跳出整个语句块。</p><p>break跳出最里层的循环，并且继续执行该循环下面的语句。</p><h3>语法</h3><p>break的用法很简单，就是循环结构中的一条语句：</p><pre class=\"ql-syntax\" spellcheck=\"false\">break;\n</pre><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]) {\n      int [] numbers = {10, 20, 30, 40, 50};\n\n      for(int x : numbers ) {\n         if( x == 30 ) {\n	      break;\n         }\n         System.out.print( x );\n         System.out.print(\"\\n\");\n      }\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">10\n20\n</pre><hr><h2>continue关键字</h2><p>continue适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p><p>在for循环中，continue语句使程序立即跳转到更新语句。</p><p>在while或者do…while循环中，程序立即跳转到布尔表达式的判断语句。</p><h3>语法</h3><p>continue就是循环体中一条简单的语句：</p><pre class=\"ql-syntax\" spellcheck=\"false\">continue;\n</pre><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]) {\n      int [] numbers = {10, 20, 30, 40, 50};\n\n      for(int x : numbers ) {\n         if( x == 30 ) {\n	      continue;\n         }\n         System.out.print( x );\n         System.out.print(\"\\n\");\n      }\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">10\n20\n40\n50\n</pre><p><br></p>');
INSERT INTO `knowledge` VALUES (11, 2, 'Java 分支结构 - if…else/switch', 1002, 'teacher', '2022-12-09 08:10:53', '<h2 class=\"ql-align-center\"><strong>Java分支结构</strong></h2><p><br></p><p>顺序结构只能顺序执行，不能进行判断和选择，因此需要分支结构。</p><p>Java有两种分支结构：</p><ul><li>if语句</li><li>switch语句</li></ul><hr><h2>if语句</h2><p>一个if语句包含一个布尔表达式和一条或多条语句。</p><h3>语法</h3><p>If 语句的用语法如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">if(布尔表达式)\n{\n   //如果布尔表达式为true将执行的语句\n}\n</pre><p>如果布尔表达式的值为 true，则执行if语句中的代码块。否则执行 If 语句块后面的代码。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]){\n      int x = 10;\n\n      if( x &lt; 20 ){\n          System.out.print(\"这是 if 语句\"); \n      }\n   }\n} \n</pre><p>以上代码编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">这是 if 语句\n</pre><hr><h2>if...else 语句</h2><p>if 语句后面可以跟 else 语句，当if语句的布尔表达式值为 false 时，else 语句块会被执行。</p><h3>语法</h3><p>if…else 的用法如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">if(布尔表达式){\n   //如果布尔表达式的值为true\n}else{\n   //如果布尔表达式的值为false\n}\n</pre><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]){\n      int x = 30;\n\n      if( x &lt; 20 ){\n          System.out.print(\"这是 if 语句\");\n       }else{\n          System.out.print(\"这是 else 语句\");\n       }\n   }\n} \n</pre><p>以上代码编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">这是 else 语句\n</pre><hr><h2>if...else if...else 语句</h2><p>if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。</p><p>使用if，else if，else语句的时候，需要注意下面几点：</p><ul><li>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。</li><li>If 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li><li>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</li></ul><h3>语法</h3><p>if...else 语法格式如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">if(布尔表达式 1){\n   //如果布尔表达式 1的值为true执行代码\n}else if(布尔表达式 2){\n   //如果布尔表达式 2的值为true执行代码\n}else if(布尔表达式 3){\n   //如果布尔表达式 3的值为true执行代码\n}else {\n   //如果以上布尔表达式都不为true执行代码\n}\n</pre><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]){\n      int x = 30;\n\n      if( x == 10 ){\n         System.out.print(\"Value of X is 10\");\n      }else if( x == 20 ){\n         System.out.print(\"Value of X is 20\");\n      }else if( x == 30 ){\n         System.out.print(\"Value of X is 30\");\n      }else{\n         System.out.print(\"这是 else 语句\");\n      }\n   }\n}\n</pre><p>以上代码编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Value of X is 30\n</pre><hr><h2>嵌套的 if…else 语句</h2><p>使用嵌套的 if-else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。</p><h3>语法</h3><p>嵌套的 if…else 语法格式如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">if(布尔表达式 1){\n   ////如果布尔表达式 1的值为true执行代码\n   if(布尔表达式 2){\n      ////如果布尔表达式 2的值为true执行代码\n   }\n}\n</pre><p>你可以像 if 语句一样嵌套 else if...else。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]){\n      int x = 30;\n      int y = 10;\n\n      if( x == 30 ){\n         if( y == 10 ){\n             System.out.print(\"X = 30 and Y = 10\");\n          }\n       }\n    }\n}\n</pre><p>以上代码编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">X = 30 and Y = 10\n</pre><hr><h2>switch 语句</h2><p>switch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p><h3>语法</h3><p>switch 语法格式如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">switch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n</pre><p>switch 语句有如下规则：</p><ul><li>switch 语句中的变量类型只能为 byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li><li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li><li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li><li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到break语句出现才会跳出 switch 语句。</li><li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li><li>switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li></ul><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]){\n      //char grade = args[0].charAt(0);\n      char grade = \'C\';\n\n      switch(grade)\n      {\n         case \'A\' :\n            System.out.println(\"优秀\"); \n            break;\n         case \'B\' :\n         case \'C\' :\n            System.out.println(\"良好\");\n            break;\n         case \'D\' :\n            System.out.println(\"及格\");\n         case \'F\' :\n            System.out.println(\"你需要继续努力\");\n            break;\n         default :\n            System.out.println(\"无效等级\");\n      }\n      System.out.println(\"你的等级是 \" + grade);\n   }\n}\n</pre><p>以上代码编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">良好\n你的等级是 C\n</pre><p><br></p>');
INSERT INTO `knowledge` VALUES (12, 2, 'Java Number类', 1003, 'teacher', '2022-12-09 08:11:26', '<h2><strong>Java Number类</strong></h2><p><br></p><p>一般情况下我们会使用数据的基本数据类型：byte、int、short、long、double、float、boolean、char；</p><p>对应的包装类型也有八种：Byte、Integer、Short、Long、Double、Float、Character、Boolean;</p><p>包装类型都是用 final 声明了，不可以被继承重写；在实际情况中编译器会自动的将基本数据类型装箱成对象类型，或者将对象类型拆箱成基本数据类型；如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public static void main(String[] args) {\n	int num1 = 1;\n	//将基本数据类型装箱成对象包装类型\n	Integer num2 = num1;\n	Integer num3 = 3;\n	//将对象数据类拆箱\n	int num4 = num3;\n}\n</pre><p>Number 类是 java.lang 包下的一个抽象类，提供了将包装类型拆箱成基本类型的方法，所有基本类型（数据类型）的包装类型都继承了该抽象类，并且是final声明不可继承改变；</p><pre class=\"ql-syntax\" spellcheck=\"false\">package java.lang;\n\npublic abstract class Number implements java.io.Serializable {\n\n    public abstract int intValue();\n\n    public abstract long longValue();\n\n    public abstract float floatValue();\n\n    public abstract double doubleValue();\n\n    public byte byteValue() {\n        return (byte)intValue();\n    }\n\n    public short shortValue() {\n        return (short)intValue();\n    }\n\n    private static final long serialVersionUID = -8742448824652078965L;\n}\n</pre><p>包装类基本数据类型BooleanbooleanBytebyteShortshortIntegerintLonglongCharactercharFloatfloatDoubledouble</p><p><img src=\"http://localhost:8080/static/picture/1459506097805010.jpg\"></p><p>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p><p>下面是一个装箱与拆箱的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;Test{\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;x&nbsp;=&nbsp;5;&nbsp;//&nbsp;boxes&nbsp;int&nbsp;to&nbsp;an&nbsp;Integer&nbsp;object\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;&nbsp;x&nbsp;+&nbsp;10;&nbsp;&nbsp;&nbsp;//&nbsp;unboxes&nbsp;the&nbsp;Integer&nbsp;to&nbsp;a&nbsp;int\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(x);&nbsp;\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">15\n</pre><p>当x被赋为整型值时，由于 x 是一个对象，所以编译器要对x进行装箱。然后，为了使x能进行加运算，所以要对x进行拆箱。</p><hr><h1>Java Math类</h1><p>Java&nbsp;的&nbsp;Math&nbsp;包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p><p>Math&nbsp;的方法都被定义为&nbsp;static&nbsp;形式，通过&nbsp;Math&nbsp;类可以在主函数中直接调用。</p><p><strong>实例</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {  \n    public static void main (String []args)  \n    {  \n        System.out.println(\"90 度的正弦值：\" + Math.sin(Math.PI/2));  \n        System.out.println(\"0度的余弦值：\" + Math.cos(0));  \n        System.out.println(\"60度的正切值：\" + Math.tan(Math.PI/3));  \n        System.out.println(\"1的反正切值： \" + Math.atan(1));  \n        System.out.println(\"π/2的角度值：\" + Math.toDegrees(Math.PI/2));  \n        System.out.println(Math.PI);  \n    }  \n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">90 度的正弦值：1.0\n0度的余弦值：1.0\n60度的正切值：1.7320508075688767\n1的反正切值： 0.7853981633974483\nπ/2的角度值：90.0\n3.141592653589793\n</pre><p><br></p><h2>Number&nbsp;&amp;&nbsp;Math&nbsp;类方法</h2><p>下面的表中列出的是常用的 Number 类和 Math 类的方法：</p><p>序号方法与描述1xxxValue()</p><p>将number对象转换为xxx数据类型的值并返回。2compareTo()</p><p>将number对象与参数比较。3equals()</p><p>判断number对象是否与参数相等。4valueOf()</p><p>返回一个Integer对象指定的内置数据类型5toString()</p><p>以字符串形式返回值。6parseInt()</p><p>将字符串解析为int类型。7abs()</p><p>返回参数的绝对值。8ceil()</p><p>返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。9floor()</p><p>返回小于等于（&lt;=）给定参数的最大整数 。10rint()</p><p>返回与参数最接近的整数。返回类型为double。11round()</p><p>返回一个最接近的int、long型值。12min()</p><p>返回两个参数中的最小值。13max()</p><p>返回两个参数中的最大值。14exp()</p><p>返回自然数底数e的参数次方。15log()</p><p>返回参数的自然数底数的对数值。16pow()</p><p>返回第一个参数的第二个参数次方。17sqrt()</p><p>求参数的算术平方根。18sin()</p><p>求指定double类型参数的正弦值。19cos()</p><p>求指定double类型参数的余弦值。20tan()</p><p>求指定double类型参数的正切值。21asin()</p><p>求指定double类型参数的反正弦值。22acos()</p><p>求指定double类型参数的反余弦值。23atan()</p><p>求指定double类型参数的反正切值。24atan2()</p><p>将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。25toDegrees()</p><p>将参数转化为角度。26toRadians()</p><p>将角度转换为弧度。27random()</p><p>返回一个随机数。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (13, 2, 'Java Character类', 1003, 'teacher', '2022-12-09 08:12:18', '<h2><strong>Java Character类</strong></h2><p><br></p><p>本章节我们主要向大家介绍一下Java Character类，以及Character类的用法。</p><p><br></p><h3>Java Character类</h3><p>使用字符时，我们通常使用的是内置数据类型 char。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">char ch = \'a\';\n\n// Unicode for uppercase Greek omega character\nchar uniChar = \'\\u039A\'; \n\n// 字符数组\nchar[] charArray = { \'a\', \'b\', \'c\', \'d\', \'e\' }; \n</pre><p>然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java 语言为内置数据类型 char 提供了包装类 Character 类。</p><p>Character类的用法：Character 类提供了一系列方法来操纵字符，你可以使用 Character 的构造方法创建一个 Character 类对象，例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Character ch = new Character(\'a\');\n</pre><p>在某些情况下，Java 编译器会自动创建一个 Character 对象。</p><p>例如，将一个 char 类型的参数传递给需要一个 Character 类型参数时，那么编译器会自动地将 char 类型参数转换为 Character 对象。 这种特征称为装箱，反过来称为拆箱。&nbsp;</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">// Here following primitive char \'a\'\n// is boxed into the Character object ch\nCharacter ch = \'a\';\n\n// Here primitive \'x\' is boxed for method test,\n// return is unboxed to char \'c\'\nchar c = test(\'x\');\n</pre><hr><h2>转义序列</h2><p>前面有反斜杠（\\）的字符代表转义字符，它对编译器来说是有特殊含义的。</p><p>下面列表展示了 Java 的转义序列：</p><p>转义序列描述\\t在文中该处插入一个tab键\\b在文中该处插入一个后退键\\n在文中该处换行\\r在文中该处插入回车\\f在文中该处插入换页符\\\'在文中该处插入单引号\\\"在文中该处插入双引号\\\\在文中该处插入反斜杠</p><h3>实例</h3><p>当打印语句遇到一个转义序列时，编译器可以正确地对其进行解释。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test {\n\n   public static void main(String args[]) {\n      System.out.println(\"She said \\\"Hello!\\\" to me.\");\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">She said \"Hello!\" to me.\n</pre><hr><h2>Character 方法</h2><p>下面是 Character 类的方法：</p><p>序号方法与描述1isLetter()</p><p>是否是一个字母2isDigit()</p><p>是否是一个数字字符3isWhitespace()</p><p>是否一个空格4isUpperCase()</p><p>是否是大写字母5isLowerCase()</p><p>是否是小写字母6toUpperCase()</p><p>指定字母的大写形式7toLowerCase()</p><p>指定字母的小写形式8toString()</p><p>返回字符的字符串形式，字符串的长度仅为1</p><h3><br></h3><h3>初学者会经常使用的几个方法</h3><p>public static boolean isUpperCase(char ch): 判断给定的字符是否是大写字符；</p><p><br></p><p>public static boolean isLowerCase(char ch): 判断给定的字符是否是小写字符；</p><p><br></p><p>public static boolean isDigit(char ch): 判断给定的字符是否是数字字符；</p><p><br></p><p>这三个句子里的boolean代表，这三个方法使用后的返回值是 boolean 型。</p><p><br></p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Java {\n\n	public static void main(String[] args) {\n		Character ch = new Character(\'X\');\n		\n		System.out.println(Character.isUpperCase(ch));\n		//Character.isUpperCase(ch) 用于判断括号里的字母是否为大写\n		System.out.println(Character.isLowerCase(ch));\n		//Character.isLowerCase(ch) 用于判断括号里的字母是否为小写\n		System.out.println(Character.isDigit(ch));\n		//Character.isDigit(ch) 用于判断括号里的内容是否为数字\n	}\n}\n</pre><p>运行结果为：</p><pre class=\"ql-syntax\" spellcheck=\"false\">true\nfalse\nfalse\n</pre><p>对于方法的完整列表，请参考的 java.lang.Character API 规范。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (14, 2, 'Java String类', 1003, 'teacher', '2022-12-09 08:13:37', '<h2><strong>Java String类</strong></h2><p><br></p><p>字符串广泛应用在Java编程中，在Java中字符串属于对象，Java提供了String类来创建和操作字符串。</p><h2><br></h2><h3>创建字符串</h3><p>创建字符串最简单的方式如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">String greeting = \"Hello world!\";\n</pre><p>在代码中遇到字符串常量时，这里的值是 \"Hello world!\" ，编译器会使用该值创建一个 String 对象。</p><p>和其它对象一样，可以使用关键字和构造方法来创建String对象。</p><p>String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class StringDemo{\n\n   public static void main(String args[]){\n      char[] helloArray = { \'h\', \'e\', \'l\', \'l\', \'o\', \'.\'};\n      String helloString = new String(helloArray);  \n      System.out.println( helloString );\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">hello.\n</pre><p><strong>注意:</strong>String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。 如果需要对字符串做很多修改，那么应该选择使用&nbsp;<a href=\"http://localhost:8080/java-stringbuffer.html\" rel=\"noopener noreferrer\" target=\"_blank\">StringBuffer &amp; StringBuilder 类</a>。</p><hr><h3>字符串长度</h3><p>用于获取有关对象的信息的方法称为访问器方法。</p><p>String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。</p><p>下面的代码执行后，len 变量等于 17:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class StringDemo {\n\n   public static void main(String args[]) {\n      String palindrome = \"Dot saw I was Tod\";\n      int len = palindrome.length();\n      System.out.println( \"String Length is : \" + len );\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">String Length is : 17\n</pre><hr><h2>连接字符串</h2><p>String 类提供了连接两个字符串的方法：</p><pre class=\"ql-syntax\" spellcheck=\"false\">string1.concat(string2);\n</pre><p>返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">\"My name is \".concat(\"Zara\");\n</pre><p>更常用的是使用\'+\'操作符来连接字符串，如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">\"Hello,\" + \" world\" + \"!\"\n</pre><p>结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">\"Hello, world!\"\n</pre><p>下面是一个例子:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class StringDemo {\n   public static void main(String args[]) {     \n      String string1 = \"saw I was \";     \n      System.out.println(\"Dot \" + string1 + \"Tod\");  \n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Dot saw I was Tod\n</pre><hr><h2>创建格式化字符串</h2><p>我们知道输出格式化数字可以使用 printf() 和 format() 方法。String 类使用静态方法 format() 返回一个 String 对象而不是 PrintStream 对象。</p><p>String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">System.out.printf(\"The value of the float variable is \" +\n                  \"%f, while the value of the integer \" +\n                  \"variable is %d, and the string \" +\n                  \"is %s\", floatVar, intVar, stringVar);\n</pre><p>你也可以这样写</p><pre class=\"ql-syntax\" spellcheck=\"false\">String fs;\nfs = String.format(\"The value of the float variable is \" +\n                   \"%f, while the value of the integer \" +\n                   \"variable is %d, and the string \" +\n                   \"is %s\", floatVar, intVar, stringVar);\nSystem.out.println(fs);\n</pre><hr><h2>String 方法</h2><p>下面是 String 类支持的常用方法，更多详细，参看 Java API 文档:</p><p>SN(序号)方法描述1char charAt(int index)</p><p>返回指定索引处的 char 值。2int compareTo(Object o)</p><p>把这个字符串和另一个对象比较。3int compareTo(String anotherString)</p><p>按字典顺序比较两个字符串。4int compareToIgnoreCase(String str)</p><p>按字典顺序比较两个字符串，不考虑大小写。5String concat(String str)</p><p>将指定字符串连接到此字符串的结尾。6boolean contentEquals(StringBuffer sb)</p><p>当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。7static String copyValueOf(char[] data)</p><p>返回指定数组中表示该字符序列的 String。8static String copyValueOf(char[] data, int offset, int count)</p><p>返回指定数组中表示该字符序列的 String。9boolean endsWith(String suffix)</p><p>测试此字符串是否以指定的后缀结束。10boolean equals(Object anObject)</p><p>将此字符串与指定的对象比较。11boolean equalsIgnoreCase(String anotherString)</p><p>将此 String 与另一个 String 比较，不考虑大小写。12byte[] getBytes()</p><p>&nbsp;使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。13byte[] getBytes(String charsetName)</p><p>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。14void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。15int hashCode()</p><p>返回此字符串的哈希码。16int indexOf(int ch)</p><p>返回指定字符在此字符串中第一次出现处的索引。17int indexOf(int ch, int fromIndex)</p><p>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。18int indexOf(String str)</p><p>&nbsp;返回指定子字符串在此字符串中第一次出现处的索引。19int indexOf(String str, int fromIndex)</p><p>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。20String intern()</p><p>&nbsp;返回字符串对象的规范化表示形式。21int lastIndexOf(int ch)</p><p>&nbsp;返回指定字符在此字符串中最后一次出现处的索引。22int lastIndexOf(int ch, int fromIndex)</p><p>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。23int lastIndexOf(String str)</p><p>返回指定子字符串在此字符串中最右边出现处的索引。24int lastIndexOf(String str, int fromIndex)</p><p>&nbsp;返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。25int length()</p><p>返回此字符串的长度。26boolean matches(String regex)</p><p>告知此字符串是否匹配给定的正则表达式。27boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</p><p>测试两个字符串区域是否相等。28boolean regionMatches(int toffset, String other, int ooffset, int len)</p><p>测试两个字符串区域是否相等。29String replace(char oldChar, char newChar)</p><p>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。30String replaceAll(String regex, String replacement</p><p>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。31String replaceFirst(String regex, String replacement)</p><p>&nbsp;使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。32String[] split(String regex)</p><p>根据给定正则表达式的匹配拆分此字符串。33String[] split(String regex, int limit)</p><p>根据匹配给定的正则表达式来拆分此字符串。34boolean startsWith(String prefix)</p><p>测试此字符串是否以指定的前缀开始。35boolean startsWith(String prefix, int toffset)</p><p>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。36CharSequence subSequence(int beginIndex, int endIndex)</p><p>&nbsp;返回一个新的字符序列，它是此序列的一个子序列。37String substring(int beginIndex)</p><p>返回一个新的字符串，它是此字符串的一个子字符串。38String substring(int beginIndex, int endIndex)</p><p>返回一个新字符串，它是此字符串的一个子字符串。39char[] toCharArray()</p><p>将此字符串转换为一个新的字符数组。40String toLowerCase()</p><p>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。41String toLowerCase(Locale locale)</p><p>&nbsp;使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。42String toString()</p><p>&nbsp;返回此对象本身（它已经是一个字符串！）。43String toUpperCase()</p><p>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。44String toUpperCase(Locale locale)</p><p>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。45String trim()</p><p>返回字符串的副本，忽略前导空白和尾部空白。46static String valueOf(primitive data type x)</p><p>返回给定data type类型x参数的字符串表示形式。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (15, 2, 'Java StringBuffer 和 StringBuilder 类', 1003, 'teacher', '2022-12-09 08:14:15', '<h2><strong style=\"background-color: rgb(240, 247, 255);\">Java StringBuffer 和 StringBuilder 类</strong></h2><p><br></p><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和String类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Test{\n\n    public static void main(String args[]){\n       StringBuffer sBuffer = new StringBuffer(\" test\");\n       sBuffer.append(\" String Buffer\");\n       System.out.println(sBuffer);  \n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">test String Buffer\n</pre><h2>StringBuffer 方法</h2><p>以下是 StringBuffer 类支持的主要方法：</p><p>序号方法描述1public StringBuffer append(String s)</p><p>将指定的字符串追加到此字符序列。2public StringBuffer reverse()</p><p>&nbsp;将此字符序列用其反转形式取代。3public delete(int start, int end)</p><p>移除此序列的子字符串中的字符。4public insert(int offset, int i)</p><p>将&nbsp;<code>int</code>&nbsp;参数的字符串表示形式插入此序列中。5replace(int start, int end, String str)</p><p>使用给定&nbsp;<code>String</code>&nbsp;中的字符替换此序列的子字符串中的字符。</p><p>下面的列表里的方法和 String 类的方法类似：</p><p>序号方法描述1int capacity()</p><p>返回当前容量。2char charAt(int index)</p><p>返回此序列中指定索引处的&nbsp;<code>char</code>&nbsp;值。3void ensureCapacity(int minimumCapacity)</p><p>确保容量至少等于指定的最小值。4void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</p><p>将字符从此序列复制到目标字符数组&nbsp;<code>dst</code>。5int indexOf(String str)</p><p>返回第一次出现的指定子字符串在该字符串中的索引。6int indexOf(String str, int fromIndex)</p><p>从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。7int lastIndexOf(String str)</p><p>返回最右边出现的指定子字符串在此字符串中的索引。8int lastIndexOf(String str, int fromIndex)</p><p>返回最后一次出现的指定子字符串在此字符串中的索引。9int length()</p><p>&nbsp;返回长度（字符数）。10void setCharAt(int index, char ch)</p><p>将给定索引处的字符设置为&nbsp;<code>ch</code>。11void setLength(int newLength)</p><p>设置字符序列的长度。12CharSequence subSequence(int start, int end)</p><p>返回一个新的字符序列，该字符序列是此序列的子序列。13String substring(int start)</p><p>返回一个新的&nbsp;<code>String</code>，它包含此字符序列当前所包含的字符子序列。14String substring(int start, int end)</p><p>返回一个新的&nbsp;<code>String</code>，它包含此序列当前所包含的字符子序列。15String toString()</p><p>返回此序列中数据的字符串表示形式。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (16, 2, 'Java 数组', 1002, 'teacher', '2022-12-09 08:14:36', '<h2><strong>Java数组</strong></h2><p><br></p><p><br></p><p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p><p>你可以声明一个数组变量，如 numbers[100] 来代替直接声明 100 个独立变量 number0，number1，....，number99。</p><p>本教程将为大家介绍Java数组的声明、创建和初始化，并给出其对应的代码。</p><hr><h2>声明数组变量</h2><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p><pre class=\"ql-syntax\" spellcheck=\"false\">dataType[]&nbsp;arrayRefVar;&nbsp;&nbsp;&nbsp;//&nbsp;首选的方法\n\n或\n\ndataType&nbsp;arrayRefVar[];&nbsp;&nbsp;//&nbsp;效果相同，但不是首选方法\n</pre><p><strong>注意:</strong>&nbsp;建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让&nbsp;C/C++&nbsp;程序员能够快速理解 java 语言。</p><h3>实例</h3><p>下面是这两种语法的代码示例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">double[]&nbsp;myList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;首选的方法\n\n或\n\ndouble&nbsp;myList[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;效果相同，但不是首选方法\n</pre><hr><h2>创建数组</h2><p>Java 语言使用 new操作符来创建数组，语法如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">arrayRefVar&nbsp;=&nbsp;new&nbsp;dataType[arraySize];\n</pre><p>上面的语法语句做了两件事：</p><ul><li>一、使用 dataType[arraySize] 创建了一个数组。</li><li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li></ul><p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">dataType[]&nbsp;arrayRefVar&nbsp;=&nbsp;new&nbsp;dataType[arraySize];\n</pre><p>另外，你还可以使用如下的方式创建数组。</p><pre class=\"ql-syntax\" spellcheck=\"false\">dataType[]&nbsp;arrayRefVar&nbsp;=&nbsp;{value0,&nbsp;value1,&nbsp;...,&nbsp;valuek};\n</pre><p>数组的元素是通过索引访问的。数组索引从0开始，所以索引值从 0 到 arrayRefVar.length-1。</p><p>那么当数组开辟空间之后，就可以采用如下的方式的操作：</p><ul><li>数组的访问通过索引完成，即：“数组名称[索引]”，但是需要注意的是，数组的索引从0开始，所以索引的范围就是0&nbsp;~ 数组长度-1，例如开辟了3个空间的数组，所以可以使用的索引是：0,1,2，如果此时访问的时候超过了数组的索引范围，会产生 java.lang.ArrayIndexOutOfBoundsException&nbsp;异常信息；</li><li>当我们数组采用动态初始化开辟空间后，数组里面的每一个元素都是该数组对应数据类型的默认值；</li><li>数组本身是一个有序的集合操作，所以对于数组的内容操作往往会采用循环的模式完成，数组是一个有限的数据集合，所以应该使用&nbsp;for&nbsp;循环。</li><li>在&nbsp;Java&nbsp;中提供有一种动态取得数组长度的方式：数组名称.length；</li></ul><p>示例： 定义一个int型数组</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class ArrayDemo {\n	public static void main(String args[]) {\n		int data[] = new int[3]; /*开辟了一个长度为3的数组*/\n		data[0] = 10; // 第一个元素\n		data[1] = 20; // 第二个元素\n		data[2] = 30; // 第三个元素\n		for(int x = 0; x &lt; data.length; x++) {\n			System.out.println(data[x]); //通过循环控制索引\n		}\n	}\n}\n</pre><p>数组本身除了声明并开辟空间之外还有另外一种开辟模式。</p><p>示例：&nbsp;采用分步的模式开辟数组空间</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class ArrayDemo {\n	public static void main(String args[]) {\n		int data[] = null; \n		data = new int[3]; /*开辟了一个长度为3的数组*/\n		data[0] = 10; // 第一个元素\n		data[1] = 20; // 第二个元素\n		data[2] = 30; // 第三个元素\n		for(int x = 0; x &lt; data.length; x++) {\n			System.out.println(data[x]); //通过循环控制索引\n		}\n	}\n}\n</pre><p>但是千万要记住，数组属于引用数据类型，所以在数组使用之前一定要开辟空间（实例化），如果使用了没有开辟空间的数组，则一定会出现&nbsp;<code>NullPointerException</code>&nbsp;异常信息：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class ArrayDemo {\n	public static void main(String args[]) {\n		int data[] = null; \n		System.out.println(data[x]);\n	}\n}\n</pre><p>这一原则和之前讲解的对象是完全相同的。</p><p>数组在开发之中一定会使用，但是像上面的操作很少。在以后的实际开发之中，会更多的使用数组概念，而直接使用，大部分情况下都只是做一个&nbsp;for&nbsp;循环输出。</p><hr><h2>处理数组</h2><p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 foreach 循环。</p><h3>示例</h3><p>该实例完整地展示了如何创建、初始化和操纵数组：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;TestArray&nbsp;{\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double[]&nbsp;myList&nbsp;=&nbsp;{1.9,&nbsp;2.9,&nbsp;3.4,&nbsp;3.5};\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;打印所有数组元素\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;myList.length;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(myList[i]&nbsp;+&nbsp;\"&nbsp;\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;计算所有元素的总和\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;total&nbsp;=&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;myList.length;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;+=&nbsp;myList[i];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Total&nbsp;is&nbsp;\"&nbsp;+&nbsp;total);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;查找最大元素\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;max&nbsp;=&nbsp;myList[0];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;myList.length;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(myList[i]&nbsp;&gt;&nbsp;max)&nbsp;max&nbsp;=&nbsp;myList[i];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Max&nbsp;is&nbsp;\"&nbsp;+&nbsp;max);\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">1.9\n2.9\n3.4\n3.5\nTotal&nbsp;is&nbsp;11.7\nMax&nbsp;is&nbsp;3.5\n</pre><hr><h2>foreach 循环</h2><p>JDK 1.5 引进了一种新的循环类型，被称为 foreach 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p><p>语法格式如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">for(type element: array){\n    System.out.println(element);\n}\n</pre><h3>示例</h3><p>该实例用来显示数组 myList 中的所有元素：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;TestArray&nbsp;{\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double[]&nbsp;myList&nbsp;=&nbsp;{1.9,&nbsp;2.9,&nbsp;3.4,&nbsp;3.5};\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;打印所有数组元素\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(double&nbsp;element:&nbsp;myList)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(element);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">1.9\n2.9\n3.4\n3.5\n</pre><hr><h2>数组作为函数的参数</h2><p>数组可以作为参数传递给方法。例如，下面的例子就是一个打印 int 数组中元素的方法。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;static&nbsp;void&nbsp;printArray(int[]&nbsp;array)&nbsp;{\n&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;array.length;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(array[i]&nbsp;+&nbsp;\"&nbsp;\");\n&nbsp;&nbsp;&nbsp;}\n&nbsp;}\n</pre><p>下面例子调用 printArray 方法打印出 3，1，2，6，4和2：</p><pre class=\"ql-syntax\" spellcheck=\"false\">printArray(new&nbsp;int[]{3,&nbsp;1,&nbsp;2,&nbsp;6,&nbsp;4,&nbsp;2});\n</pre><hr><h2>数组作为函数的返回值</h2><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;static&nbsp;int[]&nbsp;reverse(int[]&nbsp;list)&nbsp;{\n&nbsp;&nbsp;int[]&nbsp;result&nbsp;=&nbsp;new&nbsp;int[list.length];\n\n&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0,&nbsp;j&nbsp;=&nbsp;result.length&nbsp;-&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;list.length;&nbsp;i++,&nbsp;j--)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[j]&nbsp;=&nbsp;list[i];\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;return&nbsp;result;\n&nbsp;}\n</pre><p>以上实例中result数组作为函数的返回值。</p><hr><h2>Arrays 类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能：</p><ul><li>给数组赋值：通过 fill 方法。</li><li>对数组排序：通过 sort 方法,按升序。</li><li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul><p>具体说明请查看下表：</p><p>序号方法和说明1<strong>public static int binarySearch(Object[] a, Object key)</strong></p><p>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。2<strong>public static boolean equals(long[] a, long[] a2)</strong></p><p>如果两个指定的 long 型数组彼此<em>相等</em>，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。3<strong>public static void fill(int[] a, int val)</strong></p><p>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。4<strong>public static void sort(Object[] a)</strong></p><p>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (17, 2, 'Java 日期时间', 1002, 'teacher', '2022-12-09 08:14:59', '<h2><strong>Java日期时间</strong></h2><p><br></p><p>java.util包提供了Date类来封装当前的日期和时间。 Date类提供两个构造函数来实例化Date对象。</p><p>第一个构造函数使用当前日期和时间来初始化对象。</p><pre class=\"ql-syntax\" spellcheck=\"false\">Date( )\n</pre><p>第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。</p><pre class=\"ql-syntax\" spellcheck=\"false\">Date(long millisec)\n</pre><p>Date对象创建以后，可以调用下面的方法。</p><p>序号方法和描述1<strong>boolean after(Date date)</strong></p><p>若当调用此方法的Date对象在指定日期之后返回true,否则返回false。2<strong>boolean before(Date date)</strong></p><p>若当调用此方法的Date对象在指定日期之前返回true,否则返回false。3<strong>Object clone( )</strong></p><p>返回此对象的副本。4<strong>int compareTo(Date date)</strong></p><p>比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。5<strong>int compareTo(Object obj)</strong></p><p>若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。6<strong>boolean equals(Object date)</strong></p><p>当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。7<strong>long getTime( )</strong></p><p>返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。8<strong>int hashCode( )</strong></p><p>&nbsp;返回此对象的哈希码值。9<strong>void setTime(long time)</strong></p><p>&nbsp;</p><p>用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。10<strong>String toString( )</strong></p><p>转换Date对象为String表示形式，并返回该字符串。</p><h2>获取当前日期时间</h2><p>Java中获取当前日期和时间很简单，使用Date对象的 toString()方法来打印当前日期和时间，如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.Date;\n  \npublic class Main{\n   public static void main(String args[]) {\n       // 初始化 Date 对象\n       Date date = new Date();\n        \n       // 使用 toString() 函数显示日期时间\n       System.out.println(date.toString());\n   }\n}\n</pre><p>尝试一下以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Mon May 04 09:51:52 CDT 2013\n</pre><hr><h2>日期比较</h2><p>Java使用以下三种方法来比较两个日期：</p><ul><li>使用getTime( ) 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。</li><li>使用方法before()，after()和equals()。例如，一个月的12号比18号早，则new Date(99, 2, 12).before(new Date (99, 2, 18))返回true。</li><li>使用compareTo()方法，它是由Comparable接口定义的，Date类实现了这个接口。</li></ul><hr><h2>使用SimpleDateFormat格式化日期</h2><p>SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许你选择任何用户自定义日期时间格式来运行。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.*;\nimport java.text.*;\n\npublic class Main{\n   public static void main(String args[]) {\n\n      Date dNow = new Date( );\n      SimpleDateFormat ft = \n      new SimpleDateFormat (\"E yyyy.MM.dd \'at\' hh:mm:ss a zzz\");\n\n      System.out.println(\"Current Date: \" + ft.format(dNow));\n   }\n}\n</pre><p>尝试一下以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Current Date: Sun 2004.07.18 at 04:14:09 PM PDT\n</pre><hr><h2>简单的DateFormat格式化编码</h2><p>时间模式字符串用来指定时间格式。在此模式中，所有的ASCII字母被保留为模式字母，定义如下：</p><p><strong>字母描述示例</strong>G纪元标记ADy四位年份2001M月份July or 07d一个月的日期10h&nbsp;A.M./P.M. (1~12)格式小时12H一天中的小时 (0~23)22m分钟数30s秒数55S毫秒数234E星期几TuesdayD一年中的日子360F一个月中第几周的周几2 (second Wed. in July)w一年中第几周40W一个月中第几周1aA.M./P.M. 标记PMk一天中的小时(1~24)24K&nbsp;A.M./P.M. (0~11)格式小时10z时区Eastern Standard Time\'文字定界符Delimiter\"单引号`</p><h2>使用printf格式化日期</h2><p>printf方法可以很轻松地格式化时间和日期。使用两个字母格式，它以t开头并且以下面表格中的一个字母结尾。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.Date;\n\npublic class Main{\n\n  public static void main(String args[]) {\n     // 初始化 Date 对象\n     Date date = new Date();\n\n     // 使用toString()显示日期和时间\n     String str = String.format(\"Current Date/Time : %tc\", date );\n\n     System.out.printf(str);\n  }\n}\n</pre><p>尝试一下以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Current Date/Time : Sat Dec 15 16:37:57 MST 2012\n</pre><p>如果你需要重复提供日期，那么利用这种方式来格式化它的每一部分就有点复杂了。因此，可以利用一个格式化字符串指出要被格式化的参数的索引。</p><p>索引必须紧跟在%后面，而且必须以$结束。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.Date;\n  \npublic class Main{\n   public static void main(String args[]) {\n       // 初始化 Date 对象\n       Date date = new Date();\n        \n       // 使用toString()显示日期和时间\n       System.out.printf(\"%1$s %2$tB %2$td, %2$tY\", \n                         \"Due date:\", date);\n   }\n}\n</pre><p>尝试一下以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Due date: February 09, 2004\n</pre><p>或者，你可以使用&lt;标志。它表明先前被格式化的参数要被再次使用。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.Date;\n  \npublic class Main{\n\n   public static void main(String args[]) {\n       // 初始化 Date 对象\n       Date date = new Date();\n        \n       // 显示格式化时间\n       System.out.printf(\"%s %tB %&lt;te, %&lt;tY\",\n                           \"Due date:\", date);\n   }\n} \n</pre><p>尝试一下以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Due date: February 09, 2004\n</pre><hr><h2>日期和时间转换字符</h2><p><strong>字符描述例子</strong>c完整的日期和时间Mon May 04 09:51:52 CDT 2009FISO 8601 格式日期2004-02-09DU.S. 格式日期 (月/日/年)02/09/2004T24小时时间18:05:19r12小时时间06:05:19 pmR24小时时间，不包含秒18:05Y4位年份(包含前导0)2004y年份后2位(包含前导0)04C年份前2位(包含前导0)20B月份全称Februaryb月份简称Febn2位月份(包含前导0)02d2位日子(包含前导0)03e2位日子(不包含前导0)9A星期全称Mondaya星期简称Monj3位年份(包含前导0)069H2位小时(包含前导0), 00 到 2318k2位小时(不包含前导0),&nbsp;0 到 2318I2位小时(包含前导0), 01 到 1206l2位小时(不包含前导0),&nbsp;1 到 126M2位分钟(包含前导0)05S2位秒数(包含前导0)19L3位毫秒(包含前导0)047N9位纳秒(包含前导0)047000000P大写上下午标志PMp小写上下午标志pmz从GMT的RFC 822数字偏移-0800Z时区PSTs自 1970-01-01 00:00:00 GMT的秒数1078884319Q自 1970-01-01 00:00:00 GMT的毫妙1078884319047</p><p>还有其他有用的日期和时间相关的类。对于更多的细节，你可以参考到Java标准文档。</p><hr><h2>解析字符串为时间</h2><p>SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.*;\nimport java.text.*;\n  \npublic class Main{\n\n   public static void main(String args[]) {\n      SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd\"); \n\n      String input = args.length == 0 ? \"1818-11-11\" : args[0]; \n\n      System.out.print(input + \" Parses as \"); \n\n      Date t; \n\n      try { \n          t = ft.parse(input); \n          System.out.println(t); \n      } catch (ParseException e) { \n          System.out.println(\"Unparseable using \" + ft); \n      }\n   }\n}\n</pre><p>尝试一下以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">$ java DateDemo\n1818-11-11 Parses as Wed Nov 11 00:00:00 GMT 1818\n$ java DateDemo 2007-12-01\n2007-12-01 Parses as Sat Dec 01 00:00:00 GMT 2007\n</pre><hr><p>Java 休眠(sleep)</p><p>你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠3秒：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.*;\n  \npublic class Main{\n   public static void main(String args[]) {\n      try { \n         System.out.println(new Date( ) + \"\\n\"); \n         Thread.sleep(5*60*10); \n         System.out.println(new Date( ) + \"\\n\"); \n      } catch (Exception e) { \n          System.out.println(\"Got an exception!\"); \n      }\n   }\n}\n</pre><p>尝试一下以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Sun May 03 18:04:41 GMT 2009\n\nSun May 03 18:04:44 GMT 2009\n</pre><hr><h2>测量时间</h2><p>下面的一个例子表明如何测量时间间隔（以毫秒为单位）：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.*;\n  \npublic class Main{\n\n   public static void main(String args[]) {\n      try {\n         long start = System.currentTimeMillis( );\n         System.out.println(new Date( ) + \"\\n\");\n         Thread.sleep(5*60*10);\n         System.out.println(new Date( ) + \"\\n\");\n         long end = System.currentTimeMillis( );\n         long diff = end - start;\n         System.out.println(\"Difference is : \" + diff);\n      } catch (Exception e) {\n         System.out.println(\"Got an exception!\");\n      }\n   }\n}\n</pre><p>尝试一下以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Sun May 03 18:16:51 GMT 2009\n\nSun May 03 18:16:54 GMT 2009\n\nDifference is : 3050\n</pre><hr><h2>Calendar类</h2><p>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。</p><p>Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。</p><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。</p><h3>创建一个代表系统当前日期的Calendar对象</h3><pre class=\"ql-syntax\" spellcheck=\"false\">Calendar c = Calendar.getInstance();//默认是当前日期\n</pre><h3>创建一个指定日期的Calendar对象</h3><p>使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。</p><pre class=\"ql-syntax\" spellcheck=\"false\">//创建一个代表2009年6月12日的Calendar对象\nCalendar c1 = Calendar.getInstance();\nc1.set(2009, 6 - 1, 12);\n</pre><h3>Calendar类对象字段类型</h3><p>Calendar类中用一下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想</p><p>常量描述Calendar.YEAR年份Calendar.MONTH月份Calendar.DATE日期Calendar.DAY_OF_MONTH日期，和上面的字段意义完全相同Calendar.HOUR12小时制的小时Calendar.HOUR_OF_DAY24小时制的小时Calendar.MINUTE分钟Calendar.SECOND秒Calendar.DAY_OF_WEEK星期几</p><h3>Calendar类对象信息的设置</h3><p><strong>Set设置</strong></p><p>如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Calendar c1 = Calendar.getInstance();\n</pre><p>调用：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public final void set(int year,int month,int date)\nc1.set(2009, 6 - 1, 12);//把Calendar对象c1的年月日分别设这为：2009、5、12\n</pre><p>利用字段类型设置</p><p>如果只设定某个字段，例如日期的值，则可以使用如下set方法：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public void set(int field,int value)\n</pre><p>把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算</p><pre class=\"ql-syntax\" spellcheck=\"false\">c1.set(Calendar.DATE,10);\n</pre><p>把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算</p><pre class=\"ql-syntax\" spellcheck=\"false\">c1.set(Calendar.YEAR,2008);\n</pre><p>其他字段属性set的意义以此类推</p><p><strong>Add设置</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">Calendar c1 = Calendar.getInstance();\n</pre><p>把c1对象的日期加上10，也就是c1所表的日期的10天后的日期，其它所有的数值会被重新计算</p><pre class=\"ql-syntax\" spellcheck=\"false\">c1.add(Calendar.DATE, 10);\n</pre><p>把c1对象的日期减去10，也就是c1所表的日期的10天前的日期，其它所有的数值会被重新计算</p><pre class=\"ql-syntax\" spellcheck=\"false\">c1.add(Calendar.DATE, -10);\n</pre><p>其他字段属性的add的意义以此类推</p><h3>Calendar类对象信息的获得</h3><pre class=\"ql-syntax\" spellcheck=\"false\">Calendar c1 = Calendar.getInstance();\n// 获得年份\nint year = c1.get(Calendar.YEAR);\n// 获得月份\nint month = c1.get(Calendar.MONTH) + 1;\n// 获得日期\nint date = c1.get(Calendar.DATE);\n// 获得小时\nint hour = c1.get(Calendar.HOUR_OF_DAY);\n// 获得分钟\nint minute = c1.get(Calendar.MINUTE);\n// 获得秒\nint second = c1.get(Calendar.SECOND);\n// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）\nint day = c1.get(Calendar.DAY_OF_WEEK);\n</pre><hr><h2>GregorianCalendar类</h2><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><p>Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这些代表公历定义的两个时代。</p><p>下面列出GregorianCalendar对象的几个构造方法：</p><p><strong>序号构造函数和说明</strong>1<strong>GregorianCalendar()</strong></p><p>在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。2<strong>GregorianCalendar(int year, int month, int date)</strong></p><p>在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar3<strong>GregorianCalendar(int year, int month, int date, int hour, int minute)</strong></p><p>为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。4<strong>GregorianCalendar(int year, int month, int date, int hour, int minute, int second)</strong></p><p>&nbsp;为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。5<strong>GregorianCalendar(Locale aLocale)</strong></p><p>在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。6<strong>GregorianCalendar(TimeZone zone)</strong></p><p>在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。7<strong>GregorianCalendar(TimeZone zone, Locale aLocale)</strong></p><p>&nbsp;在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。</p><p>这里是GregorianCalendar 类提供的一些有用的方法列表：</p><p><strong>序号方法和说明</strong>1<strong>void add(int field, int amount)</strong></p><p>根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。2<strong>protected void computeFields()</strong></p><p>转换UTC毫秒值为时间域值3<strong>protected void computeTime()</strong></p><p>覆盖Calendar ，转换时间域值为UTC毫秒值4<strong>boolean equals(Object obj)</strong></p><p>比较此 GregorianCalendar 与指定的 Object。5<strong>int get(int field)</strong></p><p>获取指定字段的时间值6<strong>int getActualMaximum(int field)</strong></p><p>返回当前日期，给定字段的最大值7<strong>int getActualMinimum(int field)</strong></p><p>返回当前日期，给定字段的最小值8<strong>int getGreatestMinimum(int field)</strong></p><p>&nbsp;返回此 GregorianCalendar 实例给定日历字段的最高的最小值。9<strong>Date getGregorianChange()</strong></p><p>获得格里高利历的更改日期。10<strong>int getLeastMaximum(int field)</strong></p><p>返回此 GregorianCalendar 实例给定日历字段的最低的最大值11<strong>int getMaximum(int field)</strong></p><p>返回此 GregorianCalendar 实例的给定日历字段的最大值。12<strong>Date getTime()</strong></p><p>获取日历当前时间。13<strong>long getTimeInMillis()</strong></p><p>获取用长整型表示的日历的当前时间14<strong>TimeZone getTimeZone()</strong></p><p>获取时区。15<strong>int getMinimum(int field)</strong></p><p>返回给定字段的最小值。16<strong>int hashCode()</strong></p><p>重写hashCode.17<strong>boolean isLeapYear(int year)</strong></p><p>确定给定的年份是否为闰年。18<strong>void roll(int field, boolean up)</strong></p><p>在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。19<strong>void set(int field, int value)</strong></p><p>用给定的值设置时间字段。20<strong>void set(int year, int month, int date)</strong></p><p>设置年、月、日的值。21<strong>void set(int year, int month, int date, int hour, int minute)</strong></p><p>设置年、月、日、小时、分钟的值。22<strong>void set(int year, int month, int date, int hour, int minute, int second)</strong></p><p>设置年、月、日、小时、分钟、秒的值。23<strong>void setGregorianChange(Date date)</strong></p><p>设置 GregorianCalendar 的更改日期。24<strong>void setTime(Date date)</strong></p><p>用给定的日期设置Calendar的当前时间。25<strong>void setTimeInMillis(long millis)</strong></p><p>用给定的long型毫秒数设置Calendar的当前时间。26<strong>void setTimeZone(TimeZone value)</strong></p><p>用给定时区值设置当前时区。27<strong>String toString()</strong></p><p>返回代表日历的字符串。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.*;\n  \npublic class GregorianCalendarDemo {\n\n   public static void main(String args[]) {\n      String months[] = {\n      \"Jan\", \"Feb\", \"Mar\", \"Apr\",\n      \"May\", \"Jun\", \"Jul\", \"Aug\",\n      \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n      \n      int year;\n      // 初始化 Gregorian 日历\n      // 使用当前时间和日期\n      // 默认为本地时间和时区\n      GregorianCalendar gcalendar = new GregorianCalendar();\n      // 显示当前时间和日期的信息\n      System.out.print(\"Date: \");\n      System.out.print(months[gcalendar.get(Calendar.MONTH)]);\n      System.out.print(\" \" + gcalendar.get(Calendar.DATE) + \" \");\n      System.out.println(year = gcalendar.get(Calendar.YEAR));\n      System.out.print(\"Time: \");\n      System.out.print(gcalendar.get(Calendar.HOUR) + \":\");\n      System.out.print(gcalendar.get(Calendar.MINUTE) + \":\");\n      System.out.println(gcalendar.get(Calendar.SECOND));\n      \n      // 测试当前年份是否为闰年\n      if(gcalendar.isLeapYear(year)) {\n         System.out.println(\"当前年份是闰年\");\n      }\n      else {\n         System.out.println(\"当前年份不是闰年\");\n      }\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Date: Apr 22 2009\nTime: 11:25:27\n当前年份不是闰年\n</pre><p>关于Calender 类的完整列表，你可以参考标准的Java文档。</p><p><br></p><hr><p><br></p><hr><p><br></p>');
INSERT INTO `knowledge` VALUES (18, 2, 'Java 正则表达式', 1002, 'teacher', '2022-12-09 08:15:33', '<h2><strong>Java正则表达式</strong></h2><p><br></p><p>正则表达式定义了字符串的模式。</p><p>正则表达式可以用来搜索、编辑或处理文本。</p><p>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。</p><p>Java正则表达式和Perl的是最为相似的。</p><p>java.util.regex包主要包括以下三个类：</p><ul><li><strong>Pattern类：</strong></li><li>pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。</li><li><strong>Matcher类：</strong></li><li>Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。</li><li><strong>PatternSyntaxException：</strong></li><li>PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li></ul><hr><h2>捕获组</h2><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p><p>例如，正则表达式(dog) 创建了单一分组，组里包含\"d\"，\"o\"，和\"g\"。</p><p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p><ul><li>((A)(B(C)))</li><li>(A)</li><li>(B(C))</li><li>(C)</li></ul><p>可以通过调用matcher对象的groupCount方法来查看表达式有多少个分组。groupCount方法返回一个int值，表示matcher对象当前有多个捕获组。</p><p>还有一个特殊的组（组0），它总是代表整个表达式。该组不包括在groupCount的返回值中。</p><h2>实例</h2><p>下面的例子说明如何从一个给定的字符串中找到数字串：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches\n{\n    public static void main( String args[] ){\n\n      // 按指定模式在字符串查找\n      String line = \"This order was placed for QT3000! OK?\";\n      String pattern = \"(.*)(\\\\d+)(.*)\";\n\n      // 创建 Pattern 对象\n      Pattern r = Pattern.compile(pattern);\n\n      // 现在创建 matcher 对象\n      Matcher m = r.matcher(line);\n      if (m.find( )) {\n         System.out.println(\"Found value: \" + m.group(0) );\n         System.out.println(\"Found value: \" + m.group(1) );\n         System.out.println(\"Found value: \" + m.group(2) );\n      } else {\n         System.out.println(\"NO MATCH\");\n      }\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Found value: This order was placed for QT3000! OK?\nFound value: This order was placed for QT300\nFound value: 0\n</pre><hr><h2>正则表达式语法</h2><p>字符</p><p>说明</p><p>\\</p><p>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，\"n\"匹配字符\"n\"。\"\\n\"匹配换行符。序列\"\\\\\"匹配\"\\\"，\"\\(\"匹配\"(\"。</p><p>^</p><p>匹配输入字符串开始的位置。如果设置了&nbsp;<strong>RegExp</strong>&nbsp;对象的&nbsp;<strong>Multiline</strong>&nbsp;属性，^ 还会与\"\\n\"或\"\\r\"之后的位置匹配。</p><p>$</p><p>匹配输入字符串结尾的位置。如果设置了&nbsp;<strong>RegExp</strong>&nbsp;对象的&nbsp;<strong>Multiline</strong>&nbsp;属性，$ 还会与\"\\n\"或\"\\r\"之前的位置匹配。</p><p>*</p><p>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配\"z\"和\"zoo\"。* 等效于 {0,}。</p><p>+</p><p>一次或多次匹配前面的字符或子表达式。例如，\"zo+\"与\"zo\"和\"zoo\"匹配，但与\"z\"不匹配。+ 等效于 {1,}。</p><p>?</p><p>零次或一次匹配前面的字符或子表达式。例如，\"do(es)?\"匹配\"do\"或\"does\"中的\"do\"。? 等效于 {0,1}。</p><p>{<em>n</em>}</p><p><em>n&nbsp;</em>是非负整数。正好匹配&nbsp;<em>n</em>&nbsp;次。例如，\"o{2}\"与\"Bob\"中的\"o\"不匹配，但与\"food\"中的两个\"o\"匹配。</p><p>{<em>n</em>,}</p><p><em>n&nbsp;</em>是非负整数。至少匹配&nbsp;<em>n&nbsp;</em>次。例如，\"o{2,}\"不匹配\"Bob\"中的\"o\"，而匹配\"foooood\"中的所有 o。\"o{1,}\"等效于\"o+\"。\"o{0,}\"等效于\"o*\"。</p><p>{<em>n</em>,<em>m</em>}</p><p><em>M</em>&nbsp;和&nbsp;<em>n</em>&nbsp;是非负整数，其中&nbsp;<em>n</em>&nbsp;&lt;=&nbsp;<em>m</em>。匹配至少&nbsp;<em>n</em>&nbsp;次，至多&nbsp;<em>m</em>&nbsp;次。例如，\"o{1,3}\"匹配\"fooooood\"中的头三个 o。\'o{0,1}\' 等效于 \'o?\'。注意：您不能将空格插入逗号和数字之间。</p><p>?</p><p>当此字符紧随任何其他限定符（*、+、?、{<em>n</em>}、{<em>n</em>,}、{<em>n</em>,<em>m</em>}）之后时，匹配模式是\"非贪心的\"。\"非贪心的\"模式匹配搜索到的、尽可能短的字符串，而默认的\"贪心的\"模式匹配搜索到的、尽可能长的字符串。例如，在字符串\"oooo\"中，\"o+?\"只匹配单个\"o\"，而\"o+\"匹配所有\"o\"。</p><p>.</p><p>匹配除\"\\r\\n\"之外的任何单个字符。若要匹配包括\"\\r\\n\"在内的任意字符，请使用诸如\"[\\s\\S]\"之类的模式。</p><p>(<em>pattern</em>)</p><p>匹配&nbsp;<em>pattern</em>&nbsp;并捕获该匹配的子表达式。可以使用&nbsp;<strong>$0…$9</strong>&nbsp;属性从结果\"匹配\"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用\"\\(\"或者\"\\)\"。</p><p>(?:<em>pattern</em>)</p><p>匹配&nbsp;<em>pattern</em>&nbsp;但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用\"or\"字符 (|) 组合模式部件的情况很有用。例如，\'industr(?:y|ies) 是比 \'industry|industries\' 更经济的表达式。</p><p>(?=<em>pattern</em>)</p><p>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配&nbsp;<em>pattern</em>&nbsp;的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，\'Windows (?=95|98|NT|2000)\' 匹配\"Windows 2000\"中的\"Windows\"，但不匹配\"Windows 3.1\"中的\"Windows\"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p><p>(?!<em>pattern</em>)</p><p>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配&nbsp;<em>pattern</em>&nbsp;的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，\'Windows (?!95|98|NT|2000)\' 匹配\"Windows 3.1\"中的 \"Windows\"，但不匹配\"Windows 2000\"中的\"Windows\"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p><p><em>x</em>|<em>y</em></p><p>匹配&nbsp;<em>x</em>&nbsp;或&nbsp;<em>y</em>。例如，\'z|food\' 匹配\"z\"或\"food\"。\'(z|f)ood\' 匹配\"zood\"或\"food\"。</p><p>[<em>xyz</em>]</p><p>字符集。匹配包含的任一字符。例如，\"[abc]\"匹配\"plain\"中的\"a\"。</p><p>[^<em>xyz</em>]</p><p>反向字符集。匹配未包含的任何字符。例如，\"[^abc]\"匹配\"plain\"中\"p\"，\"l\"，\"i\"，\"n\"。</p><p>[<em>a-z</em>]</p><p>字符范围。匹配指定范围内的任何字符。例如，\"[a-z]\"匹配\"a\"到\"z\"范围内的任何小写字母。</p><p>[^<em>a-z</em>]</p><p>反向范围字符。匹配不在指定的范围内的任何字符。例如，\"[^a-z]\"匹配任何不在\"a\"到\"z\"范围内的任何字符。</p><p>\\b</p><p>匹配一个字边界，即字与空格间的位置。例如，\"er\\b\"匹配\"never\"中的\"er\"，但不匹配\"verb\"中的\"er\"。</p><p>\\B</p><p>非字边界匹配。\"er\\B\"匹配\"verb\"中的\"er\"，但不匹配\"never\"中的\"er\"。</p><p>\\c<em>x</em></p><p>匹配&nbsp;<em>x</em>&nbsp;指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。<em>x</em>&nbsp;的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是\"c\"字符本身。</p><p>\\d</p><p>数字字符匹配。等效于 [0-9]。</p><p>\\D</p><p>非数字字符匹配。等效于 [^0-9]。</p><p>\\f</p><p>换页符匹配。等效于 \\x0c 和 \\cL。</p><p>\\n</p><p>换行符匹配。等效于 \\x0a 和 \\cJ。</p><p>\\r</p><p>匹配一个回车符。等效于 \\x0d 和 \\cM。</p><p>\\s</p><p>匹配任何空白字符，包括空格、制表符、换页符等。与 [&nbsp;\\f\\n\\r\\t\\v] 等效。</p><p>\\S</p><p>匹配任何非空白字符。与 [^&nbsp;\\f\\n\\r\\t\\v] 等效。</p><p>\\t</p><p>制表符匹配。与 \\x09 和 \\cI 等效。</p><p>\\v</p><p>垂直制表符匹配。与 \\x0b 和 \\cK 等效。</p><p>\\w</p><p>匹配任何字类字符，包括下划线。与\"[A-Za-z0-9_]\"等效。</p><p>\\W</p><p>与任何非单词字符匹配。与\"[^A-Za-z0-9_]\"等效。</p><p>\\x<em>n</em></p><p>匹配&nbsp;<em>n</em>，此处的&nbsp;<em>n</em>&nbsp;是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，\"\\x41\"匹配\"A\"。\"\\x041\"与\"\\x04\"&amp;\"1\"等效。允许在正则表达式中使用 ASCII 代码。</p><p>\\<em>num</em></p><p>匹配&nbsp;<em>num</em>，此处的&nbsp;<em>num</em>&nbsp;是一个正整数。到捕获匹配的反向引用。例如，\"(.)\\1\"匹配两个连续的相同字符。</p><p>\\<em>n</em></p><p>标识一个八进制转义码或反向引用。如果 \\<em>n</em>&nbsp;前面至少有&nbsp;<em>n</em>&nbsp;个捕获子表达式，那么&nbsp;<em>n</em>&nbsp;是反向引用。否则，如果&nbsp;<em>n</em>&nbsp;是八进制数 (0-7)，那么&nbsp;<em>n</em>&nbsp;是八进制转义码。</p><p>\\<em>nm</em></p><p>标识一个八进制转义码或反向引用。如果 \\<em>nm</em>&nbsp;前面至少有&nbsp;<em>nm</em>&nbsp;个捕获子表达式，那么&nbsp;<em>nm</em>&nbsp;是反向引用。如果 \\<em>nm</em>&nbsp;前面至少有&nbsp;<em>n</em>&nbsp;个捕获，则&nbsp;<em>n</em>&nbsp;是反向引用，后面跟有字符&nbsp;<em>m</em>。如果两种前面的情况都不存在，则 \\<em>nm</em>&nbsp;匹配八进制值&nbsp;<em>nm</em>，其中&nbsp;<em>n&nbsp;</em>和&nbsp;<em>m</em>&nbsp;是八进制数字 (0-7)。</p><p>\\nml</p><p>当&nbsp;<em>n</em>&nbsp;是八进制数 (0-3)，<em>m</em>&nbsp;和&nbsp;<em>l</em>&nbsp;是八进制数 (0-7) 时，匹配八进制转义码&nbsp;<em>nml</em>。</p><p>\\u<em>n</em></p><p>匹配&nbsp;<em>n</em>，其中&nbsp;<em>n</em>&nbsp;是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。</p><h2>Matcher类的方法</h2><h2>索引方法</h2><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p><p><strong>序号方法及说明</strong>1<strong>public int start()</strong></p><p>返回以前匹配的初始索引。2<strong>public int start(int group)</strong></p><p>&nbsp;返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引3<strong>public int end()</strong></p><p>返回最后匹配字符之后的偏移量。4<strong>public int end(int group)</strong></p><p>返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</p><h2>研究方法</h2><p>研究方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：</p><p><strong>序号方法及说明</strong>1<strong>public boolean lookingAt()</strong></p><p>&nbsp;尝试将从区域开头开始的输入序列与该模式匹配。2<strong>public boolean find()</strong></p><p>尝试查找与该模式匹配的输入序列的下一个子序列。3<strong>public boolean find(int start）</strong></p><p>重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。4<strong>public boolean matches()</strong></p><p>尝试将整个区域与模式匹配。</p><h2>替换方法</h2><p>替换方法是替换输入字符串里文本的方法：</p><p><strong>序号方法及说明</strong>1<strong>public Matcher appendReplacement(StringBuffer sb, String replacement)</strong></p><p>实现非终端添加和替换步骤。2<strong>public StringBuffer appendTail(StringBuffer sb)</strong></p><p>实现终端添加和替换步骤。3<strong>public String replaceAll(String replacement)</strong></p><p>&nbsp;替换模式与给定替换字符串相匹配的输入序列的每个子序列。4<strong>public String replaceFirst(String replacement)</strong></p><p>&nbsp;替换模式与给定替换字符串匹配的输入序列的第一个子序列。5<strong>public static String quoteReplacement(String s)</strong></p><p>返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</p><h2>start 和end 方法</h2><p>下面是一个对单词\"cat\"出现在输入字符串中出现次数进行计数的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches\n{\n    private static final String REGEX = \"\\\\bcat\\\\b\";\n    private static final String INPUT =\n                                    \"cat cat cat cattie cat\";\n\n    public static void main( String args[] ){\n       Pattern p = Pattern.compile(REGEX);\n       Matcher m = p.matcher(INPUT); // 获取 matcher 对象\n       int count = 0;\n\n       while(m.find()) {\n         count++;\n         System.out.println(\"Match number \"+count);\n         System.out.println(\"start(): \"+m.start());\n         System.out.println(\"end(): \"+m.end());\n      }\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Match number 1\nstart(): 0\nend(): 3\nMatch number 2\nstart(): 4\nend(): 7\nMatch number 3\nstart(): 8\nend(): 11\nMatch number 4\nstart(): 19\nend(): 22\n</pre><p>可以看到这个例子是使用单词边界，以确保字母 \"c\" \"a\" \"t\" 并非仅是一个较长的词的子串。它也提供了一些关于输入字符串中匹配发生位置的有用信息。</p><p>Start方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end方法最后一个匹配字符的索引加1。</p><h2>matches 和lookingAt 方法</h2><p>matches 和lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是matches要求整个序列都匹配，而lookingAt 不要求。</p><p>这两个方法经常在输入字符串的开始使用。</p><p>我们通过下面这个例子，来解释这个功能：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches\n{\n    private static final String REGEX = \"foo\";\n    private static final String INPUT = \"fooooooooooooooooo\";\n    private static Pattern pattern;\n    private static Matcher matcher;\n\n    public static void main( String args[] ){\n       pattern = Pattern.compile(REGEX);\n       matcher = pattern.matcher(INPUT);\n\n       System.out.println(\"Current REGEX is: \"+REGEX);\n       System.out.println(\"Current INPUT is: \"+INPUT);\n\n       System.out.println(\"lookingAt(): \"+matcher.lookingAt());\n       System.out.println(\"matches(): \"+matcher.matches());\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Current REGEX is: foo\nCurrent INPUT is: fooooooooooooooooo\nlookingAt(): true\nmatches(): false\n</pre><h2>replaceFirst 和replaceAll 方法</h2><p>replaceFirst 和replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。</p><p>下面的例子来解释这个功能：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches\n{\n    private static String REGEX = \"dog\";\n    private static String INPUT = \"The dog says meow. \" +\n                                    \"All dogs say meow.\";\n    private static String REPLACE = \"cat\";\n\n    public static void main(String[] args) {\n       Pattern p = Pattern.compile(REGEX);\n       // get a matcher object\n       Matcher m = p.matcher(INPUT); \n       INPUT = m.replaceAll(REPLACE);\n       System.out.println(INPUT);\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">The cat says meow. All cats say meow.\n</pre><h2>appendReplacement 和 appendTail 方法</h2><p>Matcher 类也提供了appendReplacement 和appendTail 方法用于文本替换：</p><p>看下面的例子来解释这个功能：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexMatches\n{\n   private static String REGEX = \"a*b\";\n   private static String INPUT = \"aabfooaabfooabfoob\";\n   private static String REPLACE = \"-\";\n   public static void main(String[] args) {\n      Pattern p = Pattern.compile(REGEX);\n      // 获取 matcher 对象\n      Matcher m = p.matcher(INPUT);\n      StringBuffer sb = new StringBuffer();\n      while(m.find()){\n         m.appendReplacement(sb,REPLACE);\n      }\n      m.appendTail(sb);\n      System.out.println(sb.toString());\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">-foo-foo-foo-\n</pre><h2>PatternSyntaxException 类的方法</h2><p>PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。</p><p>PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。</p><p><strong>序号方法及说明</strong>1<strong>public String getDescription()</strong></p><p>获取错误的描述。2<strong>public int getIndex()</strong></p><p>&nbsp;获取错误的索引。3<strong>public String getPattern()</strong></p><p>获取错误的正则表达式模式。4<strong>public String getMessage()</strong></p><p>返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (19, 2, 'Java 方法', 1002, 'teacher', '2022-12-09 08:15:55', '<h2><strong>Java方法</strong></h2><p><br></p><p>在前面几个章节中我们经常使用到System.out.println()，那么它是什么呢？</p><p>println()是一个方法(Method)，而System是系统类(Class)，out是标准输出对象(Object)。这句话的用法是调用系统类System中的标准输出对象out中的方法println()。</p><h3>那么什么是方法呢？</h3><p>Java方法是语句的集合，它们在一起执行一个功能。</p><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><hr><h2>方法的定义</h2><p>一般情况下，定义一个方法包含以下语法：</p><pre class=\"ql-syntax\" spellcheck=\"false\">修饰符&nbsp;返回值类型&nbsp;方法名&nbsp;(参数类型&nbsp;参数名){\n&nbsp;&nbsp;&nbsp;&nbsp;...\n&nbsp;&nbsp;&nbsp;&nbsp;方法体\n&nbsp;&nbsp;&nbsp;&nbsp;...\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;返回值;\n}\n</pre><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p><ul><li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字<strong>void</strong>。</li><li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li></ul><p><img src=\"http://localhost:8080/static/picture/1459506282508515.jpg\"></p><p>如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;static&nbsp;int&nbsp;age(int&nbsp;birthday){...}\n</pre><p>参数可以有多个：</p><pre class=\"ql-syntax\" spellcheck=\"false\">static&nbsp;float&nbsp;interest(float&nbsp;principal,&nbsp;int&nbsp;year){...}\n</pre><p><strong>注意：</strong>&nbsp;在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</p><h3>实例</h3><p>下面的方法包含2个参数num1和num2，它返回这两个参数的最大值。</p><pre class=\"ql-syntax\" spellcheck=\"false\">/**&nbsp;返回两个整型变量数据的较大值&nbsp;*/\npublic&nbsp;static&nbsp;int&nbsp;max(int&nbsp;num1,&nbsp;int&nbsp;num2)&nbsp;{\n&nbsp;&nbsp;&nbsp;int&nbsp;result;\n&nbsp;&nbsp;&nbsp;if&nbsp;(num1&nbsp;&gt;&nbsp;num2){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;num1;\n&nbsp;&nbsp;&nbsp;}else{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;num2;\n   }\n&nbsp;&nbsp;&nbsp;return&nbsp;result;&nbsp;\n}\n</pre><hr><h2>方法调用</h2><p>Java支持两种调用方法的方式，根据方法是否返回值来选择。</p><p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p><p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">int&nbsp;larger&nbsp;=&nbsp;max(30,&nbsp;40);\n</pre><p>如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：</p><pre class=\"ql-syntax\" spellcheck=\"false\">System.out.println(\"Welcome&nbsp;to&nbsp;Java!\");\n</pre><h3>示例</h3><p>下面的例子演示了如何定义一个方法，以及如何调用它：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;TestMax&nbsp;{\n&nbsp;&nbsp;&nbsp;/**&nbsp;主方法&nbsp;*/\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;5;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j&nbsp;=&nbsp;2;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;k&nbsp;=&nbsp;max(i,&nbsp;j);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"The&nbsp;maximum&nbsp;between&nbsp;\"&nbsp;+&nbsp;i&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"&nbsp;and&nbsp;\"&nbsp;+&nbsp;j&nbsp;+&nbsp;\"&nbsp;is&nbsp;\"&nbsp;+&nbsp;k);\n&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;/**&nbsp;返回两个整数变量较大的值&nbsp;*/\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;int&nbsp;max(int&nbsp;num1,&nbsp;int&nbsp;num2)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(num1&nbsp;&gt;&nbsp;num2){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;num1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;num2;\n      }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;&nbsp;\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">The&nbsp;maximum&nbsp;between&nbsp;5&nbsp;and&nbsp;2&nbsp;is&nbsp;5\n</pre><p>这个程序包含main方法和max方法。Main方法是被JVM调用的，除此之外，main方法和其它方法没什么区别。</p><p>main方法的头部是不变的，如例子所示，带修饰符public和static,返回void类型值，方法名字是main,此外带个一个String[]类型参数。String[]表明参数是字符串数组。</p><hr><h2>void 关键字</h2><p>本节说明如何声明和调用一个void方法。</p><p>下面的例子声明了一个名为printGrade的方法，并且调用它来打印给定的分数。</p><h3>示例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;TestVoidMethod&nbsp;{\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printGrade(78.5);\n&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;printGrade(double&nbsp;score)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(score&nbsp;&gt;=&nbsp;90.0)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\'A\');\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(score&nbsp;&gt;=&nbsp;80.0)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\'B\');\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(score&nbsp;&gt;=&nbsp;70.0)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\'C\');\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(score&nbsp;&gt;=&nbsp;60.0)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\'D\');\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\'F\');\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">C\n</pre><p>这里printGrade方法是一个void类型方法，它不返回值。</p><p>一个void方法的调用一定是一个语句。 所以，它被在main方法第三行以语句形式调用。就像任何以分号结束的语句一样。</p><hr><h2>通过值传递参数</h2><p>调用一个方法时候需要提供参数，你必须按照参数列表指定的顺序提供。</p><p>例如，下面的方法连续n次打印一个消息：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;static&nbsp;void&nbsp;nPrintln(String&nbsp;message,&nbsp;int&nbsp;n)&nbsp;{\n&nbsp;&nbsp; for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(message);\n}\n</pre><h3>示例</h3><p>下面的例子演示按值传递的效果。</p><p>该程序创建一个方法，该方法用于交换两个变量。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;TestPassByValue&nbsp;{\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;num1&nbsp;=&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;num2&nbsp;=&nbsp;2;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Before&nbsp;swap&nbsp;method,&nbsp;num1&nbsp;is&nbsp;\"&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num1&nbsp;+&nbsp;\"&nbsp;and&nbsp;num2&nbsp;is&nbsp;\"&nbsp;+&nbsp;num2);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;调用swap方法\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(num1,&nbsp;num2);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"After&nbsp;swap&nbsp;method,&nbsp;num1&nbsp;is&nbsp;\"&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num1&nbsp;+&nbsp;\"&nbsp;and&nbsp;num2&nbsp;is&nbsp;\"&nbsp;+&nbsp;num2);\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;/**&nbsp;交换两个变量的方法&nbsp;*/\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;swap(int&nbsp;n1,&nbsp;int&nbsp;n2)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"\\tInside&nbsp;the&nbsp;swap&nbsp;method\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"\\t\\tBefore&nbsp;swapping&nbsp;n1&nbsp;is&nbsp;\"&nbsp;+&nbsp;n1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;\"&nbsp;n2&nbsp;is&nbsp;\"&nbsp;+&nbsp;n2);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;交换&nbsp;n1&nbsp;与&nbsp;n2的值\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;temp&nbsp;=&nbsp;n1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n1&nbsp;=&nbsp;n2;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n2&nbsp;=&nbsp;temp;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"\\t\\tAfter&nbsp;swapping&nbsp;n1&nbsp;is&nbsp;\"&nbsp;+&nbsp;n1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;\"&nbsp;n2&nbsp;is&nbsp;\"&nbsp;+&nbsp;n2);\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Before&nbsp;swap&nbsp;method,&nbsp;num1&nbsp;is&nbsp;1&nbsp;and&nbsp;num2&nbsp;is&nbsp;2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inside&nbsp;the&nbsp;swap&nbsp;method\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Before&nbsp;swapping&nbsp;n1&nbsp;is&nbsp;1&nbsp;n2&nbsp;is&nbsp;2\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After&nbsp;swapping&nbsp;n1&nbsp;is&nbsp;2&nbsp;n2&nbsp;is&nbsp;1\nAfter&nbsp;swap&nbsp;method,&nbsp;num1&nbsp;is&nbsp;1&nbsp;and&nbsp;num2&nbsp;is&nbsp;2\n</pre><p>传递两个参数调用swap方法。有趣的是，方法被调用后，实参的值并没有改变。</p><hr><h2>方法的重载</h2><p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p><p>解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;static&nbsp;double&nbsp;max(double&nbsp;num1,&nbsp;double&nbsp;num2)&nbsp;{\n&nbsp;&nbsp;if&nbsp;(num1&nbsp;&gt;&nbsp;num2){\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;num1;\n&nbsp;&nbsp;}else{\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;num2;\n  }\n}\n</pre><p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p><p>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；</p><p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p><p>Java编译器根据方法签名判断哪个方法应该被调用。</p><p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p><p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p><hr><h2>变量作用域</h2><p>变量的范围是程序中该变量可以被引用的部分。</p><p>方法内定义的变量被称为局部变量。</p><p>局部变量的作用范围从声明开始，直到包含它的块结束。</p><p>局部变量必须声明才可以使用。</p><p>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</p><p>for循环的初始化部分声明的变量，其作用范围在整个循环。</p><p>但循环体内声明的变量其适用范围是从它声明到循环体结束。它包含如下所示的变量声明：</p><p><img src=\"http://localhost:8080/static/picture/1459506313251902.jpg\"></p><p>你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。</p><h2>命令行参数的使用</h2><p>有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。</p><p>命令行参数是在执行程序时候紧跟在程序名字后面的信息。</p><h3>实例</h3><p>下面的程序打印所有的命令行参数：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;CommandLine&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;&nbsp;i&lt;args.length;&nbsp;i++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n          System.out.println(\"args [\"&nbsp;+&nbsp;i&nbsp;+&nbsp;\"]:&nbsp;\"&nbsp;+&nbsp;args[i]);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;}\n</pre><p>如下所示，运行这个程序：</p><pre class=\"ql-syntax\" spellcheck=\"false\">java&nbsp;CommandLine&nbsp;this&nbsp;is&nbsp;a&nbsp;command&nbsp;line&nbsp;200&nbsp;-100\n</pre><p>运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">args[0]:&nbsp;this\nargs[1]:&nbsp;is\nargs[2]:&nbsp;a\nargs[3]:&nbsp;command\nargs[4]:&nbsp;line\nargs[5]:&nbsp;200\nargs[6]:&nbsp;-100\n</pre><hr><h2>构造方法</h2><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p><p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p><p>不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它把所有成员初始化为0。</p><p>一旦你定义了自己的构造方法，默认构造方法就会失效。</p><h3>实例</h3><p>下面是一个使用构造方法的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;一个简单的构造函数\nstatic class&nbsp;MyClass&nbsp;{\n&nbsp;&nbsp;&nbsp;int&nbsp;x;\n&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;//&nbsp;以下是构造函数\n&nbsp;&nbsp;&nbsp;MyClass()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;10;\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>你可以像下面这样调用构造方法来初始化一个对象：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;ConsDemo&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyClass&nbsp;t1&nbsp;=&nbsp;new&nbsp;MyClass();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyClass&nbsp;t2&nbsp;=&nbsp;new&nbsp;MyClass();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(t1.x&nbsp;+&nbsp;\"&nbsp;\"&nbsp;+&nbsp;t2.x);\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>大多时候需要一个有参数的构造方法。</p><h3>实例</h3><p>下面是一个使用构造方法的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;一个简单的构造函数\nclass&nbsp;MyClass&nbsp;{\n&nbsp;&nbsp;&nbsp;int&nbsp;x;\n&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;//&nbsp;以下是构造函数\n&nbsp;&nbsp;&nbsp;MyClass(int&nbsp;i&nbsp;)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;i;\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>你可以像下面这样调用构造方法来初始化一个对象：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;ConsDemo&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyClass&nbsp;t1&nbsp;=&nbsp;new&nbsp;MyClass(&nbsp;10&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyClass&nbsp;t2&nbsp;=&nbsp;new&nbsp;MyClass(&nbsp;20&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(t1.x&nbsp;+&nbsp;\"&nbsp;\"&nbsp;+&nbsp;t2.x);\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">10&nbsp;20\n</pre><h2>可变参数</h2><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p><p>方法的可变参数的声明如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">typeName...&nbsp;parameterName\n</pre><p>在方法声明中，在指定参数类型后加一个省略号(...) 。</p><p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;VarargsDemo&nbsp;{\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;调用可变参数的方法\n	&nbsp;&nbsp;printMax(34,&nbsp;3,&nbsp;3,&nbsp;2,&nbsp;56.5);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printMax(new&nbsp;double[]{1,&nbsp;2,&nbsp;3});\n&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;printMax(&nbsp;double...&nbsp;numbers)&nbsp;{\n&nbsp;&nbsp;&nbsp;if&nbsp;(numbers.length&nbsp;==&nbsp;0)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"No&nbsp;argument&nbsp;passed\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;double&nbsp;result&nbsp;=&nbsp;numbers[0];\n\n&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;&nbsp;numbers.length;&nbsp;i++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(numbers[i]&nbsp;&gt;&nbsp;&nbsp;result){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    result&nbsp;=&nbsp;numbers[i];\n       }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"The&nbsp;max&nbsp;value&nbsp;is&nbsp;\"&nbsp;+&nbsp;result);\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">The&nbsp;max&nbsp;value&nbsp;is&nbsp;56.5\nThe&nbsp;max&nbsp;value&nbsp;is&nbsp;3.0\n</pre><hr><h2>finalize() 方法</h2><p>Java允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做finalize( )，它用来清除回收对象。</p><p>例如，你可以使用finalize()来确保一个对象打开的文件被关闭了。</p><p>在finalize()方法里，你必须指定在对象销毁时候要执行的操作。</p><p>finalize()一般格式是：</p><pre class=\"ql-syntax\" spellcheck=\"false\">protected&nbsp;void&nbsp;finalize()\n{\n&nbsp;&nbsp;&nbsp;//&nbsp;在这里终结代码\n}\n</pre><p>关键字protected是一个限定符，它确保finalize() 方法不会被该类以外的代码调用。</p><p>当然，Java的内存回收可以由JVM来自动完成。如果你手动使用，则可以使用上面的方法。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public&nbsp;class&nbsp;FinalizationDemo&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cake&nbsp;c1&nbsp;=&nbsp;new&nbsp;Cake(1);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cake&nbsp;c2&nbsp;=&nbsp;new&nbsp;Cake(2);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cake&nbsp;c3&nbsp;=&nbsp;new&nbsp;Cake(3);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2&nbsp;=&nbsp;c3&nbsp;=&nbsp;null;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.gc();&nbsp;//调用Java垃圾收集器\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n}&nbsp;&nbsp;\n&nbsp;&nbsp;\nclass&nbsp;Cake&nbsp;extends&nbsp;Object&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;id;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Cake(int&nbsp;id)&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id&nbsp;=&nbsp;id;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Cake&nbsp;Object&nbsp;\"&nbsp;+&nbsp;id&nbsp;+&nbsp;\"is&nbsp;created\");&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;finalize()&nbsp;throws&nbsp;java.lang.Throwable&nbsp;{&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.finalize();&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Cake&nbsp;Object&nbsp;\"&nbsp;+&nbsp;id&nbsp;+&nbsp;\"is&nbsp;disposed\");&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n}\n</pre><p>运行以上代码，输出结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">C:\\1&gt;java&nbsp;FinalizationDemo&nbsp;&nbsp;\nCake&nbsp;Object&nbsp;1is&nbsp;created&nbsp;&nbsp;\nCake&nbsp;Object&nbsp;2is&nbsp;created&nbsp;&nbsp;\nCake&nbsp;Object&nbsp;3is&nbsp;created&nbsp;&nbsp;\nCake&nbsp;Object&nbsp;3is&nbsp;disposed&nbsp;&nbsp;\nCake&nbsp;Object&nbsp;2is&nbsp;disposed\n</pre><p><br></p><p><br></p>');
INSERT INTO `knowledge` VALUES (20, 2, 'Java 流(Stream)、文件(File)和IO', 1009, 'teacher', '2022-12-09 08:16:24', '<h2><strong style=\"background-color: rgb(240, 247, 255);\">Java 流(Stream)、文件(File)和IO</strong></h2><p><br></p><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p><p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><p>Java为I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p><p>但本节讲述最基本的和流与 I/O 相关的功能。我们将通过一个个例子来学习这些功能。</p><hr><h2>读取控制台输入</h2><p>Java 的控制台输入由 System.in 完成。</p><p>为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</p><p>下面是创建 BufferedReader 的基本语法：</p><pre class=\"ql-syntax\" spellcheck=\"false\">BufferedReader&nbsp;br&nbsp;=&nbsp;new&nbsp;BufferedReader(new InputStreamReader(System.in));\n</pre><p>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。</p><hr><h2>从控制台读取多字符输入</h2><p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">int&nbsp;read()&nbsp;throws&nbsp;IOException\n</pre><p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p><p>下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 \"q\" 。</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;使用&nbsp;BufferedReader&nbsp;在控制台读取字符\n\nimport&nbsp;java.io.*;\n\npublic&nbsp;class&nbsp;BRRead&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;throws&nbsp;IOException\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;使用&nbsp;System.in&nbsp;创建&nbsp;BufferedReader&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader&nbsp;br&nbsp;=&nbsp;new&nbsp;BufferedReader(new&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStreamReader(System.in));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"输入字符, 按下 \'q\' 键退出.\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;读取字符\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;(char)&nbsp;br.read();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(c);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while(c&nbsp;!=&nbsp;\'q\');\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">输入字符, 按下 \'q\' 键退出.\n123abcq\n1\n2\n3\na\nb\nc\nq\n</pre><hr><h2>从控制台读取字符串</h2><p>从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。</p><p>它的一般格式是：</p><pre class=\"ql-syntax\" spellcheck=\"false\">String&nbsp;readLine()&nbsp;throws&nbsp;IOException\n</pre><p>下面的程序读取和显示字符行直到你输入了单词 \"end\"。</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;使用&nbsp;BufferedReader&nbsp;在控制台读取字符\nimport&nbsp;java.io.*;\npublic&nbsp;class&nbsp;BRReadLines&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;throws&nbsp;IOException\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;使用&nbsp;System.in&nbsp;创建&nbsp;BufferedReader&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader&nbsp;br&nbsp;=&nbsp;new&nbsp;BufferedReader(new\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStreamReader(System.in));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;str;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Enter&nbsp;lines&nbsp;of&nbsp;text.\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Enter&nbsp;\'end\'&nbsp;to&nbsp;quit.\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;=&nbsp;br.readLine();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while(!str.equals(\"end\"));\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Enter&nbsp;lines&nbsp;of&nbsp;text.\nEnter&nbsp;\'end\'&nbsp;to&nbsp;quit.\nThis&nbsp;is&nbsp;line&nbsp;one\nThis&nbsp;is&nbsp;line&nbsp;one\nThis&nbsp;is&nbsp;line&nbsp;two\nThis&nbsp;is&nbsp;line&nbsp;two\nend\nend\n</pre><h2>控制台输出</h2><p>在此前已经介绍过，控制台的输出由 print() 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。</p><p>PrintStream 继承了 OutputStream 类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。</p><p>PrintStream 定义 write() 的最简单格式如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">void&nbsp;write(int&nbsp;byteval)\n</pre><p>该方法将 byteval 的低八位字节写到流中。</p><h3>实例</h3><p>下面的例子用 write() 把字符 \"A\" 和紧跟着的换行符输出到屏幕：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import&nbsp;java.io.*;\n\n//&nbsp;演示&nbsp;System.out.write().\npublic&nbsp;class&nbsp;WriteDemo&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;b;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;\'A\';\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.write(b);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.write(\'\\n\');\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>运行以上实例在输出窗口输出 \"A\" 字符</p><pre class=\"ql-syntax\" spellcheck=\"false\">A\n</pre><p><strong>注意：</strong>write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。</p><hr><h2>读写文件</h2><p>如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。</p><p>下图是一个描述输入流和输出流的类层次图。</p><p><img src=\"http://localhost:8080/static/picture/1459506359419466.jpg\"></p><p>下面将要讨论的两个重要的流是 FileInputStream 和 FileOutputStream：</p><hr><h2>FileInputStream</h2><p>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。</p><p>有多种构造方法可用来创建对象。</p><p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p><pre class=\"ql-syntax\" spellcheck=\"false\">InputStream&nbsp;f&nbsp;=&nbsp;new&nbsp;FileInputStream(\"C:/java/hello\");\n</pre><p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：</p><pre class=\"ql-syntax\" spellcheck=\"false\">File&nbsp;f&nbsp;=&nbsp;new&nbsp;File(\"C:/java/hello\");\nInputStream&nbsp;f&nbsp;=&nbsp;new&nbsp;FileInputStream(f);\n</pre><p>创建了 InputStream 对象，就可以使用下面的方法来读取流或者进行其他的流操作。</p><p><strong>序号方法及描述</strong>1<strong>public void close() throws IOException{}</strong></p><p>关闭此文件输入流并释放与此流有关的所有系统资源。抛出 IOException 异常。2<strong>protected void finalize()throws IOException {}</strong></p><p>这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出 IOException 异常。3<strong>public int read(int r)throws IOException{}</strong></p><p>这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回 -1。4<strong>public int read(byte[] r) throws IOException{}</strong></p><p>这个方法从输入流读取 r.length 长度的字节。返回读取的字节数。如果是文件结尾则返回 -1。5<strong>public int available() throws IOException{}</strong></p><p>返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。</p><p>除了 InputStream 外，还有一些其他的输入流，更多的细节参考下面链接：</p><ul><li>ByteArrayInputStream</li><li>DataInputStream</li></ul><hr><h2>FileOutputStream</h2><p>该类用来创建一个文件并向文件中写数据。</p><p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p><p>有两个构造方法可以用来创建 FileOutputStream 对象。</p><p>使用字符串类型的文件名来创建一个输出流对象：</p><pre class=\"ql-syntax\" spellcheck=\"false\">OutputStream&nbsp;f&nbsp;=&nbsp;new&nbsp;FileOutputStream(\"C:/java/hello\")\n</pre><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用 File() 方法来创建一个文件对象：</p><pre class=\"ql-syntax\" spellcheck=\"false\">File&nbsp;f&nbsp;=&nbsp;new&nbsp;File(\"C:/java/hello\");\nOutputStream&nbsp;f&nbsp;=&nbsp;new&nbsp;FileOutputStream(f);\n</pre><p>创建 OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。</p><p><strong>序号方法及描述</strong>1<strong>public void close() throws IOException{}</strong></p><p>关闭此文件输入流并释放与此流有关的所有系统资源。抛出 IOException 异常。2<strong>protected void finalize()throws IOException {}</strong></p><p>这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出 IOException 异常。3<strong>public void write(int w)throws IOException{}</strong></p><p>这个方法把指定的字节写到输出流中。4<strong>public void write(byte[] w)</strong></p><p>把指定数组中 w.length 长度的字节写到 OutputStream 中。</p><p>除了 OutputStream 外，还有一些其他的输出流，更多的细节参考下面链接：</p><ul><li>ByteArrayOutputStream</li><li>DataOutputStream</li></ul><h3>实例</h3><p>下面是一个演示 InputStream 和 OutputStream 用法的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.io.*;\n \npublic class fileStreamTest {\n    public static void main(String args[]) {\n        try {\n            byte bWrite[] = { 11, 21, 3, 40, 5 };\n            OutputStream os = new FileOutputStream(\"test.txt\");\n            for (int x = 0; x &lt; bWrite.length; x++) {\n                os.write(bWrite[x]); // writes the bytes\n            }\n            os.close();\n \n            InputStream is = new FileInputStream(\"test.txt\");\n            int size = is.available();\n \n            for (int i = 0; i &lt; size; i++) {\n                System.out.print((char) is.read() + \"  \");\n            }\n            is.close();\n        } catch (IOException e) {\n            System.out.print(\"Exception\");\n        }\n    }\n}\n</pre><p>上面的程序首先创建文件 test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。</p><p>以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：</p><pre class=\"ql-syntax\" spellcheck=\"false\">//文件名&nbsp;:fileStreamTest2.java\nimport&nbsp;java.io.*;\n\npublic&nbsp;class&nbsp;fileStreamTest2{\n	public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;IOException&nbsp;{\n		\n		File&nbsp;f&nbsp;=&nbsp;new&nbsp;File(\"a.txt\");\n		FileOutputStream&nbsp;fop&nbsp;=&nbsp;new&nbsp;FileOutputStream(f);\n		//&nbsp;构建FileOutputStream对象,文件不存在会自动新建\n		\n		OutputStreamWriter&nbsp;writer&nbsp;=&nbsp;new&nbsp;OutputStreamWriter(fop,&nbsp;\"UTF-8\");\n		//&nbsp;构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk\n		\n		writer.append(\"中文输入\");\n		//&nbsp;写入到缓冲区\n		\n		writer.append(\"\\r\\n\");\n		//换行\n		\n		writer.append(\"English\");\n		//&nbsp;刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入\n		\n		writer.close();\n		//关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉\n		\n		fop.close();\n		//&nbsp;关闭输出流,释放系统资源\n\n		FileInputStream&nbsp;fip&nbsp;=&nbsp;new&nbsp;FileInputStream(f);\n		//&nbsp;构建FileInputStream对象\n		\n		InputStreamReader&nbsp;reader&nbsp;=&nbsp;new&nbsp;InputStreamReader(fip,&nbsp;\"UTF-8\");\n		//&nbsp;构建InputStreamReader对象,编码与写入相同\n\n		StringBuffer&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuffer();\n		while&nbsp;(reader.ready())&nbsp;{\n			sb.append((char)&nbsp;reader.read());\n			//&nbsp;转成char加到StringBuffer对象中\n		}\n		System.out.println(sb.toString());\n		reader.close();\n		//&nbsp;关闭读取流\n		\n		fip.close();\n		//&nbsp;关闭输入流,释放系统资源\n\n	}\n}\n</pre><hr><h2>文件和I/O</h2><p>还有一些关于文件和 I/O 的类，我们也需要知道：</p><ul><li>File Class(类)</li><li>FileReader Class(类)</li><li>FileWriter Class(类)</li></ul><hr><h2>Java中的目录</h2><h3>创建目录：</h3><p>File 类中有两个方法可以用来创建文件夹：</p><ul><li><strong>mkdir( )&nbsp;</strong>方法创建一个文件夹，成功则返回 true，失败则返回 false。失败表明 File 对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li><li><strong>mkdirs( )&nbsp;</strong>方法创建一个文件夹和它的所有父文件夹。</li></ul><p>下面的例子创建 \"/tmp/user/java/bin\" 文件夹：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import&nbsp;java.io.File;\n\npublic&nbsp;class&nbsp;CreateDir&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;dirname&nbsp;=&nbsp;\"/tmp/user/java/bin\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;d&nbsp;=&nbsp;new&nbsp;File(dirname);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;现在创建目录\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.mkdirs();\n&nbsp;&nbsp;}\n}\n</pre><p>编译并执行上面代码来创建目录 \"/tmp/user/java/bin\"。</p><p><strong>注意：</strong>Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符(/) ，路径依然能够被正确解析。</p><hr><h2>读取目录</h2><p>一个目录其实就是一个 File 对象，它包含其他文件和文件夹。</p><p>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory( ) 方法会返回 true。</p><p>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。</p><p>下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import&nbsp;java.io.File;\n\npublic&nbsp;class&nbsp;DirList&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;dirname&nbsp;=&nbsp;\"/tmp\";\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;f1&nbsp;=&nbsp;new&nbsp;File(dirname);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(f1.isDirectory())&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&nbsp;\"Directory&nbsp;of&nbsp;\"&nbsp;+&nbsp;dirname);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s[]&nbsp;=&nbsp;f1.list();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;&nbsp;i&nbsp;&lt;&nbsp;s.length;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;f&nbsp;=&nbsp;new&nbsp;File(dirname&nbsp;+&nbsp;\"/\"&nbsp;+&nbsp;s[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(f.isDirectory())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s[i]&nbsp;+&nbsp;\"是一个目录\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s[i]&nbsp;+&nbsp;\"是一个文件\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(dirname&nbsp;+&nbsp;\"不是一个目录\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">目录 /tmp\nbin 是一个目录\nlib 是一个目录\ndemo 是一个目录\ntest.txt 是一个文件\nREADME 是一个文件\nindex.html 是一个文件\ninclude 是一个目录\n</pre><h2>删除目录或文件</h2><p>删除文件可以使用&nbsp;java.io.File.delete()&nbsp;方法。</p><p>以下代码会删除目录&nbsp;/tmp/java/，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。</p><p>测试目录结构：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/tmp/java/\n|-- 1.log\n|-- test\n</pre><h2>DeleteFileDemo.java 文件代码：</h2><pre class=\"ql-syntax\" spellcheck=\"false\">import java.io.File;\npublic class DeleteFileDemo {\n    public static void main(String args[]) {\n        // 这里修改为自己的测试目录\n        File folder = new File(\"/tmp/java/\");\n        deleteFolder(folder);\n    }\n    // 删除文件及目录\n    public static void deleteFolder(File folder) {\n        File[] files = folder.listFiles();\n        if (files != null) {\n            for (File f : files) {\n                if (f.isDirectory()) {\n                    deleteFolder(f);\n                } else {\n                    f.delete();\n                }\n            }\n        }\n        folder.delete();\n    }\n}\n</pre><p><br></p>');
INSERT INTO `knowledge` VALUES (21, 2, 'Java Scanner 类', 1003, 'teacher', '2022-12-09 08:16:51', '<h2><strong style=\"background-color: rgb(240, 247, 255);\">Java Scanner 类</strong></h2><p><br></p><p>java.util.Scanner是Java5的新特征，我们可以通过 Scanner 类来获取用户的输入。</p><p>下面是创建 Scanner 对象的基本语法：</p><pre class=\"ql-syntax\" spellcheck=\"false\"> Scanner s = new Scanner(System.in); \n</pre><p>接下来我们演示一个最简单的的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：</p><h3>使用 next 方法：</h3><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.Scanner; \n\npublic class ScannerDemo {  \n    public static void main(String[] args) {  \n        Scanner scan = new Scanner(System.in); \n		// 从键盘接收数据  \n\n		//next方式接收字符串\n        System.out.println(\"next方式接收：\");\n        // 判断是否还有输入\n        if(scan.hasNext()){   \n        	String str1 = scan.next();\n        	System.out.println(\"输入的数据为：\"+str1);  \n        }  \n\n    }  \n} \n</pre><p>执行以上程序输出结果为：</p><pre class=\"ql-syntax\" spellcheck=\"false\">$ javac ScannerDemo.java\n$ java ScannerDemo\nnext方式接收：\nyouj com\n输入的数据为：youj\n</pre><p>可以看到 com 字符串并未输出，接下来我们看 nextLine。</p><pre class=\"ql-syntax\" spellcheck=\"false\">使用 nextLine 方法：import java.util.Scanner; \n\npublic class ScannerDemo {  \n    public static void main(String[] args) {  \n        Scanner scan = new Scanner(System.in); \n		// 从键盘接收数据  \n\n		//nextLine方式接收字符串\n        System.out.println(\"nextLine方式接收：\");\n        // 判断是否还有输入\n        if(scan.hasNextLine()){   \n        	String str2 = scan.nextLine();\n        	System.out.println(\"输入的数据为：\"+str2);  \n        }  \n\n    }  \n} \n</pre><h3>执行以上程序输出结果为：</h3><pre class=\"ql-syntax\" spellcheck=\"false\">$ javac ScannerDemo.java\n$ java ScannerDemo\nnextLine方式接收：\nyouj com\n输入的数据为：youj com\n</pre><h3>可以看到 com 字符串输出。</h3><h3>next()与nextLine()区别</h3><p><strong>next():</strong></p><ul><li>1、一定要读取到有效字符后才可以结束输入。</li><li>2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉。</li><li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li>next()不能得到带有空格的字符串。</li></ul><p><strong>nextLine()：</strong></p><ul><li>1、以Enter为结束符,也就是说nextLine()方法返回的是输入回车之前的所有字符。</li><li>2、可以获得空白。</li></ul><p>如果要输入int或float类型的数据，在Scanner类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.Scanner;  \n\npublic class ScannerDemo {  \n    public static void main(String[] args) {  \n        Scanner scan = new Scanner(System.in);  \n		// 从键盘接收数据  \n        int i = 0 ;  \n        float f = 0.0f ;  \n        System.out.print(\"输入整数：\");  \n        if(scan.hasNextInt()){                 \n			// 判断输入的是否是整数  \n            i = scan.nextInt() ;                \n			// 接收整数  \n            System.out.println(\"整数数据：\" + i) ;  \n        }else{                                 \n			// 输入错误的信息  \n            System.out.println(\"输入的不是整数！\") ;  \n        }  \n        System.out.print(\"输入小数：\");  \n        if(scan.hasNextFloat()){              \n			// 判断输入的是否是小数  \n            f = scan.nextFloat() ;             \n			// 接收小数  \n            System.out.println(\"小数数据：\" + f) ;  \n        }else{                                \n			// 输入错误的信息  \n            System.out.println(\"输入的不是小数！\") ;  \n        }  \n    }  \n} \n</pre><p>执行以上程序输出结果为：</p><pre class=\"ql-syntax\" spellcheck=\"false\">$ javac ScannerDemo.java\n$ java ScannerDemo\n输入整数：12\n整数数据：12\n输入小数：1.2\n小数数据：1.2\n</pre><p>以下实例我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.util.Scanner; \n\nclass ScannerDemo   \n{  \n    public static void main(String[] args)   \n    {  \n        Scanner scan = new Scanner(System.in);  \n  \n        double sum = 0;  \n        int m = 0;  \n  \n        while(scan.hasNextDouble())  \n        {  \n            double x = scan.nextDouble();  \n            m = m + 1;  \n            sum = sum + x;  \n        }  \n  \n        System.out.println(m+\"个数的和为\"+sum);  \n        System.out.println(m+\"个数的平均值是\"+(sum/m));  \n    }  \n}  \n</pre><p>执行以上程序输出结果为：</p><pre class=\"ql-syntax\" spellcheck=\"false\">$ javac ScannerDemo.java\n$ java ScannerDemo\n12\n23\n15\n21.4\nend\n4个数的和为71.4\n4个数的平均值是17.85\n</pre><p>更多内容可以参考 API 文档：//www.w3cschool.cn/manual/jdk1.6/。</p>');
INSERT INTO `knowledge` VALUES (22, 2, 'Java 异常处理', 1006, 'teacher', '2022-12-09 08:17:12', '<h2>Java异常处理</h2><p><br></p><p><br></p><h2>什么是异常？</h2><p>程序运行时，发生的不被期望的事件，它阻止了程序按照程序员的预期正常执行，这就是异常。异常发生时，是任程序自生自灭，立刻退出终止，还是输出错误给用户？或者用C语言风格：用函数返回值作为执行状态？在Java中，异常就是Java在编译或运行或者运行过程中出现的错误。&nbsp;</p><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p><p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用 System.out.println(11/0)，那么你是因为你用 0 做了除数，会抛出 java.lang.ArithmeticException 的异常。</p><p>异常发生的原因有很多，通常包含以下几大类：</p><ul><li>用户输入了非法数据。</li><li>要打开的文件不存在。</li><li>网络通信时连接中断，或者 JVM 内存溢出。</li></ul><p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-</p><p>要理解 Java 异常处理是如何工作的，你需要掌握以下三种类型的异常：</p><ul><li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li><strong>运行时异常：</strong>&nbsp;运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><strong>错误：</strong>&nbsp;错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><hr><h2>Exception 类的层次</h2><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable 还有一个子类 Error 。</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在 Java 程序处理的范畴之外。</p><p>Error 用来指示运行时环境发生的错误。</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p><img src=\"http://localhost:8080/static/picture/1459506445622784.jpg\"></p><p>在 Java 内置类中(接下来会说明)，有大部分常用检查性和非检查性异常。</p><hr><h2>Java 内置异常类</h2><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。</p><p><strong>异常描述</strong>ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数\"除以零\"时，抛出此类的一个实例。ArrayIndexOutOfBoundsException用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。ArrayStoreException试图将错误类型的对象存储到一个对象数组时抛出的异常。ClassCastException当试图将对象强制转换为不是实例的子类时，抛出该异常。IllegalArgumentException抛出的异常表明向方法传递了一个不合法或不正确的参数。IllegalMonitorStateException抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。IllegalStateException在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。IllegalThreadStateException线程没有处于请求操作所要求的适当状态时抛出的异常。IndexOutOfBoundsException指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。NegativeArraySizeException如果应用程序试图创建大小为负的数组，则抛出该异常。NullPointerException当应用程序试图在需要对象的地方使用&nbsp;<code>null</code>&nbsp;时，抛出该异常NumberFormatException当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。SecurityException由安全管理器抛出的异常，指示存在安全侵犯。StringIndexOutOfBoundsException此异常由&nbsp;<code>String</code>&nbsp;方法抛出，指示索引或者为负，或者超出字符串的大小。UnsupportedOperationException当不支持请求的操作时，抛出该异常。</p><p>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。</p><p><strong>异常描述</strong>ClassNotFoundException应用程序试图加载类时，找不到相应的类，抛出该异常。CloneNotSupportedException当调用&nbsp;<code>Object</code>&nbsp;类中的&nbsp;<code>clone</code>&nbsp;方法克隆对象，但该对象的类无法实现&nbsp;<code>Cloneable</code>&nbsp;接口时，抛出该异常。IllegalAccessException拒绝访问一个类的时候，抛出该异常。InstantiationException当试图使用&nbsp;<code>Class</code>&nbsp;类中的&nbsp;<code>newInstance</code>&nbsp;方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。InterruptedException一个线程被另一个线程中断，抛出该异常。NoSuchFieldException请求的变量不存在NoSuchMethodException请求的方法不存在</p><h2>异常方法</h2><p>下面的列表是 Throwable 类的主要方法:</p><p><strong>序号方法及说明</strong>1<strong>public String getMessage()</strong></p><p>返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。2<strong>public Throwable getCause()</strong></p><p>返回一个Throwable 对象代表异常原因。3<strong>public String toString()</strong></p><p>使用getMessage()的结果返回类的串级名字。4<strong>public void printStackTrace()</strong></p><p>打印toString()结果和栈层次到System.err，即错误输出流。5<strong>public StackTraceElement [] getStackTrace()</strong></p><p>返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。6<strong>public Throwable fillInStackTrace()</strong></p><p>用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</p><h2>捕获异常</h2><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p><p>try/catch 代码块中的代码称为保护代码，使用&nbsp;try/catch 的语法如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">try\n{\n&nbsp;&nbsp;&nbsp;//&nbsp;程序代码\n}catch(ExceptionName&nbsp;e1)\n{\n&nbsp;&nbsp;&nbsp;//Catch&nbsp;块\n}\n</pre><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p><p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p><h3>实例</h3><p>下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;文件名&nbsp;:&nbsp;ExcepTest.java\nimport&nbsp;java.io.*;\npublic&nbsp;class&nbsp;ExcepTest{\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a[]&nbsp;=&nbsp;new&nbsp;int[2];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Access&nbsp;element&nbsp;three&nbsp;:\"&nbsp;+&nbsp;a[3]);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(ArrayIndexOutOfBoundsException&nbsp;e){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Exception&nbsp;thrown&nbsp;&nbsp;:\"&nbsp;+&nbsp;e);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Out&nbsp;of&nbsp;the&nbsp;block\");\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上代码编译运行输出结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Exception&nbsp;thrown&nbsp;&nbsp;:java.lang.ArrayIndexOutOfBoundsException:&nbsp;3\nOut&nbsp;of&nbsp;the&nbsp;block\n</pre><hr><h2>多重捕获块</h2><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p><p>多重捕获块的语法如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;try{\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序代码\n&nbsp;}catch(异常类型1&nbsp;异常的变量名1){\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序代码\n&nbsp;}catch(异常类型2&nbsp;异常的变量名2){\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序代码\n&nbsp;}catch(异常类型2&nbsp;异常的变量名2){\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序代码\n&nbsp;}\n</pre><p>上面的代码段包含了 3 个 catch 块。</p><p>可以在 try 语句后面添加任意数量的 catch 块。</p><p>如果保护代码中发生异常，异常被抛给第一个 catch 块。</p><p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。</p><p>如果不匹配，它会被传递给第二个 catch 块。</p><p>如此，直到异常被捕获或者通过所有的 catch 块。</p><h3>实例</h3><p>该实例展示了怎么使用多重 try/catch。</p><pre class=\"ql-syntax\" spellcheck=\"false\">try\n{\n&nbsp;&nbsp;&nbsp;file&nbsp;=&nbsp;new&nbsp;FileInputStream(fileName);\n&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;(byte)&nbsp;file.read();\n}catch(IOException&nbsp;i)\n{\n&nbsp;&nbsp;&nbsp;i.printStackTrace();\n&nbsp;&nbsp;&nbsp;return&nbsp;-1;\n}catch(FileNotFoundException&nbsp;f)&nbsp;//Not&nbsp;valid!\n{\n&nbsp;&nbsp;&nbsp;f.printStackTrace();\n&nbsp;&nbsp;&nbsp;return&nbsp;-1;\n}\n</pre><hr><h2>throws/throw关键字：</h2><p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><p>下面方法的声明抛出一个 RemoteException 异常：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import&nbsp;java.io.*;\npublic&nbsp;class&nbsp;className\n{\n&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;deposit(double&nbsp;amount)&nbsp;throws&nbsp;RemoteException\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;implementation\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RemoteException();\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;//Remainder&nbsp;of&nbsp;class&nbsp;definition\n}\n</pre><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p><p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import&nbsp;java.io.*;\npublic&nbsp;class&nbsp;className\n{\n&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;withdraw(double&nbsp;amount)&nbsp;throws&nbsp;RemoteException,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InsufficientFundsException\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Method&nbsp;implementation\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;//Remainder&nbsp;of&nbsp;class&nbsp;definition\n}\n</pre><hr><h2>finally 关键字</h2><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>finally 代码块出现在 catch 代码块最后，语法如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;try{\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序代码\n&nbsp;}catch(异常类型1&nbsp;异常的变量名1){\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序代码\n&nbsp;}catch(异常类型2&nbsp;异常的变量名2){\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序代码\n&nbsp;}finally{\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序代码\n&nbsp;}\n</pre><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;public&nbsp;class&nbsp;ExcepTest{\n\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a[]&nbsp;=&nbsp;new&nbsp;int[2];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Access&nbsp;element&nbsp;three&nbsp;:\"&nbsp;+&nbsp;a[3]);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(ArrayIndexOutOfBoundsException&nbsp;e){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Exception&nbsp;thrown&nbsp;&nbsp;:\"&nbsp;+&nbsp;e);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[0]&nbsp;=&nbsp;6;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"First&nbsp;element&nbsp;value:&nbsp;\"&nbsp;+a[0]);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"The&nbsp;finally&nbsp;statement&nbsp;is&nbsp;executed\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Exception&nbsp;thrown&nbsp;&nbsp;:java.lang.ArrayIndexOutOfBoundsException:&nbsp;3\nFirst&nbsp;element&nbsp;value:&nbsp;6\nThe&nbsp;finally&nbsp;statement&nbsp;is&nbsp;executed\n</pre><p>注意下面事项：</p><ul><li>catch 不能独立于 try 存在。</li><li>在 try/catch 后面添加 finally 块并非强制性要求的。</li><li>try 代码后不能既没 catch 块也没 finally 块。</li><li>try, catch, finally 块之间不能添加任何代码。</li></ul><hr><h2>声明自定义异常</h2><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p><ul><li>所有异常都必须是 Throwable 的子类。</li><li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li></ul><p>可以像下面这样定义自己的异常类：</p><pre class=\"ql-syntax\" spellcheck=\"false\">class&nbsp;MyException&nbsp;extends&nbsp;Exception{\n}\n</pre><p>只继承 Exception 类来创建的异常类是检查性异常类。</p><p>下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。</p><p>一个异常类和其它任何类一样，包含有变量和方法。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;文件名InsufficientFundsException.java\nimport&nbsp;java.io.*;\n\npublic&nbsp;class&nbsp;InsufficientFundsException&nbsp;extends&nbsp;Exception\n{\n&nbsp;&nbsp;&nbsp;private&nbsp;double&nbsp;amount;\n&nbsp;&nbsp;&nbsp;public&nbsp;InsufficientFundsException(double&nbsp;amount)\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.amount&nbsp;=&nbsp;amount;\n&nbsp;&nbsp;&nbsp;}&nbsp;\n&nbsp;&nbsp;&nbsp;public&nbsp;double&nbsp;getAmount()\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;amount;\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>为了展示如何使用我们自定义的异常类，</p><p>在下面的 CheckingAccount 类中包含一个 withdraw() 方法抛出一个 InsufficientFundsException 异常。</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;文件名称&nbsp;CheckingAccount.java\nimport&nbsp;java.io.*;\n\npublic&nbsp;class&nbsp;CheckingAccount\n{\n&nbsp;&nbsp;&nbsp;private&nbsp;double&nbsp;balance;\n&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;number;\n&nbsp;&nbsp;&nbsp;public&nbsp;CheckingAccount(int&nbsp;number)\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.number&nbsp;=&nbsp;number;\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;deposit(double&nbsp;amount)\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance&nbsp;+=&nbsp;amount;\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;withdraw(double&nbsp;amount)&nbsp;throws\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InsufficientFundsException\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(amount&nbsp;&lt;=&nbsp;balance)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance&nbsp;-=&nbsp;amount;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;needs&nbsp;=&nbsp;amount&nbsp;-&nbsp;balance;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;InsufficientFundsException(needs);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;double&nbsp;getBalance()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;balance;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getNumber()\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;number;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;}\n</pre><p>下面的 BankDemo 程序示范了如何调用 CheckingAccount 类的 deposit() 和 withdraw() 方法。</p><pre class=\"ql-syntax\" spellcheck=\"false\">//文件名称&nbsp;BankDemo.java\npublic&nbsp;class&nbsp;BankDemo\n{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;[]&nbsp;args)\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CheckingAccount&nbsp;c&nbsp;=&nbsp;new&nbsp;CheckingAccount(101);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Depositing&nbsp;$500...\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.deposit(500.00);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"\\nWithdrawing&nbsp;$100...\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.withdraw(100.00);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"\\nWithdrawing&nbsp;$600...\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.withdraw(600.00);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(InsufficientFundsException&nbsp;e)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Sorry,&nbsp;but&nbsp;you&nbsp;are&nbsp;short&nbsp;$\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;e.getAmount());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>编译上面三个文件，并运行程序 BankDemo，得到结果如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Depositing&nbsp;$500...\n\nWithdrawing&nbsp;$100...\n\nWithdrawing&nbsp;$600...\nSorry,&nbsp;but&nbsp;you&nbsp;are&nbsp;short&nbsp;$200.0\nInsufficientFundsException\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;CheckingAccount.withdraw(CheckingAccount.java:25)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;BankDemo.main(BankDemo.java:13)\n</pre><hr><h2>通用异常</h2><p>在 Java 中定义了两种类型的异常和错误。</p><ul><li><strong>JVM(Java虚拟机) 异常：</strong>由 JVM 抛出的异常或错误。例如：<code>NullPointerException类</code>，<code>ArrayIndexOutOfBoundsException类</code>，<code>ClassCastException类</code>。</li><li><strong>程序级异常：</strong>由程序或者API程序抛出的异常。例如&nbsp;<code>IllegalArgumentException类</code>，<code>IllegalStateException类</code>。</li></ul><p>学习完本教程，建议您进行实战练习来巩固您新学到的知识：<strong>点击进入实战</strong></p><p><br></p><p><br></p><hr><p><br></p><hr><p><br></p>');
INSERT INTO `knowledge` VALUES (23, 2, 'Java 继承', 1003, 'teacher', '2022-12-09 08:17:34', '<h2><strong>Java继承</strong></h2><p><br></p><p>继承是所有 OOP 语言和 Java 语言不可缺少的组成部分。</p><p>继承是 Java 面向对象编程技术的一块基石，是面向对象的三大特征之一，也是实现软件复用的重要手段，继承可以理解为一个对象从另一个对象获取属性的过程。</p><p>如果类 A 是类 B 的父类，而类&nbsp;B 是类 C 的父类，我们也称类 C 是 A 的子类，类 C 是从类 A 继承而来的。在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类。</p><p>继承中最常使用的两个关键字是<strong>&nbsp;extends&nbsp;</strong>和&nbsp;<strong>implements</strong>&nbsp;。</p><p>这两个关键字的使用决定了一个对象和另一个对象是否是 IS-A (是一个)关系。</p><p>通过使用这两个关键字，我们能实现一个对象获取另一个对象的属性。</p><p>所有 Java 的类均是由 java.lang.Object 类继承而来的，所以 Object 是所有类的祖先类，而除了 Object 外，所有类必须有一个父类。</p><p>通过&nbsp;<strong>extends&nbsp;</strong>关键字可以申明一个类是继承另外一个类而来的，一般形式如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">// A.java\npublic class A {\n    private int i;\n    protected int j;\n \n    public void func() {\n \n    }\n}\n \n// B.java\npublic class B extends A {\n&nbsp;&nbsp;&nbsp;&nbsp;public int z;\n\n&nbsp;&nbsp;&nbsp;&nbsp;public void fund(){\n\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;\n}\n</pre><p>以上的代码片段说明，类 B 由类 A 继承而来的，类 B 是类 A 的子类。而类 A 是 Object 的子类，这里可以不显示地声明。</p><p>作为子类，类 B 的实例拥有类 A 所有的成员变量，但对于 private 类型的成员变量类 B 却没有访问权限，这保障了类 A 的封装性。</p><hr><h2>IS-A 关系</h2><p>IS-A 就是说：一个对象是另一个对象的一个分类。</p><p>下面是使用关键字<strong>&nbsp;extends&nbsp;</strong>实现继承。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Animal{\n}\n\npublic class Mammal extends Animal{\n}\n\npublic class Reptile extends Animal{\n}\n\npublic class Dog extends Mammal{\n}\n</pre><p>基于上面的例子，以下说法是正确的：</p><ul><li>Animal 类是 Mammal 类的父类。</li><li>Animal 类是 Reptile 类的父类。</li><li>Mammal 类和 Reptile 类是 Animal 类的子类。</li><li>Dog 类既是 Mammal 类的子类又是 Animal 类的子类。</li></ul><p>分析以上示例中的 IS-A 关系，如下：</p><ul><li>Mammal IS-A Animal</li><li>Reptile IS-A Animal</li><li>Dog IS-A Mammal</li></ul><p>因此 : Dog IS-A Animal</p><p>通过使用关键字&nbsp;<strong>extends&nbsp;</strong>，子类可以继承父类的除 private 属性外所有的属性。</p><p>我们通过使用 instanceof 操作符，能够确定 Mammal IS-A Animal</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Dog extends Mammal{\n   public static void main(String args[]){\n\n      Animal a = new Animal();\n      Mammal m = new Mammal();\n      Dog d = new Dog();\n\n      System.out.println(m instanceof Animal);\n      System.out.println(d instanceof Mammal);\n      System.out.println(d instanceof Animal);\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">true\ntrue\ntrue\n</pre><p>介绍完&nbsp;<strong>extends&nbsp;</strong>关键字之后，我们再来看下&nbsp;<strong>implements&nbsp;</strong>关键字是怎样使用来表示 IS-A 关系。</p><p><strong>Implements&nbsp;</strong>关键字在类继承接口的情况下使用， 这种情况不能使用关键字&nbsp;<strong>extends&nbsp;</strong>。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public interface Animal {}\n\npublic class Mammal implements Animal{\n}\n\npublic class Dog extends Mammal{\n}\n</pre><hr><h2>instanceof 关键字</h2><p>可以使用&nbsp;<strong>instanceof</strong>&nbsp;运算符来检验 Mammal 和 dog 对象是否是 Animal 类的一个实例。</p><pre class=\"ql-syntax\" spellcheck=\"false\">interface Animal{}\n\nclass Mammal implements Animal{}\n\npublic class Dog extends Mammal{\n   public static void main(String args[]){\n\n      Mammal m = new Mammal();\n      Dog d = new Dog();\n\n      System.out.println(m instanceof Animal);\n      System.out.println(d instanceof Mammal);\n      System.out.println(d instanceof Animal);\n   }\n} \n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">true\ntrue\ntrue\n</pre><hr><h2>HAS-A 关系</h2><p>HAS-A 代表类和它的成员之间的从属关系。这有助于代码的重用和减少代码的错误。</p><h3>例子</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Vehicle{}\npublic class Speed{}\npublic class Van extends Vehicle{\n	private Speed sp;\n} \n</pre><p>Van 类和 Speed 类是 HAS-A 关系( Van 有一个 Speed )，这样就不用将 Speed 类的全部代码粘贴到 Van 类中了，并且 Speed 类也可以重复利用于多个应用程序。</p><p>在面向对象特性中，用户不必担心类的内部怎样实现。</p><p>Van 类将实现的细节对用户隐藏起来，因此，用户只需要知道怎样调用 Van 类来完成某一功能，而不必知道 Van 类是自己来做还是调用其他类来做这些工作。</p><p>Java 只支持单继承，也就是说，一个类不能继承多个类。</p><p>下面的做法是不合法的：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class extends Animal, Mammal{} \n</pre><p>Java 只支持单继承（继承基本类和抽象类），但是我们可以用接口来实现（多继承接口来实现），代码结构如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public class Apple extends Fruit implements Fruit1, Fruit2{}\n</pre><p>一般我们继承基本类和抽象类用&nbsp;<strong>extends&nbsp;</strong>关键字，实现接口类的继承用<strong>&nbsp;implements</strong>&nbsp;关键字。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (24, 2, 'Java 重写(Override)与重载(Overload)', 1003, 'teacher', '2022-12-09 08:18:21', '<h2><span style=\"background-color: rgb(240, 247, 255);\">Java 重写(Override)与重载(Overload)</span></h2><h3><br></h3><h3><strong>重写 (Override)</strong></h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！</p><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。</p><p>也就是说子类能够根据需要实现父类的方法。</p><p>在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">class Animal{\n\n   public void move(){\n      System.out.println(\"动物可以移动\");\n   }\n}\n\nclass Dog extends Animal{\n\n   public void move(){\n      System.out.println(\"狗可以跑和走\");\n   }\n}\n\npublic class TestDog{\n\n   public static void main(String args[]){\n      Animal a = new Animal(); // Animal 对象\n      Animal b = new Dog(); // Dog 对象\n\n      a.move();// 执行 Animal 类的方法\n\n      b.move();//执行 Dog 类的方法\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">动物可以移动\n狗可以跑和走\n</pre><p>在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move 方法。</p><p>这是由于在编译阶段，只是检查参数的引用类型。</p><p>然而在运行时，Java 虚拟机 (JVM) 指定对象的类型并且运行该对象的方法。</p><p>因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法。</p><p>思考以下例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">class Animal{\n\n   public void move(){\n      System.out.println(\"动物可以移动\");\n   }\n}\n\nclass Dog extends Animal{\n\n   public void move(){\n      System.out.println(\"狗可以跑和走\");\n   }\n   public void bark(){\n      System.out.println(\"狗可以吠叫\");\n   }\n}\n\npublic class TestDog{\n\n   public static void main(String args[]){\n      Animal a = new Animal(); // Animal 对象\n      Animal b = new Dog(); // Dog 对象\n\n      a.move();// 执行 Animal 类的方法\n      b.move();//执行 Dog 类的方法\n      a.bark();//执行 Animal 类的方法\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">TestDog.java:30: cannot find symbol\nsymbol  : method bark()\nlocation: class Animal\n                a.bark();\n                 ^\n</pre><p>该程序将抛出一个编译错误，因为 a 的引用类型 Animal 没有 bark 方法。</p><hr><h2>方法重写的规则</h2><ul><li>参数列表与被重写方法的参数列表必须完全相同。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li><li>子类方法的访问权限必须大于或等于父类方法的访问权限。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li></ul><hr><h2>Super 关键字的使用</h2><p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p><pre class=\"ql-syntax\" spellcheck=\"false\">class Animal{\n\n   public void move(){\n      System.out.println(\"动物可以移动\");\n   }\n}\n\nclass Dog extends Animal{\n\n   public void move(){\n      super.move(); // 应用super类的方法\n      System.out.println(\"狗可以跑和走\");\n   }\n}\n\npublic class TestDog{\n\n   public static void main(String args[]){\n\n      Animal b = new Dog(); //\n      b.move(); //执行 Dog类的方法\n\n   }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">动物可以移动\n狗可以跑和走\n</pre><h2>重载 (Overload)</h2><p>重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>最常用的地方就是构造器的重载。</p><p>重载规则</p><ul><li>被重载的方法必须改变参数列表；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public class Overloading {\n \n	public int test(){\n		System.out.println(\"test1\");\n		return 1;\n	}\n \n	public void test(int a){\n		System.out.println(\"test2\");\n	}	\n \n	//以下两个参数类型顺序不同\n	public String test(int a,String s){\n		System.out.println(\"test3\");\n		return \"returntest3\";\n	}	\n \n	public String test(String s,int a){\n		System.out.println(\"test4\");\n		return \"returntest4\";\n	}	\n \n	public static void main(String[] args){\n		Overloading o = new Overloading();\n		System.out.println(o.test());\n		o.test(1);\n		System.out.println(o.test(1,\"test3\"));\n		System.out.println(o.test(\"test4\",1));\n	}\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">test1\n1\ntest2\ntest3\nreturntest3\ntest4\nreturntest4\n</pre><hr><h2>重写与重载之间的区别</h2><p>区别点重载方法重写方法参数列表必须修改一定不能修改返回类型可以修改一定不能修改异常可以修改可以减少或删除，一定不能抛出新的或者更广的异常访问可以修改一定不能做更严格的限制（可以降低限制）</p><p><br></p><h2>总结</h2><p>方法的重写 (Overriding) 和重载 (Overloading) 是 java 多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><ul><li>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载 (Overloading)。</li><li>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写 (Overriding)。</li><li>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ul><p><img src=\"http://localhost:8080/static/picture/1597744851877031.png\"></p><p><br></p>');
INSERT INTO `knowledge` VALUES (25, 2, 'Java 多态', 1003, 'teacher', '2022-12-09 08:18:46', '<h2>Java 多态</h2><p><br></p><p>本章主要为大家介绍java多态的概念，以及便于理解的多态简单例子。</p><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>多态性是对象多种表现形式的体现。</p><p>比如我们说\"宠物\"这个对象，它就有很多不同的表达或实现，比如有小猫、小狗、蜥蜴等等。那么我到宠物店说\"请给我一只宠物\"，服务员给我小猫、小狗或者蜥蜴都可以，我们就说\"宠物\"这个对象就具备多态性。</p><p>接下来让我们通过实例来了解Java的多态。</p><h3>简单的例子</h3><pre class=\"ql-syntax\" spellcheck=\"false\">public interface Vegetarian{}\npublic class Animal{}\npublic class Deer extends Animal implements Vegetarian{}\n</pre><p>因为Deer类具有多重继承，所以它具有多态性。以上实例解析如下：</p><ul><li>一个 Deer IS-A（是一个） Animal</li><li>一个 Deer IS-A（是一个） Vegetarian</li><li>一个 Deer IS-A（是一个） Deer</li><li>一个 Deer IS-A（是一个）Object</li></ul><p>在Java中，所有的对象都具有多态性，因为任何对象都能通过IS-A测试的类型和Object类。</p><p>访问一个对象的唯一方法就是通过引用型变量。</p><p>引用型变量只能有一种类型，一旦被声明，引用型变量的类型就不能被改变了。</p><p>引用型变量不仅能够被重置为其他对象，前提是这些对象没有被声明为final。还可以引用和它类型相同的或者相兼容的对象。它可以声明为类类型或者接口类型。</p><p>当我们将引用型变量应用于Deer对象的引用时，下面的声明是合法的：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Deer d = new Deer();\nAnimal a = d;\nVegetarian v = d;\nObject o = d;\n</pre><p>所有的引用型变量d,a,v,o都指向堆中相同的Deer对象。</p><hr><h2>虚方法</h2><p>我们将介绍在Java中，当设计类时，被重写的方法的行为怎样影响多态性。</p><p>我们已经讨论了方法的重写，也就是子类能够重写父类的方法。</p><p>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。</p><p>要想调用父类中被重写的方法，则必须使用关键字super。</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : Employee.java */\npublic class Employee\n{\n   private String name;\n   private String address;\n   private int number;\n   public Employee(String name, String address, int number)\n   {\n      System.out.println(\"Constructing an Employee\");\n      this.name = name;\n      this.address = address;\n      this.number = number;\n   }\n   public void mailCheck()\n   {\n      System.out.println(\"Mailing a check to \" + this.name\n       + \" \" + this.address);\n   }\n   public String toString()\n   {\n      return name + \" \" + address + \" \" + number;\n   }\n   public String getName()\n   {\n      return name;\n   }\n   public String getAddress()\n   {\n      return address;\n   }\n   public void setAddress(String newAddress)\n   {\n      address = newAddress;\n   }\n   public int getNumber()\n   {\n     return number;\n   }\n}\n</pre><p>假设下面的类继承Employee类：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : Salary.java */\npublic class Salary extends Employee\n{\n   private double salary; //Annual salary\n   public Salary(String name, String address, int number, double\n      salary)\n   {\n       super(name, address, number);\n       setSalary(salary);\n   }\n   public void mailCheck()\n   {\n       System.out.println(\"Within mailCheck of Salary class \");\n       System.out.println(\"Mailing check to \" + getName()\n       + \" with salary \" + salary);\n   }\n   public double getSalary()\n   {\n       return salary;\n   }\n   public void setSalary(double newSalary)\n   {\n       if(newSalary &gt;= 0.0)\n       {\n          salary = newSalary;\n       }\n   }\n   public double computePay()\n   {\n      System.out.println(\"Computing salary pay for \" + getName());\n      return salary/52;\n   }\n}\n</pre><p>现在我们仔细阅读下面的代码，尝试给出它的输出结果：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : VirtualDemo.java */\npublic class VirtualDemo\n{\n   public static void main(String [] args)\n   {\n      Salary s = new Salary(\"Mohd Mohtashim\", \"Ambehta, UP\", 3, 3600.00);\n      Employee e = new Salary(\"John Adams\", \"Boston, MA\", 2, 2400.00);\n      System.out.println(\"Call mailCheck using Salary reference --\");\n      s.mailCheck();\n      System.out.println(\"\\n Call mailCheck using Employee reference--\");\n      e.mailCheck();\n    }\n}\n</pre><p>以上实例编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Constructing an Employee\nConstructing an Employee\nCall mailCheck using Salary reference --\nWithin mailCheck of Salary class\nMailing check to Mohd Mohtashim with salary 3600.0\n\nCall mailCheck using Employee reference--\nWithin mailCheck of Salary class\nMailing check to John Adams with salary 2400.0\n</pre><p>例子中，我们实例化了两个Salary对象。一个使用Salary引用s，另一个使用Employee引用。</p><p>编译时，编译器检查到mailCheck()方法在Salary类中的声明。</p><p>在调用s.mailCheck()时，Java虚拟机(JVM)调用Salary类的mailCheck()方法。</p><p>因为e是Employee的引用，所以调用e的mailCheck()方法则有完全不同的结果。</p><p>当编译器检查e.mailCheck()方法时，编译器检查到Employee类中的mailCheck()方法。</p><p>在编译的时候，编译器使用Employee类中的mailCheck()方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是Salary类中的mailCheck()方法。</p><p>该行为被称为虚拟方法调用，该方法被称为虚拟方法。</p><p>Java中所有的方法都能以这种方式表现，借此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。</p><h2>多态的实现方式</h2><h3>方式一：重写：</h3><p>这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：<a href=\"http://localhost:8080/java-override-overload.html\" rel=\"noopener noreferrer\" target=\"_blank\">Java 重写(Override)与重载(Overload)</a>。</p><h3>方式二：接口</h3><ul><li>1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li><li>2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看&nbsp;<a href=\"http://localhost:8080/java-interfaces.html\" rel=\"noopener noreferrer\" target=\"_blank\">java接口</a>&nbsp;这一章节的内容。</li></ul><h3>方式三：抽象类和抽象方法</h3><p>详情请看<a href=\"http://localhost:8080/java-abstraction.html\" rel=\"noopener noreferrer\" target=\"_blank\">&nbsp;Java 抽象类</a>&nbsp;章节</p><p><br></p>');
INSERT INTO `knowledge` VALUES (26, 2, 'Java 抽象类', 1003, 'teacher', '2022-12-09 08:19:10', '<h2>Java抽象类</h2><p><br></p><p>在 Java 面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><hr><h3>抽象类</h3><p>在Java语言中使用abstract class来定义抽象类。如下实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : Employee.java */\npublic abstract class Employee\n{\n   private String name;\n   private String address;\n   private int number;\n   public Employee(String name, String address, int number)\n   {\n      System.out.println(\"Constructing an Employee\");\n      this.name = name;\n      this.address = address;\n      this.number = number;\n   }\n   public double computePay()\n   {\n     System.out.println(\"Inside Employee computePay\");\n     return 0.0;\n   }\n   public void mailCheck()\n   {\n      System.out.println(\"Mailing a check to \" + this.name\n       + \" \" + this.address);\n   }\n   public String toString()\n   {\n      return name + \" \" + address + \" \" + number;\n   }\n   public String getName()\n   {\n      return name;\n   }\n   public String getAddress()\n   {\n      return address;\n   }\n   public void setAddress(String newAddress)\n   {\n      address = newAddress;\n   }\n   public int getNumber()\n   {\n     return number;\n   }\n}\n</pre><p>注意到该Employee类没有什么不同，尽管该类是抽象类，但是它仍然有3个成员变量，7个成员方法和1个构造方法。 现在如果你尝试如下的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : AbstractDemo.java */\npublic class AbstractDemo\n{\n   public static void main(String [] args)\n   {\n      /* 以下是不允许的，会引发错误 */\n      Employee e = new Employee(\"George W.\", \"Houston, TX\", 43);\n\n      System.out.println(\"\\n Call mailCheck using Employee reference--\");\n      e.mailCheck();\n    }\n}\n</pre><p>当你尝试编译AbstractDemo类时，会产生如下错误：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Employee.java:46: Employee is abstract; cannot be instantiated\n      Employee e = new Employee(\"George W.\", \"Houston, TX\", 43);\n                   ^\n1 error\n</pre><hr><h2>继承抽象类</h2><p>我们能通过一般的方法继承Employee类：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : Salary.java */\npublic class Salary extends Employee\n{\n   private double salary; //Annual salary\n   public Salary(String name, String address, int number, double\n      salary)\n   {\n       super(name, address, number);\n       setSalary(salary);\n   }\n   public void mailCheck()\n   {\n       System.out.println(\"Within mailCheck of Salary class \");\n       System.out.println(\"Mailing check to \" + getName()\n       + \" with salary \" + salary);\n   }\n   public double getSalary()\n   {\n       return salary;\n   }\n   public void setSalary(double newSalary)\n   {\n       if(newSalary &gt;= 0.0)\n       {\n          salary = newSalary;\n       }\n   }\n   public double computePay()\n   {\n      System.out.println(\"Computing salary pay for \" + getName());\n      return salary/52;\n   }\n}\n</pre><p>尽管我们不能实例化一个Employee类的对象，但是如果我们实例化一个Salary类对象，该对象将从Employee类继承3个成员变量和7个成员方法。</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : AbstractDemo.java */\npublic class AbstractDemo\n{\n   public static void main(String [] args)\n   {\n      Salary s = new Salary(\"Mohd Mohtashim\", \"Ambehta, UP\", 3, 3600.00);\n      Employee e = new Salary(\"John Adams\", \"Boston, MA\", 2, 2400.00);\n\n      System.out.println(\"Call mailCheck using Salary reference --\");\n      s.mailCheck();\n\n      System.out.println(\"\\n Call mailCheck using Employee reference--\");\n      e.mailCheck();\n    }\n}\n</pre><p>以上程序编译运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Constructing an Employee\nConstructing an Employee\nCall mailCheck using  Salary reference --\nWithin mailCheck of Salary class\nMailing check to Mohd Mohtashim with salary 3600.0\n\nCall mailCheck using Employee reference--\nWithin mailCheck of Salary class\nMailing check to John Adams with salary 2400.\n</pre><hr><h2>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p>Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><pre class=\"ql-syntax\" spellcheck=\"false\">public abstract class Employee\n{\n   private String name;\n   private String address;\n   private int number;\n   \n   public abstract double computePay();\n   \n   //其余代码\n}\n</pre><p>声明抽象方法会造成以下两个结果：</p><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li></ul><p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><p>如果Salary类继承了Employee类，那么它必须实现computePay()方法：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : Salary.java */\npublic class Salary extends Employee\n{\n   private double salary; // Annual salary\n  \n   public double computePay()\n   {\n      System.out.println(\"Computing salary pay for \" + getName());\n      return salary/52;\n   }\n\n   //其余代码\n}\n</pre><p><br></p>');
INSERT INTO `knowledge` VALUES (27, 2, 'Java 封装', 1003, 'teacher', '2022-12-09 08:19:33', '<h2><strong>Java封装</strong></h2><p><br></p><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指，一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。</p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的接口控制。</p><p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><h3>实例</h3><p>让我们来看一个java封装类的例子：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名: EncapTest.java */\npublic class EncapTest{\n\n   private String name;\n   private String idNum;\n   private int age;\n\n   public int getAge(){\n      return age;\n   }\n\n   public String getName(){\n      return name;\n   }\n\n   public String getIdNum(){\n      return idNum;\n   }\n\n   public void setAge( int newAge){\n      age = newAge;\n   }\n\n   public void setName(String newName){\n      name = newName;\n   }\n\n   public void setIdNum( String newId){\n      idNum = newId;\n   }\n}\n</pre><p>以上实例中public方法是外部类访问该类成员变量的入口。</p><p>通常情况下，这些方法被称为getter和setter方法。</p><p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</p><p>通过如下的例子说明EncapTest类的变量怎样被访问：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* F文件名 : RunEncap.java */\npublic class RunEncap{\n\n   public static void main(String args[]){\n      EncapTest encap = new EncapTest();\n      encap.setName(\"James\");\n      encap.setAge(20);\n      encap.setIdNum(\"12343ms\");\n\n      System.out.print(\"Name : \" + encap.getName()+ \n                             \" Age : \"+ encap.getAge());\n    }\n}\n</pre><p>以上代码编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Name : James Age : 20\n</pre><p><br></p>');
INSERT INTO `knowledge` VALUES (28, 2, 'Java 接口', 1003, 'teacher', '2022-12-09 08:19:49', '<h2><strong>Java接口</strong></h2><p><br></p><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><p>接口与类相似点：</p><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在.java结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在.class结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><p>接口与类的区别：</p><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了static和final变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多重继承。</li></ul><hr><h2>接口的声明</h2><p>接口的声明语法格式如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">[可见度] interface 接口名称 [extends 其他的类名] {\n        // 声明变量\n        // 抽象方法\n}\n</pre><p>Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : NameOfInterface.java */\nimport java.lang.*;\n//引入包\n\npublic interface NameOfInterface\n{\n   //任何类型 final, static 字段\n   //抽象方法\n}\n</pre><p>接口有以下特性：</p><ul><li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li><li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li><li>接口中的方法都是公有的。</li></ul><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : Animal.java */\ninterface Animal {\n\n   public void eat();\n   public void travel();\n}\n</pre><hr><h2>接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p><p>实现一个接口的语法，可以使用这个公式：</p><pre class=\"ql-syntax\" spellcheck=\"false\">... implements 接口名称[, 其他接口, 其他接口..., ...] ...\n</pre><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名 : MammalInt.java */\npublic class MammalInt implements Animal{\n\n   public void eat(){\n      System.out.println(\"Mammal eats\");\n   }\n\n   public void travel(){\n      System.out.println(\"Mammal travels\");\n   } \n\n   public int noOfLegs(){\n      return 0;\n   }\n\n   public static void main(String args[]){\n      MammalInt m = new MammalInt();\n      m.eat();\n      m.travel();\n   }\n} \n</pre><p>以上实例编译运行结果如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Mammal eats\nMammal travels\n</pre><p>重写接口中声明的方法时，需要注意以下规则：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li></ul><p>在实现接口的时候，也要注意一些规则：</p><ul><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul><hr><h2>接口的继承</h2><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p><p>下面的Sports接口被Hockey和Football接口继承：</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 文件名: Sports.java\npublic interface Sports\n{\n   public void setHomeTeam(String name);\n   public void setVisitingTeam(String name);\n}\n\n// 文件名: Football.java\npublic interface Football extends Sports\n{\n   public void homeTeamScored(int points);\n   public void visitingTeamScored(int points);\n   public void endOfQuarter(int quarter);\n}\n\n// 文件名: Hockey.java\npublic interface Hockey extends Sports\n{\n   public void homeGoalScored();\n   public void visitingGoalScored();\n   public void endOfPeriod(int period);\n   public void overtimePeriod(int ot);\n}\n</pre><p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。</p><p>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。</p><hr><h2>接口的多重继承</h2><p>在Java中，类的多重继承是不合法，但接口允许多重继承，。</p><p>在接口的多重继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public interface Hockey extends Sports, Event\n</pre><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多重继承，而 Sports及 Event 可能定义或是继承相同的方法</p><hr><h2>标记接口</h2><p>最常用的继承接口是没有包含任何方法的接口。</p><p>标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p><p>标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p>例如：java.awt.event包中的MouseListener接口继承的java.util.EventListener接口定义如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">package java.util;\npublic interface EventListener\n{}\n</pre><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><ul><li><strong>建立一个公共的父接口：</strong></li><li>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</li><li><strong>向一个类添加数据类型：</strong></li><li>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</li></ul><p><br></p>');
INSERT INTO `knowledge` VALUES (29, 2, 'Java 包(package)', 1003, 'teacher', '2022-12-09 08:20:05', '<h2><strong>Java包</strong></h2><p><br></p><p>为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。</p><p><strong>包的作用</strong></p><ul><li>1 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li><li>2 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li><li>3 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li></ul><p>Java使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p><p>包语句的语法格式为：</p><pre class=\"ql-syntax\" spellcheck=\"false\">package pkg1[．pkg2[．pkg3…]];\n</pre><p>例如,一个Something.java 文件它的内容</p><pre class=\"ql-syntax\" spellcheck=\"false\">package net.java.util\npublic class Something{\n   ...\n}\n</pre><p>那么它的路径应该是 net/java/util/Something.java 这样保存的。 package(包)的作用是把不同的java程序分类保存，更方便的被其他java程序调用。</p><p>一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。</p><p>以下是一些Java中的包：</p><ul><li>java.lang-打包基础的类</li><li>java.io-包含输入输出功能的函数</li></ul><p>开发者可以自己把一组类和接口等打包，并定义自己的package。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。</p><p>由于package创建了新的命名空间（namespace），所以不会跟其他package中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。</p><hr><h2>创建包</h2><p>创建package的时候，你需要为这个package取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个package的声明放在这个源文件的开头。</p><p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</p><p>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</p><h3>例子</h3><p>让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。</p><p>在animals包中加入一个接口（interface）：</p><pre class=\"ql-syntax\" spellcheck=\"false\">/* 文件名: Animal.java */\npackage animals;\n\ninterface Animal {\n   public void eat();\n   public void travel();\n}\n</pre><p>接下来，在同一个包中加入该接口的实现：</p><pre class=\"ql-syntax\" spellcheck=\"false\">package animals;\n\n/* 文件名 : MammalInt.java */\npublic class MammalInt implements Animal{\n\n   public void eat(){\n      System.out.println(\"Mammal eats\");\n   }\n\n   public void travel(){\n      System.out.println(\"Mammal travels\");\n   } \n\n   public int noOfLegs(){\n      return 0;\n   }\n\n   public static void main(String args[]){\n      MammalInt m = new MammalInt();\n      m.eat();\n      m.travel();\n   }\n} \n</pre><p>然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。 用下面的命令来运行：</p><pre class=\"ql-syntax\" spellcheck=\"false\">$ mkdir animals\n$ cp Animal.class  MammalInt.class animals\n$ java animals/MammalInt\nMammal eats\nMammal travel\n</pre><hr><h2>import关键字</h2><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用\"import\"语句可完成此功能。</p><p>在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import package1[.package2…].(classname|*);\n</pre><p>如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。</p><h3>例子</h3><p>下面的payroll包已经包含了Employee类，接下来向payroll包中添加一个Boss类。Boss类引用Employee类的时候可以不用使用payroll前缀，Boss类的实例如下。</p><pre class=\"ql-syntax\" spellcheck=\"false\">package payroll;\n\npublic class Boss\n{\n   public void payEmployee(Employee e)\n   {\n      e.mailCheck();\n   }\n}\n</pre><p>如果Boss类不在payroll包中又会怎样？Boss类必须使用下面几种方法之一来引用其他包中的类</p><p>使用类全名描述，例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">payroll.Employee\n</pre><p>用import关键字引入，使用通配符\"*\"</p><pre class=\"ql-syntax\" spellcheck=\"false\">import payroll.*;\n</pre><p>使用import关键字引入Employee类</p><pre class=\"ql-syntax\" spellcheck=\"false\">import payroll.Employee;\n</pre><p><strong>注意：</strong></p><p>类文件中可以包含任意数量的import声明。import声明必须在包声明之后，类声明之前。</p><hr><h2>package的目录结构</h2><p>类放在包中会有两种主要的结果：</p><ul><li>包名成为类名的一部分，正如我们前面讨论的一样。</li><li>包名必须与相应的字节码所在的目录结构相吻合。</li></ul><p>下面是管理你自己java中文件的一种简单方式：</p><p>将类、接口等类型的源码放在一个文件中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 文件名 :  Car.java\n\npackage vehicle;\n\npublic class Car {\n   // 类实现  \n}\n</pre><p>接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。</p><pre class=\"ql-syntax\" spellcheck=\"false\">....\\vehicle\\Car.java\n</pre><p>现在，正确的类名和路径将会是如下样子：</p><ul><li>类名 -&gt; vehicle.Car</li><li>路径名 -&gt; vehicle\\Car.java (in windows)</li></ul><p>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是apple.com，所有的包名都以com.apple开头。包名中的每一个部分对应一个子目录。</p><p>例如：这个公司有一个com.apple.computers的包，这个包包含一个叫做Dell.java的源文件，那么相应的，应该有如下面的一连串子目录：</p><pre class=\"ql-syntax\" spellcheck=\"false\">....\\com\\apple\\computers\\Dell.java\n</pre><p>编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上.class作为扩展后缀。 例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 文件名: Dell.java\n\npackage com.apple.computers;\npublic class Dell{\n      \n}\nclass Ups{\n      \n}\n</pre><p>现在，我们用-d选项来编译这个文件，如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">$javac -d . Dell.java\n</pre><p>这样会像下面这样放置编译了的文件：</p><pre class=\"ql-syntax\" spellcheck=\"false\">.\\com\\apple\\computers\\Dell.class.\\com\\apple\\computers\\Ups.class\n</pre><p>你可以像下面这样来导入所有 \\com\\apple\\computers\\中定义的类、接口等：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import com.apple.computers.*;\n</pre><p>编译之后的.class文件应该和.java源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求.class文件的路径跟相应的.java的路径一样。你可以分开来安排源码和类的目录。</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;path-one&gt;\\sources\\com\\apple\\computers\\Dell.java\n&lt;path-two&gt;\\classes\\com\\apple\\computers\\Dell.class\n</pre><p>这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java虚拟机（JVM）可以找到你程序中使用的所有类型。</p><p>类目录的绝对路径叫做class path。设置在系统变量CLASSPATH中。编译器和java虚拟机通过将package名字加到class path后来构造.class文件的路径。</p><p>&lt;path- two&gt;\\classes是class path，package名字是com.apple.computers,而编译器和JVM会在 &lt;path-two&gt;\\classes\\com\\apple\\compters中找.class文件。</p><p>一个class path可能会包含好几个路径。多路径应该用分隔符分开。默认情况下，编译器和JVM查找当前目录。JAR文件按包含Java平台相关的类，所以他们的目录默认放在了class path中。</p><hr><h2>设置CLASSPATH系统变量</h2><p>用下面的命令显示当前的CLASSPATH变量：</p><ul><li>Windows平台（DOS 命令行下）-&gt; C:\\&gt; set CLASSPATH</li><li>UNIX平台（Bourne shell下）-&gt; % echo $CLASSPATH</li></ul><p>删除当前CLASSPATH变量内容：</p><p><br></p><ul><li>Windows平台（DOS 命令行下）-&gt; C:\\&gt; set CLASSPATH=</li><li>UNIX平台（Bourne shell下）-&gt; % unset CLASSPATH; export CLASSPATH</li></ul><p>设置CLASSPATH变量:</p><ul><li>Windows平台（DOS 命令行下）-&gt; set CLASSPATH=C:\\users\\jack\\java\\classes</li><li>UNIX平台（Bourne shell下）-&gt; % CLASSPATH=/home/jack/java/classes; export CLASSPATH</li></ul><p><br></p>');
INSERT INTO `knowledge` VALUES (30, 2, 'Java Applet基础', 1004, 'teacher', '2022-12-09 08:20:40', '<h2>Java Applet基础</h2><p><br></p><p>applet是一种Java程序。它一般运行在支持Java的Web浏览器内。因为它有完整的Java API支持,所以applet是一个全功能的Java应用程序。</p><p>如下所示是独立的Java应用程序和applet程序之间重要的不同：</p><ul><li>Java中applet类继承了 java.applet.Applet类</li><li>Applet类没有定义main()，所以一个 Applet程序不会调用main()方法，</li><li>Applets被设计为嵌入在一个HTML页面。</li><li>当用户浏览包含Applet的HTML页面，Applet的代码就被下载到用户的机器上。</li><li>要查看一个applet需要JVM。 JVM可以是Web浏览器的一个插件，或一个独立的运行时环境。</li><li>用户机器上的JVM创建一个applet类的实例，并调用Applet生命周期过程中的各种方法。</li><li>Applets有Web浏览器强制执行的严格的安全规则，applet的安全机制被称为沙箱安全。</li><li>applet需要的其他类可以用Java归档（JAR）文件的形式下载下来。</li></ul><hr><h3>Applet的生命周期</h3><p>Applet类中的四个方法给你提供了一个框架，你可以在该框架上开发小程序：</p><ul><li><strong>init:&nbsp;</strong>该方法的目的是为你的applet提供所需的任何初始化。在Applet标记内的param标签被处理后调用该方法。</li><li><strong>start:</strong>&nbsp;浏览器调用init方法后，该方法被自动调用。每当用户从其他页面返回到包含Applet的页面时，则调用该方法。</li><li><strong>stop:</strong>当用户从包含applet的页面移除的时候，该方法自动被调用。因此，可以在相同的applet中反复调用该方法。</li><li><strong>destroy:&nbsp;</strong>此方法仅当浏览器正常关闭时调用。因为applets只有在HTML网页上有效，所以你不应该在用户离开包含Applet的页面后遗漏任何资源.</li><li><strong>paint:</strong>&nbsp;该方法在start()方法之后立即被调用，或者在applet需要重绘在浏览器的时候调用。paint()方法实际上继承于java.awt。</li></ul><hr><h2>\"Hello, World\" Applet:</h2><p>下面是一个简单的Applet程序HelloWorldApplet.java:</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.applet.*;\nimport java.awt.*;\n \npublic class HelloWorldApplet extends Applet\n{\n   public void paint (Graphics g)\n   {\n      g.drawString (\"Hello World\", 25, 50);\n   }\n}\n</pre><p>这些import语句将以下类导入到我们的applet类中：</p><pre class=\"ql-syntax\" spellcheck=\"false\">java.applet.Applet.\njava.awt.Graphics.\n</pre><p>没有这些import语句，Java编译器就识别不了Applet和Graphics类。</p><hr><h2>Applet 类</h2><p>每一个applet都是java.applet.Applet 类的子类，基础的Applet类提供了供衍生类调用的方法,以此来得到浏览器上下文的信息和服务。</p><p>这些方法做了如下事情：</p><ul><li>得到applet的参数</li><li>得到包含applet的HTML文件的网络位置</li><li>得到applet类目录的网络位置</li><li>打印浏览器的状态信息</li><li>获取一张图片</li><li>获取一个音频片段</li><li>播放一个音频片段</li><li>调整此 applet 的大小</li></ul><p>除此之外，Applet类还提供了一个接口，该接口供Viewer或浏览器来获取applet的信息，并且来控制applet的执行。</p><p>Viewer可能是：</p><ul><li>请求applet作者、版本和版权的信息</li><li>请求applet识别的参数的描述</li><li>初始化applet</li><li>销毁applet</li><li>开始执行applet</li><li>结束执行applet</li></ul><p>Applet类提供了对这些方法的默认实现，这些方法可以在需要的时候重写。</p><p>\"Hello，World\"applet都是按标准编写的。唯一被重写的方法是paint方法。</p><hr><h2>Applet的调用</h2><p>applet是一种Java程序。它一般运行在支持Java的Web浏览器内。因为它有完整的Java API支持,所以applet是一个全功能的Java应用程序。</p><p>&lt;applet&gt;标签是在HTML文件中嵌入applet的基础。以下是一个调用\"Hello World\"applet的例子；</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;html&gt;\n&lt;title&gt;The Hello, World Applet&lt;/title&gt;\n&lt;hr&gt;\n&lt;applet code=\"HelloWorldApplet.class\" width=\"320\" height=\"120\"&gt;\nIf your browser was Java-enabled, a \"Hello, World\"\nmessage would appear here.\n&lt;/applet&gt;\n&lt;hr&gt;\n&lt;/html&gt;\n</pre><p><strong>注意:&nbsp;</strong>你可以参照HTML Applet标签来更多的了解从HTML中调用applet的方法。</p><p>&lt;applet&gt;标签的属性指定了要运行的Applet类。Width和height用来指定applet运行面板的初始大小。applet必须使用&lt;/applet&gt;标签来关闭。</p><p>如果applet接受参数，那么参数的值需要在标签里添加，该标签位于&lt;applet&gt;和&lt;/applet&gt;之间。浏览器忽略了applet标签之间的文本和其他标签。</p><p>不支持Java的浏览器不能执行&lt;applet&gt;和&lt;/applet&gt;。因此，在标签之间显示并且和applet没有关系的任何东西，在不支持的Java的浏览器里是可见的。</p><p>Viewer或者浏览器在文档的位置寻找编译过的Java代码，要指定文档的路径，得使用&lt;applet&gt;标签的codebase属性指定。</p><p>如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;applet codebase=\"http://amrood.com/applets\" code=\"HelloWorldApplet.class\" width=\"320\" height=\"120\"&gt;\n</pre><p>如果applet所在一个包中而不是默认包，那么所在的包必须在code属性里指定，例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;applet code=\"mypackage.subpackage.TestApplet.class\" width=\"320\" height=\"120\"&gt;\n</pre><h2>获得applet参数</h2><p>下面的例子演示了如何使用一个applet响应来设置文件中指定的参数。该Applet显示了一个黑色棋盘图案和第二种颜色。</p><p>第二种颜色和每一列的大小通过文档中的applet的参数指定。</p><p>CheckerApplet 在init()方法里得到它的参数。也可以在paint()方法里得到它的参数。然而，在applet开始得到值并保存了设置，而不是每一次刷新的时候都得到值，这样是很方便，并且高效的。</p><p>applet viewer或者浏览器在applet每次运行的时候调用init()方法。在加载applet之后，Viewer立即调用init()方法（Applet.init()什么也没做），重写该方法的默认实现，添加一些自定义的初始化代码。</p><p>Applet.getParameter()方法通过给出参数名称得到参数值。如果得到的值是数字或者其他非字符数据，那么必须解析为字符串类型。</p><p>下例是CheckerApplet.java的梗概：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.applet.*;\nimport java.awt.*;\npublic class CheckerApplet extends Applet\n{\n   int squareSize = 50;// 初始化默认大小\n   public void init () {}\n   private void parseSquareSize (String param) {}\n   private Color parseColor (String param) {}\n   public void paint (Graphics g) {}\n}\n</pre><p>下面是CheckerApplet类的init()方法和私有的parseSquareSize()方法：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public void init ()\n{\n   String squareSizeParam = getParameter (\"squareSize\");\n   parseSquareSize (squareSizeParam);\n   String colorParam = getParameter (\"color\");\n   Color fg = parseColor (colorParam);\n   setBackground (Color.black);\n   setForeground (fg);\n}\nprivate void parseSquareSize (String param)\n{\n   if (param == null) return;\n   try {\n      squareSize = Integer.parseInt (param);\n   }\n   catch (Exception e) {\n     // 保留默认值\n   }\n}\n</pre><p>该applet调用parseSquareSize()，来解析squareSize参数。parseSquareSize()调用了库方法Integer. parseInt()，该方法将一个字符串解析为一个整数，当参数无效的时候，Integer.parseInt()抛出异常。</p><p>因此，parseSquareSize()方法也是捕获异常的，并不允许applet接受无效的输入。</p><p>Applet调用parseColor()方法将颜色参数解析为一个Color值。parseColor()方法做了一系列字符串的比较，来匹配参数的值和预定义颜色的名字。你需要实现这些方法来使applet工作。</p><hr><h2>指定applet参数</h2><p>如下的例子是一个HTML文件，其中嵌入了CheckerApplet类。HTML文件通过使用标签的方法给applet指定了两个参数。</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;html&gt;\n&lt;title&gt;Checkerboard Applet&lt;/title&gt;\n&lt;hr&gt;\n&lt;applet code=\"CheckerApplet.class\" width=\"480\" height=\"320\"&gt;\n&lt;param name=\"color\" value=\"blue\"&gt;\n&lt;param name=\"squaresize\" value=\"30\"&gt;\n&lt;/applet&gt;\n&lt;hr&gt;\n&lt;/html&gt;\n</pre><p><strong>注意:&nbsp;</strong>参数名字大小写不敏感。</p><hr><h2>应用程序转换成Applet</h2><p>将图形化的Java应用程序（是指，使用AWT的应用程序和使用java程序启动器启动的程序）转换成嵌入在web页面里的applet是很简单的。</p><p>下面是将应用程序转换成applet的几个步骤：</p><ul><li>编写一个HTML页面，该页面带有能加载applet代码的标签。</li><li>编写一个JApplet类的子类，将该类设置为public。否则，applet不能被加载。</li><li>消除应用程序的main()方法。不要为应用程序构造框架窗口，因为你的应用程序要显示在浏览器中。</li><li>将应用程序中框架窗口的构造方法里的初始化代码移到applet的init()方法中，你不必显示的构造applet对象，浏览器将通过调用init()方法来实例化一个对象。</li><li>移除对setSize()方法的调用，对于applet来讲，大小已经通过HTML文件里的width和height参数设定好了。</li><li>移除对 setDefaultCloseOperation()方法的调用。Applet不能被关闭，它随着浏览器的退出而终止。</li><li>如果应用程序调用了setTitle()方法，消除对该方法的调用。applet不能有标题栏。（当然你可以给通过html的title标签给网页自身命名）</li><li>不要调用setVisible(true),applet是自动显示的。</li></ul><hr><h2>事件处理</h2><p>Applet类从Container类继承了许多事件处理方法。Container类定义了几个方法，例如：processKeyEvent()和processMouseEvent()，用来处理特别类型的事件，还有一个捕获所有事件的方法叫做processEvent。</p><p>为了响应一个事件，applet必须重写合适的事件处理方法。</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.awt.event.MouseListener;\nimport java.awt.event.MouseEvent;\nimport java.applet.Applet;\nimport java.awt.Graphics;\n \npublic class ExampleEventHandling extends Applet\n                             implements MouseListener {\n \n    StringBuffer strBuffer;\n \n    public void init() {\n         addMouseListener(this);\n         strBuffer = new StringBuffer();\n        addItem(\"initializing the apple \");\n    }\n \n    public void start() {\n        addItem(\"starting the applet \");\n    }\n \n    public void stop() {\n        addItem(\"stopping the applet \");\n    }\n \n    public void destroy() {\n        addItem(\"unloading the applet\");\n    }\n \n    void addItem(String word) {\n        System.out.println(word);\n        strBuffer.append(word);\n        repaint();\n    }\n \n    public void paint(Graphics g) {\n         //Draw a Rectangle around the applet\'s display area.\n        g.drawRect(0, 0,\n                      getWidth() - 1,\n                      getHeight() - 1);\n \n         //display the string inside the rectangle.\n        g.drawString(strBuffer.toString(), 10, 20);\n    }\n \n  \n    public void mouseEntered(MouseEvent event) {\n    }\n    public void mouseExited(MouseEvent event) {\n    }\n    public void mousePressed(MouseEvent event) {\n    }\n    public void mouseReleased(MouseEvent event) {\n    }\n \n    public void mouseClicked(MouseEvent event) {\n         addItem(\"mouse clicked! \");\n    }\n}\n</pre><p>如下调用该applet：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;html&gt;\n&lt;title&gt;Event Handling&lt;/title&gt;\n&lt;hr&gt;\n&lt;applet code=\"ExampleEventHandling.class\" width=\"300\" height=\"300\"&gt;\n&lt;/applet&gt;\n&lt;hr&gt;\n&lt;/html&gt;\n</pre><p>最开始运行，applet显示 \"initializing the applet. Starting the applet.\"，然后你一点击矩形框，就会显示\"mouse clicked\" 。</p><hr><h2>显示图片</h2><p>applet能显示GIF,JPEG,BMP等其他格式的图片。为了在applet中显示图片，你需要使用java.awt.Graphics类的drawImage()方法。</p><p>如下实例演示了显示图片的所有步骤：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.applet.*;\nimport java.awt.*;\nimport java.net.*;\npublic class ImageDemo extends Applet\n{\n  private Image image;\n  private AppletContext context;\n  public void init()\n  {\n      context = this.getAppletContext();\n      String imageURL = this.getParameter(\"image\");\n      if(imageURL == null)\n      {\n         imageURL = \"java.jpg\";\n      }\n      try\n      {\n         URL url = new URL(this.getDocumentBase(), imageURL);\n         image = context.getImage(url);\n      }catch(MalformedURLException e)\n      {\n         e.printStackTrace();\n         // Display in browser status bar\n         context.showStatus(\"Could not load image!\");\n      }\n   }\n   public void paint(Graphics g)\n   {\n      context.showStatus(\"Displaying image\");\n      g.drawImage(image, 0, 0, 200, 84, null);\n      g.drawString(\"www.javalicense.com\", 35, 100);\n   } \n}\n</pre><p>如下调用该applet：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;html&gt;\n&lt;title&gt;The ImageDemo applet&lt;/title&gt;\n&lt;hr&gt;\n&lt;applet code=\"ImageDemo.class\" width=\"300\" height=\"200\"&gt;\n&lt;param name=\"image\" value=\"java.jpg\"&gt;\n&lt;/applet&gt;\n&lt;hr&gt;\n&lt;/html&gt;\n</pre><hr><h2>播放音频</h2><p>Applet能通过使用java.applet包中的AudioClip接口播放音频。AudioClip接口定义了三个方法：</p><ul><li><strong>public void play():</strong>&nbsp;从一开始播放音频片段一次。</li><li><strong>public void loop():&nbsp;</strong>循环播放音频片段</li><li><strong>public void stop():&nbsp;</strong>停止播放音频片段</li></ul><p>为了得到AudioClip对象，你必须调用Applet类的getAudioClip()方法。无论URL指向的是否是一个真实的音频文件，该方法都会立即返回结果。</p><p>直到要播放音频文件时，该文件才会下载下来。</p><p>如下实例演示了播放音频的所有步骤：</p><pre class=\"ql-syntax\" spellcheck=\"false\">import java.applet.*;\nimport java.awt.*;\nimport java.net.*;\npublic class AudioDemo extends Applet\n{\n   private AudioClip clip;\n   private AppletContext context;\n   public void init()\n   {\n      context = this.getAppletContext();\n      String audioURL = this.getParameter(\"audio\");\n      if(audioURL == null)\n      {\n         audioURL = \"default.au\";\n      }\n      try\n      {\n         URL url = new URL(this.getDocumentBase(), audioURL);\n         clip = context.getAudioClip(url);\n      }catch(MalformedURLException e)\n      {\n         e.printStackTrace();\n         context.showStatus(\"Could not load audio file!\");\n      }\n   }\n   public void start()\n   {\n      if(clip != null)\n      {\n         clip.loop();\n      }\n   }\n   public void stop()\n   {\n      if(clip != null)\n      {\n         clip.stop();\n      }\n   }\n}\n</pre><p>如下调用applet：</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;html&gt;\n&lt;title&gt;The ImageDemo applet&lt;/title&gt;\n&lt;hr&gt;\n&lt;applet code=\"ImageDemo.class\" width=\"0\" height=\"0\"&gt;\n&lt;param name=\"audio\" value=\"test.wav\"&gt;\n&lt;/applet&gt;\n&lt;hr&gt;\n</pre><p>你可以使用你电脑上的test.wav来测试上面的实例。</p><p><br></p>');
INSERT INTO `knowledge` VALUES (31, 2, 'Java 多线程编程', 1007, 'teacher', '2022-12-09 08:21:04', '<h2><strong>Java多线程编程</strong></h2><p><br></p><p>Java 给多线程编程提供了内置的支持。一个多线程程序包含两个或多个能并发运行的部分。程序的每一部分都称作一个线程，并且每个线程定义了一个独立的执行路径。</p><p>多线程是多任务的一种特别的形式。多线程比多任务需要更小的开销。</p><p>这里定义和线程相关的另一个术语：进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。</p><p>多线程能满足程序员编写非常有效率的程序来达到充分利用 CPU 的目的，因为 CPU 的空闲时间能够保持在最低限度。</p><hr><h2>一个线程的生命周期</h2><p>线程经过其生命周期的各个阶段。下图显示了一个线程完整的生命周期。</p><p><img src=\"https://atts.w3cschool.cn/attachments/image/20160826/1472183462568697.jpg\" alt=\"线程\">&nbsp;</p><ul><li><strong>新建（new Thread）</strong></li><li>当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。</li><li>例如：Thread&nbsp;t1=new Thread();</li><li><strong>就绪（runnable）</strong></li><li>线程已经被启动，正在等待被分配给 CPU 时间片，也就是说此时线程正在就绪队列中排队等候得到 CPU 资源。</li><li>例如：t1.start();</li><li><strong>运行（running）</strong></li><li>线程获得 CPU 资源正在执行任务（ run() 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</li><li><strong>堵塞（blocked）</strong>由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。</li><li>正在睡眠：用 sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。</li><li>正在等待：调用 wait() 方法。（调用 motify() 方法回到就绪状态）</li><li>被另一个线程所阻塞：调用 suspend() 方法。（调用 resume() 方法恢复）</li><li><strong>死亡（dead）</strong>当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</li><li>自然终止：正常运行 run() 方法后终止</li><li>异常终止：调用 stop() 方法让一个线程终止运行</li></ul><hr><h2>线程的优先级</h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 优先级在 MIN_PRIORITY（1）和 MAX_PRIORITY（10）之间的范围内。默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器时间。然而，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><hr><h2>创建一个线程</h2><p>Java 提供了三种创建线程方法：</p><ul><li>通过实现 Runnable 接口；</li><li>通过继承 Thread 类本身；</li><li>通过 Callable 和 Future 创建线程。</li></ul><hr><h2>通过实现 Runnable 接口来创建线程</h2><p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p><p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">public void&nbsp;run()\n</pre><p>你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。</p><p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。</p><p>Thread定义了几个构造方法，下面的这个是我们经常使用的：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Thread(Runnable&nbsp;threadOb,String&nbsp;threadName);\n</pre><p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p><p>新线程创建之后，你调用它的start()方法它才会运行。</p><pre class=\"ql-syntax\" spellcheck=\"false\">void&nbsp;start();\n</pre><h3>实例</h3><p>下面是一个创建线程并开始让它执行的实例：</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;创建一个新的线程\nclass&nbsp;NewThread&nbsp;implements&nbsp;Runnable&nbsp;{\n&nbsp;&nbsp;&nbsp;Thread&nbsp;t;\n&nbsp;&nbsp;&nbsp;NewThread()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建第二个新线程\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;new&nbsp;Thread(this,&nbsp;\"Demo&nbsp;Thread\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Child&nbsp;thread:&nbsp;\"&nbsp;+&nbsp;t);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.start();&nbsp;//&nbsp;开始线程\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;//&nbsp;第二个线程入口\n&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;5;&nbsp;i&nbsp;&gt;&nbsp;0;&nbsp;i--)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Child&nbsp;Thread:&nbsp;\"&nbsp;+&nbsp;i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;暂停线程\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(50);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Child&nbsp;interrupted.\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Exiting&nbsp;child&nbsp;thread.\");\n&nbsp;&nbsp;&nbsp;}\n}\n&nbsp;\npublic&nbsp;class&nbsp;ThreadDemo&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;NewThread();&nbsp;//&nbsp;创建一个新线程\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;5;&nbsp;i&nbsp;&gt;&nbsp;0;&nbsp;i--)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Main&nbsp;Thread:&nbsp;\"&nbsp;+&nbsp;i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(100);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Main&nbsp;thread&nbsp;interrupted.\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Main&nbsp;thread&nbsp;exiting.\");\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>编译以上程序运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Child&nbsp;thread:&nbsp;Thread[Demo&nbsp;Thread,5,main]\nMain&nbsp;Thread:&nbsp;5\nChild&nbsp;Thread:&nbsp;5\nChild&nbsp;Thread:&nbsp;4\nMain&nbsp;Thread:&nbsp;4\nChild&nbsp;Thread:&nbsp;3\nChild&nbsp;Thread:&nbsp;2\nMain&nbsp;Thread:&nbsp;3\nChild&nbsp;Thread:&nbsp;1\nExiting&nbsp;child&nbsp;thread.\nMain&nbsp;Thread:&nbsp;2\nMain&nbsp;Thread:&nbsp;1\nMain&nbsp;thread&nbsp;exiting.\n</pre><hr><h2>通过继承 Thread 来创建线程</h2><p>创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p><p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p><p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p><h3>实例</h3><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;通过继承&nbsp;Thread&nbsp;创建线程\nclass&nbsp;NewThread&nbsp;extends&nbsp;Thread&nbsp;{\n&nbsp;&nbsp;&nbsp;NewThread()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建第二个新线程\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(\"Demo&nbsp;Thread\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Child&nbsp;thread:&nbsp;\"&nbsp;+&nbsp;this);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start();&nbsp;//&nbsp;开始线程\n&nbsp;&nbsp;&nbsp;}\n&nbsp;\n&nbsp;&nbsp;&nbsp;//&nbsp;第二个线程入口\n&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;5;&nbsp;i&nbsp;&gt;&nbsp;0;&nbsp;i--)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Child&nbsp;Thread:&nbsp;\"&nbsp;+&nbsp;i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;让线程休眠一会\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(50);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Child&nbsp;interrupted.\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Exiting&nbsp;child&nbsp;thread.\");\n&nbsp;&nbsp;&nbsp;}\n}\n&nbsp;\npublic&nbsp;class&nbsp;ExtendThread&nbsp;{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;NewThread();&nbsp;//&nbsp;创建一个新线程\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;5;&nbsp;i&nbsp;&gt;&nbsp;0;&nbsp;i--)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Main&nbsp;Thread:&nbsp;\"&nbsp;+&nbsp;i);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(100);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Main&nbsp;thread&nbsp;interrupted.\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Main&nbsp;thread&nbsp;exiting.\");\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>编译以上程序运行结果如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\">Child&nbsp;thread:&nbsp;Thread[Demo&nbsp;Thread,5,main]\nMain&nbsp;Thread:&nbsp;5\nChild&nbsp;Thread:&nbsp;5\nChild&nbsp;Thread:&nbsp;4\nMain&nbsp;Thread:&nbsp;4\nChild&nbsp;Thread:&nbsp;3\nChild&nbsp;Thread:&nbsp;2\nMain&nbsp;Thread:&nbsp;3\nChild&nbsp;Thread:&nbsp;1\nExiting&nbsp;child&nbsp;thread.\nMain&nbsp;Thread:&nbsp;2\nMain&nbsp;Thread:&nbsp;1\nMain&nbsp;thread&nbsp;exiting.\n</pre><hr><h2>Thread 方法</h2><p>下表列出了Thread类的一些重要方法：</p><p><strong>序号方法描述</strong>1<strong>public void start()</strong></p><p>使该线程开始执行；<strong style=\"background-color: rgb(255, 255, 102);\">Java</strong>&nbsp;虚拟机调用该线程的&nbsp;run&nbsp;方法。2<strong>public void run()</strong></p><p>如果该线程是使用独立的&nbsp;Runnable&nbsp;运行对象构造的，则调用该&nbsp;Runnable&nbsp;对象的&nbsp;run&nbsp;方法；否则，该方法不执行任何操作并返回。3<strong>public final void setName(String name)</strong></p><p>改变线程名称，使之与参数&nbsp;name&nbsp;相同。4<strong>public final void setPriority(int priority)</strong></p><p>&nbsp;更改线程的优先级。5<strong>public final void setDaemon(boolean on)</strong></p><p>将该线程标记为守护线程或用户线程。6<strong>public final void join(long millisec)</strong></p><p>等待该线程终止的时间最长为&nbsp;millis&nbsp;毫秒。7<strong>public void interrupt()</strong></p><p>中断线程。8<strong>public final boolean isAlive()</strong></p><p>测试线程是否处于活动状态。</p><p>测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。</p><p><strong>序号方法描述</strong>1<strong>public static void yield()</strong></p><p>暂停当前正在执行的线程对象，并执行其他线程。2<strong>public static void sleep(long millisec)</strong></p><p>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。3<strong>public static boolean holdsLock(Object x)</strong></p><p>当且仅当当前线程在指定的对象上保持监视器锁时，才返回&nbsp;true。4<strong>public static Thread currentThread()</strong></p><p>返回对当前正在执行的线程对象的引用。5<strong>public static void dumpStack()</strong></p><p>将当前线程的堆栈跟踪打印至标准错误流。</p><h3>实例</h3><p>如下的ThreadClassDemo 程序演示了Thread类的一些方法：</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;文件名&nbsp;:&nbsp;DisplayMessage.java\n//&nbsp;通过实现&nbsp;Runnable&nbsp;接口创建线程\npublic&nbsp;class&nbsp;DisplayMessage&nbsp;implements&nbsp;Runnable\n{\n&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;message;\n&nbsp;&nbsp;&nbsp;public&nbsp;DisplayMessage(String&nbsp;message)\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.message&nbsp;=&nbsp;message;\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(message);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>GuessANumber.java 文件代码：</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;文件名&nbsp;:&nbsp;GuessANumber.java\n//&nbsp;通过继承&nbsp;Thread&nbsp;类创建线程\n\npublic&nbsp;class&nbsp;GuessANumber&nbsp;extends&nbsp;Thread\n{\n&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;number;\n&nbsp;&nbsp;&nbsp;public&nbsp;GuessANumber(int&nbsp;number)\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.number&nbsp;=&nbsp;number;\n&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;counter&nbsp;=&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;guess&nbsp;=&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guess&nbsp;=&nbsp;(int)&nbsp;(Math.random()&nbsp;*&nbsp;100&nbsp;+&nbsp;1);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(this.getName()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;\"&nbsp;guesses&nbsp;\"&nbsp;+&nbsp;guess);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter++;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}while(guess&nbsp;!=&nbsp;number);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"**&nbsp;Correct!&nbsp;\"&nbsp;+&nbsp;this.getName()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;\"&nbsp;in&nbsp;\"&nbsp;+&nbsp;counter&nbsp;+&nbsp;\"&nbsp;guesses.**\");\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>ThreadClassDemo.java 文件代码：</p><pre class=\"ql-syntax\" spellcheck=\"false\">//&nbsp;文件名&nbsp;:&nbsp;ThreadClassDemo.java\npublic&nbsp;class&nbsp;ThreadClassDemo\n{\n&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;[]&nbsp;args)\n&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;hello&nbsp;=&nbsp;new&nbsp;DisplayMessage(\"Hello\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;thread1&nbsp;=&nbsp;new&nbsp;Thread(hello);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.setDaemon(true);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.setName(\"hello\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Starting&nbsp;hello&nbsp;thread...\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread1.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable&nbsp;bye&nbsp;=&nbsp;new&nbsp;DisplayMessage(\"Goodbye\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;thread2&nbsp;=&nbsp;new&nbsp;Thread(bye);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread2.setPriority(Thread.MIN_PRIORITY);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread2.setDaemon(true);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Starting&nbsp;goodbye&nbsp;thread...\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread2.start();\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Starting&nbsp;thread3...\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;thread3&nbsp;=&nbsp;new&nbsp;GuessANumber(27);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread3.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread3.join();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(InterruptedException&nbsp;e)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Thread&nbsp;interrupted.\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Starting&nbsp;thread4...\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;thread4&nbsp;=&nbsp;new&nbsp;GuessANumber(75);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread4.start();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"main()&nbsp;is&nbsp;ending...\");\n&nbsp;&nbsp;&nbsp;}\n}\n</pre><p>运行结果如下，每一次运行的结果都不一样。</p><pre class=\"ql-syntax\" spellcheck=\"false\">Starting&nbsp;hello&nbsp;thread...\nStarting&nbsp;goodbye&nbsp;thread...\nHello\nHello\nHello\nHello\nHello\nHello\nHello\nHello\nHello\nStarting thread3...\nHello\nHello\nStarting&nbsp;thread4...\nHello\nHello\nmain() is ending...\n</pre><hr><h2>通过 Callable 和 Future 创建线程</h2><ul><li>1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li><li>2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li><li>3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li></ul><p><strong>实例</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">public class CallableThreadTest implements Callable&lt;Integer&gt; {\n    public static void main(String[] args)  \n    {  \n        CallableThreadTest ctt = new CallableThreadTest();  \n        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt);  \n        for(int i = 0;i &lt; 100;i++)  \n        {  \n            System.out.println(Thread.currentThread().getName()+\" 的循环变量i的值\"+i);  \n            if(i==20)  \n            {  \n                new Thread(ft,\"有返回值的线程\").start();  \n            }  \n        }  \n        try  \n        {  \n            System.out.println(\"子线程的返回值：\"+ft.get());  \n        } catch (InterruptedException e)  \n        {  \n            e.printStackTrace();  \n        } catch (ExecutionException e)  \n        {  \n            e.printStackTrace();  \n        }  \n  \n    }\n    @Override  \n    public Integer call() throws Exception  \n    {  \n        int i = 0;  \n        for(;i&lt;100;i++)  \n        {  \n            System.out.println(Thread.currentThread().getName()+\" \"+i);  \n        }  \n        return i;  \n    }  \n}\n</pre><hr><h2>创建线程的三种方式的对比</h2><ul><li>1. 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li><li>2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li></ul><h2>线程的几个主要概念</h2><p>在多线程编程时，你需要了解以下几个概念：</p><ul><li>线程同步</li><li>线程间通信</li><li>线程死锁</li><li>线程控制：挂起、停止和恢复</li></ul><hr><h2>多线程的使用</h2><p>有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。</p><p>通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。</p><p>请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！</p><p><br></p>');
INSERT INTO `knowledge` VALUES (32, 2, 'Java 集合框架', 1008, 'teacher', '2022-12-09 08:21:22', '<h2><strong>Java集合框架</strong></h2><p><br></p><p>早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。</p><p>虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。</p><p>集合框架被设计成要满足以下几个目标。</p><ul><li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li><li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li><li>对一个集合的扩展和适应必须是简单的。</li></ul><p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。</p><p><img src=\"https://atts.w3cschool.cn/attachments/image/20200818/1597742443418592.gif\"></p><p>简化图：</p><p><img src=\"https://atts.w3cschool.cn/attachments/image/20200819/1597829834857738.jpg\" alt=\"1\"></p><p>说明：对于以上的框架图有如下几点说明</p><ol><li>所有集合类都位于 java.util 包下。Java的集合类主要由两个接口派生而出：Collection 和 Map，Collection 和 Map 是 Java 集合框架的根接口，这两个接口又包含了一些子接口或实现类。</li><li>集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。</li><li>抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。</li><li>实现类：8个实现类（实线表示），对接口的具体实现。</li><li>Collection 接口是一组允许重复的对象。</li><li>Set 接口继承 Collection，集合元素不重复。</li><li>List 接口继承 Collection，允许重复，维护元素插入顺序。</li><li>Map接口是键－值对象，与Collection接口没有什么关系。</li><li>Set、List 和 Map 可以看做集合的三大类：</li><li>List 集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</li><li>Set 集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。</li><li>Map 集合中保存 Key-value 对形式的元素，访问时只能根据每项元素的 key 来访问其 value。</li></ol><h4>集合框架图如图所示：</h4><p><img src=\"https://atts.w3cschool.cn/attachments/image/20200818/1597742516955681.png\"></p><p>Java 集合框架提供了一套性能优良，使用方便的接口和类，java 集合框架位于 java.util 包中， 所以当使用集合框架的时候需要进行导包。</p><hr><h2>集合接口</h2><p>集合框架定义了一些接口。本节提供了每个接口的概述：</p><p>序号接口描述1Collection 接口</p><p>允许你使用一组对象，是Collection层次结构的根接口。2List 接口</p><p>继承于<strong>Collection</strong>和一个 List实例存储一个有序集合的元素。3Set</p><p>继承于&nbsp;<strong>Collection，是</strong>一个不包含重复元素的集合。4SortedSet</p><p>继承于Set保存有序的集合。5Map</p><p>将唯一的键映射到值。6Map.Entry</p><p>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。7SortedMap</p><p>继承于Map，使Key保持在升序排列。8Enumeration</p><p>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</p><h2>集合类</h2><p>Java 提供了一套实现了 Collection 接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。\n标准集合类汇总于下表：\n序号类描述1<strong>AbstractCollection&nbsp;</strong></p><p>实现了大部分的集合接口。2<strong>AbstractList&nbsp;</strong></p><p>继承于 AbstractCollection 并且实现了大部分List接口。3<strong>AbstractSequentialList&nbsp;</strong></p><p>继承于&nbsp;AbstractList ，提供了对数据元素的链式访问而不是随机访问。4LinkedList</p><p>继承于&nbsp;AbstractSequentialList，实现了一个链表。5ArrayList</p><p>通过继承 AbstractList，实现动态数组。6<strong>AbstractSet&nbsp;</strong></p><p>继承于 AbstractCollection 并且实现了大部分Set接口。7HashSet</p><p>继承了 AbstractSet，并且使用一个哈希表。8LinkedHashSet</p><p>具有可预知迭代顺序的&nbsp;Set&nbsp;接口的哈希表和链接列表实现。9TreeSet</p><p>继承于AbstractSet，使用元素的自然顺序对元素进行排序.10<strong>AbstractMap&nbsp;</strong></p><p>实现了大部分的 Map 接口。11HashMap</p><p>继承了 HashMap，并且使用一个哈希表。12TreeMap</p><p>继承了 AbstractMap，并且使用一颗树。13WeakHashMap</p><p>继承 AbstractMap类，使用弱密钥的哈希表。14LinkedHashMap</p><p>继承于 HashMap，使用元素的自然顺序对元素进行排序.15IdentityHashMap</p><p>继承 AbstractMap 类，比较文档时使用引用相等。</p><p>在前面的教程中已经讨论通过 java.util 包中定义的类，如下所示：</p><p>序号类描述1Vector</p><p>Vector 类实现了一个动态数组。和 ArrayList 和相似，但是两者是不同的。2Stack</p><p>栈是 Vector 的一个子类，它实现了一个标准的后进先出的栈。3Dictionary</p><p>Dictionary 类是一个抽象类，用来存储键/值对，作用和 Map 类相似。4Hashtable</p><p>Hashtable 是原始的 java.util 的一部分，&nbsp;是一个 Dictionary 具体的实现&nbsp;。5Properties</p><p>Properties 继承于 Hashtable.表示一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。6BitSet</p><p>一个 Bitset 类创建一种特殊类型的数组来保存位值。BitSet 中数组大小会随需要增加。</p><p>一个 Bitset 类创建一种特殊类型的数组来保存位值。BitSet 中数组大小会随需要增加。</p><hr><h2>集合算法</h2><p>集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法。</p><p>在尝试比较不兼容的类型时，一些方法能够抛出 ​<code>ClassCastException</code>​异常。当试图修改一个不可修改的集合时，抛出​<code>UnsupportedOperationException</code>​异常。</p><p>集合定义三个静态的变量：EMPTY_SET EMPTY_LIST，EMPTY_MAP 的。这些变量都不可改变。</p><p>序号算法描述1Collection Algorithms</p><p>这里是一个列表中的所有算法实现。</p><h2>如何使用迭代器</h2><p>通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。</p><p>做到这一点最简单的方法是采用一个迭代器，它是一个对象，实现了 Iterator 接口或 ListIterator 接口。</p><p>迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了 Iterator，以允许双向遍历列表和修改元素。</p><p>这里通过实例列出 Iterator 和 listIterator 接口提供的所有方法。</p><hr><p><br></p><hr><p><br></p>');
INSERT INTO `knowledge` VALUES (33, 2, 'Java 数据结构', 1001, 'wwz', '2022-12-05 21:34:27', '<div class=\"content-intro view-box \"><h2>Java 数据结构</h2> <p>Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：</p> <ul> <li> 枚举（Enumeration）</li> <li> 位集合（BitSet）</li> <li> 向量（Vector）</li> <li> 栈（Stack）</li> <li> 字典（Dictionary）</li> <li> 哈希表（Hashtable）</li> <li> 属性（Properties）</li> </ul> <p>以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架(Collection)，我们后面再讨论。</p> <hr> <h2> 枚举（Enumeration）</h2> <p>枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。 </p><p>例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。 </p><p>关于枚举接口的更多信息，<a href=\"java-enumeration-interface.html\" target=\"_blank\">请参见枚举（Enumeration）</a>。</p> <hr> <h2> 位集合（BitSet）</h2> <p> 位集合类实现了一组可以单独设置和清除的位或标志。</p><p> 该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一\"位\"，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p><p> 关于该类的更多信息，<a href=\"java-bitset-class.html\" target=\"_blank\">请参见位集合（BitSet）</a>。</p> <hr> <h2> 向量（Vector）</h2> <p>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。</p><p> 和数组一样，Vector对象的元素也能通过索引访问。</p><p> 使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</p><p> 关于该类的更多信息，<a href=\"java-vector-class.html\" target=\"_blank\">请参见向量(Vector)</a></p> <hr> <h2> 栈（Stack）</h2> <p>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</p><p> 你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。</p><p> 当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</p><p> 关于该类的更多信息，<a href=\"java-stack-class.html\" target=\"_blank\">请参见栈（Stack）</a>。</p> <hr> <h2> 字典（Dictionary）</h2> <p>字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。</p><p> 当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。</p><p> 由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。</p><p> 关于该类的更多信息，<a href=\"java-dictionary-class.html\" target=\"_blank\">请参见字典（ Dictionary）</a>。</p> <hr> <h2> 哈希表（Hashtable）</h2> <p>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。</p><p> 例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人的名字。</p><p> 哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。</p><p> 关于该类的更多信息，<a href=\"java-hashTable-class.html\" target=\"_blank\">请参见哈希表（HashTable）</a>。</p> <hr> <h2> 属性（Properties）</h2> <p>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。</p><p> Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</p><p> 关于该类的更多信息，<a href=\"java-properties-class.html\" target=\"_blank\">请参见属性（Properties）</a>。</p></div>');
INSERT INTO `knowledge` VALUES (34, 2, 'Java 网络编程', 1010, 'teacher', '2022-12-09 08:21:58', '<h2><strong>Java网络编程</strong></h2><p><br></p><p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。</p><p>java.net包中J2SE的API包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p><p>java.net包中提供了两种常见的网络协议的支持：</p><ul><li><strong>TCP</strong>： TCP是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称TCP / IP。</li><li><strong>UDP</strong>:UDP是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。</li></ul><p>本教程主要讲解以下两个主题。</p><ul><li><strong>Socket 编程</strong>:&nbsp;这是使用最广泛的网络概念，它已被解释地非常详细</li><li><strong>URL 处理</strong>:&nbsp;这部分会在另外的篇幅里讲，点击这里更详细地了解在<a href=\"http://localhost:8080/java/java-url-processing.html\" rel=\"noopener noreferrer\" target=\"_blank\">Java语言中的URL处理</a>。</li></ul><hr><h2>Socket 编程</h2><p>套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。</p><p>当连接建立时，服务器会创建一个Socket对象。客户端和服务器现在可以通过对Socket对象的写入和读取来进行通信。</p><p>java.net.Socket类代表一个套接字，并且java.net.ServerSocket类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。</p><p>以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：</p><ul><li>服务器实例化一个ServerSocket对象，表示通过服务器上的端口通信。</li><li>服务器调用&nbsp;ServerSocket类&nbsp;的accept（）方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li><li>服务器正在等待时，一个客户端实例化一个Socket对象，指定服务器名称和端口号来请求连接。</li><li>Socket类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个Socket对象能够与服务器进行通信。</li><li>在服务器端，accept()方法返回服务器上一个新的socket引用，该socket连接到客户端的socket。</li></ul><p>连接建立后，通过使用I/O流在进行通信。每一个socket都有一个输出流和一个输入流。客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。</p><p>TCP是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现sockets。</p><hr><h2>ServerSocket 类的方法</h2><p>服务器应用程序通过使用java.net.ServerSocket类以获取一个端口,并且侦听客户端请求。</p><p>ServerSocket类有四个构造方法：</p><p><strong>序号方法描述</strong>1<strong>public ServerSocket(int port) throws IOException</strong></p><p>创建绑定到特定端口的服务器套接字。2<strong>public ServerSocket(int port, int backlog) throws IOException</strong></p><p>利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。3<strong>public ServerSocket(int port, int backlog, InetAddress address) throws IOException</strong></p><p>使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。4<strong>public ServerSocket() throws IOException</strong></p><p>创建非绑定服务器套接字。</p><p>创建非绑定服务器套接字。 如果ServerSocket构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。</p><p>这里有一些ServerSocket类的常用方法：</p><p><strong>序号方法描述</strong>1<strong>public int getLocalPort()</strong></p><p>&nbsp;&nbsp;返回此套接字在其上侦听的端口。2<strong>public Socket accept() throws IOException</strong></p><p>侦听并接受到此套接字的连接。3<strong>public void setSoTimeout(int timeout)</strong></p><p>&nbsp;通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。4<strong>public void bind(SocketAddress host, int backlog)</strong></p><p>将&nbsp;ServerSocket&nbsp;绑定到特定地址（IP 地址和端口号）。</p><h2>Socket 类的方法</h2><p>java.net.Socket类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个Socket对象通过实例化 ，而 服务器获得一个Socket对象则通过accept()方法的返回值。</p><p>Socket类有五个构造方法.</p><p><strong>序号方法描述</strong>1<strong>public Socket(String host, int port) throws UnknownHostException, IOException.</strong></p><p>创建一个流套接字并将其连接到指定主机上的指定端口号。2<strong>public Socket(InetAddress host, int port) throws IOException</strong></p><p>创建一个流套接字并将其连接到指定 IP 地址的指定端口号。3<strong>public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.</strong></p><p>创建一个套接字并将其连接到指定远程主机上的指定远程端口。4<strong>public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.</strong></p><p>创建一个套接字并将其连接到指定远程地址上的指定远程端口。5<strong>public Socket()</strong></p><p>通过系统默认类型的 SocketImpl 创建未连接套接字</p><p>当Socket构造方法返回，并没有简单的实例化了一个Socket对象，它实际上会尝试连接到指定的服务器和端口。</p><p>下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个Socket对象，所以无论客户端还是服务端都能够调用这些方法。</p><p><strong>序号方法描述</strong>1<strong>public void connect(SocketAddress host, int timeout) throws IOException</strong></p><p>将此套接字连接到服务器，并指定一个超时值。2<strong>public InetAddress getInetAddress()</strong></p><p>&nbsp;返回套接字连接的地址。3<strong>public int getPort()</strong></p><p>返回此套接字连接到的远程端口。4<strong>public int getLocalPort()</strong></p><p>返回此套接字绑定到的本地端口。5<strong>public SocketAddress getRemoteSocketAddress()</strong></p><p>返回此套接字连接的端点的地址，如果未连接则返回&nbsp;null。6<strong>public InputStream getInputStream() throws IOException</strong></p><p>返回此套接字的输入流。7<strong>public OutputStream getOutputStream() throws IOException</strong></p><p>返回此套接字的输出流。8<strong>public void close() throws IOException</strong></p><p>关闭此套接字。</p><h2>InetAddress 类的方法</h2><p>这个类表示互联网协议(IP)地址。下面列出了Socket编程时比较有用的方法：</p><p><strong>序号方法描述</strong>1<strong>static InetAddress getByAddress(byte[] addr)</strong></p><p>在给定原始 IP 地址的情况下，返回&nbsp;InetAddress&nbsp;对象。2<strong>static InetAddress getByAddress(String host, byte[] addr)</strong></p><p>根据提供的主机名和 IP 地址创建 InetAddress。3<strong>static InetAddress getByName(String host)</strong></p><p>在给定主机名的情况下确定主机的 IP 地址。4<strong>String getHostAddress()&nbsp;</strong></p><p>返回 IP 地址字符串（以文本表现形式）。5<strong>String getHostName()&nbsp;</strong></p><p>&nbsp;获取此 IP 地址的主机名。6<strong>static InetAddress getLocalHost()</strong></p><p>返回本地主机。7<strong>String toString()</strong></p><p>将此 IP 地址转换为&nbsp;String。</p><h2>Socket 客户端实例</h2><p>如下的GreetingClient 是一个客户端程序，该程序通过socket连接到服务器并发送一个请求，然后等待一个响应。</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 文件名 GreetingClient.java\n\nimport java.net.*;\nimport java.io.*;\n \npublic class GreetingClient\n{\n   public static void main(String [] args)\n   {\n      String serverName = args[0];\n      int port = Integer.parseInt(args[1]);\n      try\n      {\n         System.out.println(\"Connecting to \" + serverName\n                             + \" on port \" + port);\n         Socket client = new Socket(serverName, port);\n         System.out.println(\"Just connected to \"\n                      + client.getRemoteSocketAddress());\n         OutputStream outToServer = client.getOutputStream();\n         DataOutputStream out =\n                       new DataOutputStream(outToServer);\n \n         out.writeUTF(\"Hello from \"\n                      + client.getLocalSocketAddress());\n         InputStream inFromServer = client.getInputStream();\n         DataInputStream in =\n                        new DataInputStream(inFromServer);\n         System.out.println(\"Server says \" + in.readUTF());\n         client.close();\n      }catch(IOException e)\n      {\n         e.printStackTrace();\n      }\n   }\n}\n</pre><hr><h2>Socket 服务端实例</h2><p>如下的GreetingServer 程序是一个服务器端应用程序，使用Socket来监听一个指定的端口。</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 文件名 GreetingServer.java\n\nimport java.net.*;\nimport java.io.*;\n\npublic class GreetingServer extends Thread\n{\n   private ServerSocket serverSocket;\n   \n   public GreetingServer(int port) throws IOException\n   {\n      serverSocket = new ServerSocket(port);\n      serverSocket.setSoTimeout(10000);\n   }\n\n   public void run()\n   {\n      while(true)\n      {\n         try\n         {\n            System.out.println(\"Waiting for client on port \" +\n            serverSocket.getLocalPort() + \"...\");\n            Socket server = serverSocket.accept();\n            System.out.println(\"Just connected to \"\n                  + server.getRemoteSocketAddress());\n            DataInputStream in =\n                  new DataInputStream(server.getInputStream());\n            System.out.println(in.readUTF());\n            DataOutputStream out =\n                 new DataOutputStream(server.getOutputStream());\n            out.writeUTF(\"Thank you for connecting to \"\n              + server.getLocalSocketAddress() + \"\\nGoodbye!\");\n            server.close();\n         }catch(SocketTimeoutException s)\n         {\n            System.out.println(\"Socket timed out!\");\n            break;\n         }catch(IOException e)\n         {\n            e.printStackTrace();\n            break;\n         }\n      }\n   }\n   public static void main(String [] args)\n   {\n      int port = Integer.parseInt(args[0]);\n      try\n      {\n         Thread t = new GreetingServer(port);\n         t.start();\n      }catch(IOException e)\n      {\n         e.printStackTrace();\n      }\n   }\n}\n</pre><p>编译以上 java 代码，并执行以下命令来启动服务，使用端口号为 6066：</p><pre class=\"ql-syntax\" spellcheck=\"false\">$ java GreetingServer 6066\nWaiting for client on port 6066...\n</pre><p>像下面一样开启客户端：</p><pre class=\"ql-syntax\" spellcheck=\"false\">$ java GreetingClient localhost 6066\nConnecting to localhost on port 6066\nJust connected to localhost/127.0.0.1:6066\nServer says Thank you for connecting to /127.0.0.1:6066\nGoodbye!\n</pre><p><br></p><hr><p><br></p><hr><p><br></p><hr><p><br></p>');
INSERT INTO `knowledge` VALUES (35, 2, 'Java GUI', 1005, 'teacher', '2022-12-10 07:19:36', '<h2>Java GUI——Java图形用户界面</h2><p><br></p><p>1、Java GUI概述</p><p>1.1、GUI的前世今生</p><p>&nbsp;&nbsp;早期，电脑向用户提供的是单调、枯燥、纯字符状态的“命令行界面（CLI）”。如：Windows中的DOS窗口。后来，Apple公司率先在电脑的操作系统中实现了图形化的用户界面（Graphical User Interface，简称GUI），但由于Apple公司封闭的市场策略，与其它PC不兼容。这使得Apple公司错过了一次一统全球PC的好机会。后来，Microsoft公司推出了风靡全球的Windows操作系统，它凭借着优秀的图形化用户界面，一举奠定了操作系统标准的地位。</p><p><br></p><p>&nbsp;&nbsp;在这图形用户界面风行于世的今天，一个应用软件没有良好的GUI是无法让用户接受的。而Java语言也深知这一点的重要性，它提供了一套可以轻松构建GUI的工具。</p><p><br></p><p>&nbsp;&nbsp;AWT,Java最早的界面库。（java.awt：Abstract Windows ToolKit（抽象窗口工具包），需要调用本地系统方法来实现功能，属重量级控件。）</p><p><br></p><p>&nbsp;&nbsp;Swing,是对AWT的扩展。（javax.swing：在AWT的基础上， 建立的一套图像界面系统，其中提供了更多的组件，而且完全由Java实现。增强了移植性，属轻量级组件。）</p><p><br></p><p>&nbsp;&nbsp;JavaFX,JDK1.8引入的新的界面库。</p><p><br></p><p>&nbsp;&nbsp;SWT，Eclipse使用的界面库。它吸收了AWT和Swing实现的最好的部分，SWT于2001年与Eclipse IDE(Integrated Development Environment)一起集成发布。在这个最初发布版之后，SWT发展和演化为一个独立的版本。 JFace的构建基于SWT，它提供了SWT的功能和更简易的MVC模式。SWT和JFace不仅使Java成为一个构建桌面应用程序的可行的选择，也使之成为一个具有优势的开发平台。&nbsp;&nbsp;&nbsp;</p><p><br></p><p>声明：原创文章未经允许，不得转载！</p><p><br></p><p>2、AWT</p><p>2.1、AWT概述</p><p>&nbsp;&nbsp;抽象窗口工具包AWT（Abstract Window Toolkit）是java提供的建立图形用户界面GUI的开发包，AWT可用于Java的Applet 和 Application 中。java.awt包提供了基本的GUI设计工具，主要包括组件（Component）、容器（Container）和布局管理器（LayoutManager）三个概念。</p><p>&nbsp;java的图形用户界面的最基本组成部分是组件，组件是一个可以以图形化的方式显示在屏幕上并能与用户进行交互的对象，例如一个按钮、一个标签等。组件不能独立的显示出来，必须将组件放在一定的容器中才可以显示出来。&nbsp;</p><p><br></p><p>2.2、容器（Container）</p><p>&nbsp;&nbsp;容器是Component的子类，一个容器可以容纳多个组件，并使他们成为一个整体。容器可以简化图形化界面的设计，以整体结构来布置界面，所有的组件都可以通过add()方法加入容器中。</p><p><br></p><p>&nbsp;&nbsp;有三种类型的容器：Window、Panel、ScrollPane</p><p><br></p><p>&nbsp;&nbsp;Window类：是不依赖其他容器而独立存在的容器他有两个子类分别是Frame类和Dialog类。Frame类用于创建一个具有标题栏的框架窗口作为程序的主要界面，Dialog类用于创建一个对话框，实现与用户的信息交换。</p><p><br></p><p>&nbsp;&nbsp;Panel类：也是一个容器,但是他不能单独存在,只能存在于其他容器(window或其子类)中,一个panel对象代表了一个长方形的区域,在这个区域中可以容纳其他组件，在程序中通常会使panel来实现一些特殊的布局。</p><p><br></p><p>&nbsp;&nbsp;ScrollPane类：用于实现单个子组件的自动水平和/或垂直滚动的容器类。因此该类创建的对象也是一个容器，称为滚动面板。</p><p><br></p><p>&nbsp;&nbsp;常用的容器有：Panel、Frame、Applet</p>');
INSERT INTO `knowledge` VALUES (1001, 1, '第一章 Java 语言概述', 0, 'wwz', '2022-12-04 16:03:02', NULL);
INSERT INTO `knowledge` VALUES (1002, 1, '第二章 Java语言语法基础', 0, 'wwz', '2022-12-04 16:03:02', NULL);
INSERT INTO `knowledge` VALUES (1003, 1, '第三章 Java面向对象', 0, 'wwz', '2022-12-05 21:31:30', NULL);
INSERT INTO `knowledge` VALUES (1004, 1, '第四章 Java Applet', 0, NULL, NULL, NULL);
INSERT INTO `knowledge` VALUES (1005, 1, '第五章 图形用户界面设计', 0, NULL, NULL, NULL);
INSERT INTO `knowledge` VALUES (1006, 1, '第六章 异常和异常处理', 0, NULL, NULL, NULL);
INSERT INTO `knowledge` VALUES (1007, 1, '第七章 线程', 0, NULL, NULL, NULL);
INSERT INTO `knowledge` VALUES (1008, 1, '第八章 Java集合', 0, NULL, NULL, NULL);
INSERT INTO `knowledge` VALUES (1009, 1, '第九章 Java 输入输出', 0, NULL, NULL, NULL);
INSERT INTO `knowledge` VALUES (1010, 1, '第十章 Java网络编程', 0, NULL, NULL, NULL);

-- ----------------------------
-- Table structure for loginrecord
-- ----------------------------
DROP TABLE IF EXISTS `loginrecord`;
CREATE TABLE `loginrecord`  (
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `time` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `ip` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `name`(`username`) USING BTREE,
  CONSTRAINT `name` FOREIGN KEY (`username`) REFERENCES `sys_user` (`username`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 86 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of loginrecord
-- ----------------------------
INSERT INTO `loginrecord` VALUES ('张三', 69, '2022-11-29', '10.7.107.168');
INSERT INTO `loginrecord` VALUES ('张三', 70, '2022-11-29', '10.7.107.168');
INSERT INTO `loginrecord` VALUES ('张三', 71, '2022-11-29', '10.7.107.168');
INSERT INTO `loginrecord` VALUES ('张三', 72, '2022-11-29', '10.7.107.168');
INSERT INTO `loginrecord` VALUES ('system', 73, '2022-11-30', '10.7.107.168');
INSERT INTO `loginrecord` VALUES ('teacher', 74, '2022-11-30', '10.7.107.168');
INSERT INTO `loginrecord` VALUES ('system', 75, '2022-11-30', '10.7.107.168');
INSERT INTO `loginrecord` VALUES ('teacher', 76, '2022-11-30', '10.7.107.168');
INSERT INTO `loginrecord` VALUES ('张三', 77, '2022-11-30', '10.7.107.168');
INSERT INTO `loginrecord` VALUES ('system', 78, '2022-12-01', '192.168.1.114');
INSERT INTO `loginrecord` VALUES ('teacher', 79, '2022-12-01', '192.168.1.114');
INSERT INTO `loginrecord` VALUES ('张三', 80, '2022-12-01', '192.168.1.114');
INSERT INTO `loginrecord` VALUES ('teacher', 81, '2022-12-01', '192.168.1.114');
INSERT INTO `loginrecord` VALUES ('123', 82, '2022-12-01', '192.168.1.114');
INSERT INTO `loginrecord` VALUES ('123', 83, '2022-12-01', '192.168.1.114');
INSERT INTO `loginrecord` VALUES ('teacher', 84, '2022-12-01', '192.168.1.114');
INSERT INTO `loginrecord` VALUES ('test1', 85, '2022-12-01', '192.168.1.114');

-- ----------------------------
-- Table structure for menu
-- ----------------------------
DROP TABLE IF EXISTS `menu`;
CREATE TABLE `menu`  (
  `id` int(11) NOT NULL,
  `title` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '名称',
  `path` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '地址',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of menu
-- ----------------------------
INSERT INTO `menu` VALUES (100, '权限管理', '/admin');
INSERT INTO `menu` VALUES (200, '学习平台', '/use');

-- ----------------------------
-- Table structure for paper
-- ----------------------------
DROP TABLE IF EXISTS `paper`;
CREATE TABLE `paper`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `exam_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '考试名称',
  `user_name` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '学生名称',
  `correct_user` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '修改人',
  `type` int(11) NULL DEFAULT NULL COMMENT '类型 1：期末测试  2：章节测试',
  `knowledge_id` int(11) NULL DEFAULT NULL COMMENT '章节id，-1为期末考',
  `correct_status` int(11) NULL DEFAULT NULL COMMENT '批改标识 0：未批改    1：全部批改',
  `scores` int(11) NULL DEFAULT NULL COMMENT '学生得分',
  `full_score` int(11) NULL DEFAULT NULL COMMENT '总分',
  `right_rate` decimal(10, 0) NULL DEFAULT NULL COMMENT '准确率',
  `finish_time` datetime NULL DEFAULT NULL COMMENT '完成时间',
  `used_time` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '花费的时间',
  `comment` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '老师评语',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1054 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of paper
-- ----------------------------
INSERT INTO `paper` VALUES (1001, NULL, 'zhangsan', 'auto', NULL, 1, 1, NULL, NULL, 1, '2022-12-03 07:20:41', '13', NULL);
INSERT INTO `paper` VALUES (1002, NULL, 'zhangsan', 'auto', NULL, 0, 1, NULL, NULL, 2, '2022-12-03 07:49:06', '18', NULL);
INSERT INTO `paper` VALUES (1003, NULL, 'zhangsan', 'auto', NULL, 1, 1, NULL, NULL, 27, '2022-12-03 07:54:25', '8', NULL);
INSERT INTO `paper` VALUES (1004, NULL, 'zhangsan', 'auto', NULL, 1, 1, NULL, NULL, 25, '2022-12-03 07:56:08', '12', NULL);
INSERT INTO `paper` VALUES (1005, NULL, 'zhangsan', 'auto', NULL, 1, 1, NULL, NULL, 25, '2022-12-03 10:37:18', '10', NULL);
INSERT INTO `paper` VALUES (1006, NULL, 'zhangsan', 'auto', NULL, 1, 1, NULL, NULL, 0, '2022-12-04 01:10:49', '1091', NULL);
INSERT INTO `paper` VALUES (1007, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-04 01:20:07', '14', NULL);
INSERT INTO `paper` VALUES (1008, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-04 01:20:42', '20', NULL);
INSERT INTO `paper` VALUES (1009, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-04 02:55:34', '12', NULL);
INSERT INTO `paper` VALUES (1010, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-04 03:02:10', '7', NULL);
INSERT INTO `paper` VALUES (1011, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 3, '2022-12-04 03:08:36', '7', NULL);
INSERT INTO `paper` VALUES (1012, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-04 03:09:42', '12', NULL);
INSERT INTO `paper` VALUES (1013, NULL, 'zhangsan', 'auto', NULL, 1, 1, NULL, NULL, 0, '2022-12-05 08:33:39', '3', NULL);
INSERT INTO `paper` VALUES (1014, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-05 08:59:52', '5', NULL);
INSERT INTO `paper` VALUES (1015, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-05 10:11:40', '5', NULL);
INSERT INTO `paper` VALUES (1016, NULL, 'zhangsan', 'auto', NULL, 1, 1, NULL, NULL, 0, '2022-12-08 10:30:53', '3', NULL);
INSERT INTO `paper` VALUES (1042, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 3, '2022-12-10 01:23:04', '7', NULL);
INSERT INTO `paper` VALUES (1043, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 3, '2022-12-10 01:23:12', '14', NULL);
INSERT INTO `paper` VALUES (1044, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-10 01:47:52', '3', NULL);
INSERT INTO `paper` VALUES (1045, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-10 02:00:09', '3', NULL);
INSERT INTO `paper` VALUES (1046, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-10 02:16:46', '3', NULL);
INSERT INTO `paper` VALUES (1047, NULL, 'zhangsan', 'auto', NULL, -1, 1, NULL, NULL, 0, '2022-12-10 02:17:30', '4', NULL);
INSERT INTO `paper` VALUES (1048, '添加考试test', '张三', 'teacher', 2, 1002, 1, 0, 40, 0, '2022-12-10 02:49:21', '10', 'very good');
INSERT INTO `paper` VALUES (1049, '添加考试test', '123', 'teacher', 2, 1002, 0, NULL, 40, NULL, '2022-12-10 07:34:43', '9', NULL);
INSERT INTO `paper` VALUES (1050, '添加考试test', 'test1', 'teacher', 2, 1002, 0, NULL, 40, NULL, NULL, NULL, NULL);
INSERT INTO `paper` VALUES (1051, '2222', '张三', 'teacher', 1, NULL, 0, NULL, 20, NULL, '2022-12-10 05:17:14', '18', NULL);
INSERT INTO `paper` VALUES (1052, '2222', '123', 'teacher', 1, NULL, 0, NULL, 20, NULL, NULL, NULL, NULL);
INSERT INTO `paper` VALUES (1053, '2222', 'test1', 'teacher', 1, NULL, 0, NULL, 20, NULL, NULL, NULL, NULL);

-- ----------------------------
-- Table structure for question
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question`  (
  `q_no` int(11) NOT NULL AUTO_INCREMENT COMMENT '题目序号',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `point` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '知识点',
  `choice1` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '选项1',
  `choice2` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `choice3` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `choice4` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `topic` int(11) NULL DEFAULT NULL COMMENT '章节（共有10章java练习题）',
  `answer` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '答案',
  `detail` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '解析',
  `qtype` int(11) NULL DEFAULT NULL COMMENT '题型（1选择 3判断 5编程）',
  `pic` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `score` int(11) NULL DEFAULT NULL COMMENT '分值',
  PRIMARY KEY (`q_no`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 264 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of question
-- ----------------------------
INSERT INTO `question` VALUES (1, 'JAVA中以下哪个函数是用于输出内容到终端的？', '1', 'echo', 'output', 'print', 'console.log', 1001, 'A', 'pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。', 1, NULL, 10);
INSERT INTO `question` VALUES (2, '以下关于 JAVA的描述错误的是？', '1', '软件测试', 'Web开发', '跨平台', '爬虫', 1001, 'C', '在 if...elif...else 的多个语句块中只会执行一个语句块。', 1, NULL, 10);
INSERT INTO `question` VALUES (3, '以下哪个符号是用作JAVA 的注释？', '1', '*', '（comment）', '//', '#', 1001, 'B', '在 Python 中，else 除了能与 if 配合外，还能和 for、while 配对使用。', 1, NULL, 10);
INSERT INTO `question` VALUES (4, 'Java中，以下哪个赋值操作符是错误的？', '1', '+=', '-=', '*=', 'X=', 1001, 'D', '这个语句中表示当  char 等于 空字符的时候 会结束循环。', 1, NULL, 10);
INSERT INTO `question` VALUES (5, 'Java中，以下哪个代码是正确的字典？', '1', 'myExample [\'someltem\'=>2,\'otherltem\'=>20)', 'myExample [\'someltem\':2,\'otherltem\':20)', 'myExample =(\'someltem\'=>2,\'otherltem\'=>20)', 'myExample =(\'someltem\':2,\'otherltem\':20)', 1001, 'A', '所以正确的为 PYTHON。', 1, NULL, 10);
INSERT INTO `question` VALUES (8, '给定一个字符串 s ,请你找出其中不含有重复字符的最长子串的长度。', '1', NULL, NULL, NULL, NULL, 1001, 'demo/ans_imgs/1.jpg', NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (9, '给你一个字符串 s，找到 s 中最长的回文子串。', '1', NULL, NULL, NULL, NULL, 1001, 'demo/ans_imgs/2.jpg', NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (10, '给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\r\n\r\n算法的时间复杂度应该为 O(log (m+n)) 。', '1', NULL, NULL, NULL, NULL, 1001, 'demo/ans_imgs/3.jpg', NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (11, ' 合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。\r\n\r\n数据范围：节点总数 0≤n≤50000≤n≤5000，每个节点的val满足 ∣val∣<=1000∣val∣<=1000\r\n要求：时间复杂度 O(nlogn)O(nlogn) ', '2', NULL, NULL, NULL, NULL, 1001, 'demo/ans_imgs/4.jpg', NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (12, '在Java的方法中定义一个常量要用const关键字。', '2', NULL, NULL, NULL, NULL, 1001, 'F', '在java中定义常量用final。', 3, NULL, 10);
INSERT INTO `question` VALUES (13, '抽象方法必须在抽象类中，所以抽象类中的方法都必须是抽象方法。', '1', NULL, NULL, NULL, NULL, 1001, 'F', '抽象类中必须要有抽象方法，但是同时也可以有非抽象方法。', 3, NULL, 10);
INSERT INTO `question` VALUES (14, 'Java支持多重继承。', '1', NULL, NULL, NULL, NULL, 1001, 'F', '是单继承。一个类最多只能够有一个基类，用extends实现。', 3, NULL, 10);
INSERT INTO `question` VALUES (15, 'Java语言是编译解释型语言。', '2', NULL, NULL, NULL, NULL, 1001, 'T', 'Java语言是编译解释型语言。', 3, NULL, 10);
INSERT INTO `question` VALUES (16, 'upload/1.jpg', '2', '2', NULL, NULL, NULL, 1001, 'System.in,t=t/10', '暂无', 5, NULL, 10);
INSERT INTO `question` VALUES (17, 'upload/2.jpg', '1', '2', NULL, NULL, NULL, 1001, 'int add(int a,int b),new AddOver()', '暂无', 5, NULL, 10);
INSERT INTO `question` VALUES (18, '在下列概念中，Java语言只保留了', '2', ' 运算符重载	', ' 方法重载 	', ' 指针		', ' 结构和联合', 1001, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (19, '下列关于Java语言特性的描述中，错误的是', '1', ' 支持多线程操作		', ' Java程序与平台无关		', ' Java和程序可以直接访问Internet上的对象', ' 支持单继承和多继承', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (20, '下列关于Java Application程序在结构上的特点的中，错误的是', '1', ' Java程序是由一个或多个类组成的', '	 组成Java程序的若干类可以放在一个文件中，也可以放在多个文件中', '	 Java程序的文件名要与某个类名相同', '	 组成Java程序的多个 类中，有且仅有一个主类', 1001, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (21, 'Java程序经过编译后生成 的文件的后缀是', '1', ' .obj	', ' .exe	', ' .class	', ' .java', 1001, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (22, '下列关于运行字节码文件的命令行参数的描述中，正确的是', '1', ' 第一个命令行参数(紧跟命令字的参数)被存放在args[0]中', ' 第一个命令行参数被存放在args[1]中', ' 命令行的命令字被存放在args[0]中', '数组args[]的大小与命令行参数的个数无关', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (23, 'Java语言所用的字符集中字符是多少位？', '1', ' 8', ' 16', ' 32', ' 64', 1001, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (24, '下列关于标识符的描述中，正确的是', '1', ' 标识符中可以使用下划线和美元符', ' 标识符中可以使用连接符和井号符', ' 标识符中大小写字母是无区别的', ' 标识符可选用关键字', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (25, 'Java语言和各种分隔符中，非法的是', '1', ' 空白符', ' 分号', ' 逗号', ' 问号', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (26, '下列对封装性的描述中，错误的是', '2', '	封装体包含了属性和行为', '	封装体中的属性和行为的访问权限是相同的', '	被封装的某些信息在封装体外是不可见的', '	封装使得抽象的数据类型提高了可重用性', 1001, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (27, '下列关于继承性的描述中，错误的是', '2', '	一个类可以同时生成多个子类', '	子类继承了父类的所有成员', '	 Java语言支持单重继承和多重继承', '	 Java语言通过接口可使子类使用多个父类的成员', 1001, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (28, '下列对多态性的描述中，错误的是', '2', '	 Java语言允许运算符重载', '	 Java语言允许方法重载', '	 Java语言允许变量覆盖', '	多态性提高了程序的抽象性和简洁性', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (29, '在类的修饰符中，规定只能被同一包类所使用的修饰符是', '2', '	 public      ', '默认     ', ' final     ', ' abstract', 1001, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (30, '在成员变量的修饰符中，规定只允许该类自身访问的修饰符是', '2', '	 private      ', ' public     ', '默认    ', ' protected', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (31, '在成员方法的访问控制修饰符中，规定访问权限包含该类自身，同包的其他类和其他包的该类子类的修饰符是', '2', '	 public     ', ' private   ', '默认     ', ' protected', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (32, '下列关于构造方法的特点的描述中，错误的是', '2', '	不可重载    ', '方法名同类名   ', '无返回类型   ', '系统自动调用', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (33, '下列关于静态方法的特点的描述中，错误的是', '2', '	在类体内说明静态方法使用关键字 static', '	静态方法只能处理静态变量或调用静态方法', '	静态方法不占用对象的内存空间，非静态方法占用对象的内存空间', '	静态方法只能用类名调用', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (34, '下列对静态初始化器的描述中，错误的是', '2', '	静态初始化器是用来对类进行初始化的，而不是对某个对象初始化', '	静态初始化器是由关键字 static 和一对花括号组成的语句组', '	静态初始化器不同于构造方法，它不是方法', '	静态初始化器在产生新对象时，是由系统自动调用的', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (35, '下列关于抽象类的描述中，错误的是', '2', '	抽象类是用修饰符 abstract 说明的', '	抽象类是不可以定义对象的', '	抽象类是不可以有构造方法的', '	抽象类通常要有它的子类', 1001, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (36, '下列关于类的继承性的描述中，错误的是', '3', '	继承是在已有类的基础上生成新类的一种方法', '	子类继承父类的所有成员', '	 Java 语言要求一个子类只有一个父类', '	父类中成员的访问权限在子类中将被改变', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (37, '下列关于子类继承父类的成员的描述中，错误的是', '3', '	子类中继承父类中的所有成员都可以直接访问', '	子类中定义有与父类同名变量时，子类继承父类的操作中，使用继承父类的变量；子类执行自己的操作中，使用自己定义的变量', '	当子类中出现成员方法头与父类方法头相同的方法时，子类成员方法覆盖父类中的成员方法', '	方法重载是编译时处理的，而方法覆盖是在运行时处理的', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (38, '下列关于接口的描述中，错误的是', '4', '	接口实际上是由变量和抽象方法构成的特殊类', '	一个类只允许继承一个接口', '	定义接口使用的关键字是 interface', '	在继承接口的类中通常要给出接口中定义的抽象方法的具体实现', 1001, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (39, '下列关于包的描述中，错误的是', '5', '	包是一种特殊的类  ', '包是若干个类的集合 ', '包是使用 package 语句创建的  ', '包有有包名包和无名包两种', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (40, '下列是系统提供的常用的类，所有类的父类的类是', '6', '	 Math   ', ' Object   ', ' System    ', ' String', 1001, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (41, '下列关于Applet程序的描述中，错误的是', '7', 'Applet程序的主类必须是Applet类的子类', 'Applet程序的主类中应该有一个main()方法', 'Applet不是完整的独立程序', 'Applet的字节码文件必须嵌套在一个HTML文件中', 1001, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (42, '下列关于Applet程序的描述中，错误的是', '8', '将编辑好的Java源文件，使用javac命令生成字节码文件', '将字节码文件嵌入HTML文件，并存放在一个WWW服务器中', '使用浏览器解释HTML文件中的标记', '使用编译器直接执行嵌套在HTML文件中的字节码文件', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (43, '在Applet类的主要方法中，用来实现初始化操作的是', '9', 'init()  ', ' stop()  ', ' start()  ', ' paint()', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (44, '下列关于HTML文件的描述中，错误的是', '10', 'HTML文件是使用一种超文本标记语言(HTML)书写的文件', 'HTML文件中使用的标记通常是用一对尖括号括起来的，两个标记之间是正文内容', 'HTML文件中没有单独出现的标记', 'HTML中不区分大小写字母', 1001, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (45, '下列关于向Applet程序传递参数的描述中，错误的是', '11', 'Applet程序可以通过命令获取外部参数', 'Applet程序可以通过HTML文件获取外部参数', '使用Applet标记中的PARAM标志来实现', 'Applet程序中使用getParameter()方法读取参数值', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (46, '下列关于字体的描述中，错误的是', '12', 'Font类提供了创建字体对象的方法', '字体风格(字型)使用了3个静态常量表示', '	表示字型的字体风格只能单独使用，不可以组合', '	字号表示字的大小，用点表示，一个点为1/72英寸', 1001, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (47, '下列用来获取当前颜色的方法是', '13', '	getColor()  ', ' setColor()  ', ' getRed()  ', ' Color()', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (48, '下列各种绘制矩形的方法中，绘制实心矩形的方法是', '14', '	 fillRect()	    ', ' drawRect()', '	 clearRect() 	', ' drawRoundRect()', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (49, '下列演示图像的描述中，错误的是', '15', '	使用图像类Image定义图像对象', '	使用方法getImage()获取图像信息', '	使用方法drawImage()显示图像', '	不可使用显示图像方法进行缩放', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (50, '下列关于容器的描述中，错误的是', '16', '    容器是由若干个组建和容器组成的', '    容器是对图形界面中界面元素的一种管理', '    容器是一种对指定宽和高的矩形范围', '    容器都是可以独立的窗口', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (51, '下列关于组件类的描述中，错误的是', '17', '组件类中包含了文本组件类(TextComponent)和菜单组件类(MenuComponent)', '标签(Label)和按钮(Button)是组件类(Component)的子类', '面板(Panel)和窗口(Window)是容器类(Container)的子类', '文本框(TextField)和文本区(TextArea)是文本组件类(TextComponent)的子类', 1001, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (52, '在对下列语句的解释中，错误的是', '18', 'but是某种事件对象，如按钮事件对象', 'this表示当前容器', 'ActionListener是动作事件的监听者', '该语句的功能是将but对象注册为this对象的监听者', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (53, '所有事件类的父类是', '19', '	ActionEvent		', 'AwtEvent		', 'KeyEvent		', 'MouseEvent', 1001, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (54, '所有GUI标准组件类的父类是', '20', '	Buttom		', 'List		', 'Component		', 'Container', 1001, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (55, '下列各种布局管理器中Window类、Dialog类和Frame类的默认布局是', '21', '	FlowLayout	', 'CardLayout	', 'BorderLayout	', 'GridLayout', 1001, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (56, '在下列各种容器中，最简单的无边框的又不能移动和缩放的只能包含在另一种容器中的容器是', '22', '	Window	', 'Dialog	', 'Frame	', 'Panel', 1001, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (57, '下列关于菜单和对话框的描述中，错误的是', '22', '	Frame容器是可以容纳菜单组件的容器', '	菜单条中可包含若干个菜单，菜单中又可包含若干菜单项，菜单项中还可包含菜单子项', '	对话框与Frame一样都可作为程序的最外层容器', '	对话框内不含有菜单条，它由Frame弹出', 1001, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (58, '下列关于异常的描述中，错误的是', '22', '  异常是一种经过修正后程序仍可执行的错误', '  异常是一种程序在运行中出现的不可恢复执行的错误', '  不仅Java语言有异常处理，C++语言也有异常处理', '  出现异常不是简单结束程序，而是执行某种处理异常的代码，设法恢复程序的执行', 1001, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (59, '下列关于异常处理的描述中，错误的是', '23', '  程序运行时异常由Java虚拟机自动进行处理', '  使用try-catch-finally语句捕获异常', '  使用throw语句抛出异常', '  捕获到的异常只能用当前方法中处理，不能用其他方法中处理', 1002, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (60, '下列关于try-catch-finally语句的描述中，错误的是', '23', '  try语句后面的程序段将给出处理异常的语句', '  catch()方法跟在try语句后面，它可以是一个或多个', '  catch()方法有一个参数，该参数是某种异常类的对象', '  finally语句后面的程序段总是被执行的，该语句起到提供统一接口的作用', 1002, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (61, '下列关于抛出异常的描述中，错误的是', '23', '  捕捉到发生的异常可在当前方法中处理，也可以抛到调用该方法的方法中处理', '  在说明要抛出异常的方法时应加关键字throw<异常列表>', '  <异常列表>中可以有多个用逗号分隔的异常', '  抛出异常的方法中要使用下述抛出异常语句：throw<异常名>；其中，<异常名>是异常类的类名', 1002, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (62, '下列关于用户创建自己的异常描述中，错误的是', '23', '  创建自己的异常应先创建一个异常类', '  为实现抛出异常，须在可能抛出异常的方法中书写throw语句', '  捕捉异常的方法是使用try-catch-finally语句格式', '  使用异常处理不会使整个系统更加安全和稳定', 1002, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (63, '下列说法中，正确的一项是', '24', '单处理机的计算机上，2个线程实际上不能并发执行', '单处理机的计算机上，2个线程实际上能够并发执行', '一个线程可以包含多个进程', '一个进程只能包含一个线程', 1002, 'A', '单处理机的计算机上通过一个极短的固定时间段或者在线程等待时，切换到另一个线程，这种调度过程时间极短，看上去像是并发执行。', 1, NULL, 10);
INSERT INTO `question` VALUES (64, '下列说法中，错误的一项是', '25', '线程就是程序							', '线程是一个程序的单个执行流', '多线程是指一个程序的多个执行流		', '多线程用于实现并发', 1002, 'A', '线程是一个程序的单个执行流，而不是程序本身。而多线程作为实现并发的一个重要手段，是一个程序的多个执行流。', 1, NULL, 10);
INSERT INTO `question` VALUES (65, '下列关于Thread类的线程控制方法的说法中错误的一项是', '26', '线程可以通过调用sleep()方法使比当前线程优先级低的线程运行', '线程可以通过调用yield()方法使和当前线程优先级一样的线程运行', '线程的sleep()方法调用结束后，该线程进入运行状态', '若没有相同优先级的线程处于可运行状态，线程调用yield()方法时，当前线程将继续执行', 1002, 'C', '线程的sleep()方法调用结束后，该线程进入就绪状态，而不是运行状态。', 1, NULL, 10);
INSERT INTO `question` VALUES (66, '哪个方法resume()负责恢复下列哪一个线程的执行', '27', '通过调用stop()方法而停止的线程			', '通过调用sleep()方法而停止的线程', '通过调用wait()方法而停止的线程			', '通过调用suspend()方法而停止的线程', 1002, 'D', '通过调用suspend()方法而停止的线程需要调用resume()恢复。', 1, NULL, 10);
INSERT INTO `question` VALUES (67, '下面的哪一个关键字通常用来对对象加锁，从而使得对对象的访问是排他的', '28', 'serialize			', 'transient	  		', 'synchronized		', 'static', 1002, 'C', 'synchronized用来对对象加锁，从而使得对对象的访问是排他的。', 1, NULL, 10);
INSERT INTO `question` VALUES (68, '下列说法中，错误的一项是', '29', '线程一旦创建，则立即自动执行', '线程创建后需要调用start()方法，将线程置于可运行状态', '调用线程的start()方法后，线程也不一定立即执行', '线程处于可运行状态，意味着它可以被调度', 1002, 'A', '线程创建后需要调用start()方法，将线程置于可运行状态。', 1, NULL, 10);
INSERT INTO `question` VALUES (69, '下列说法中，错误的一项是', '29', 'Thread类中没有定义run()方法		', '可以通过继承Thread类来创建线程', 'Runnable接口中定义了run()方法		', '可以通过实现Runnable接口创建线程', 1002, 'A', 'Thread类和Runnable接口中都定义了run()方法，而start()方法只有Thread类中进行了定义，而Runnable接口中没有定义。', 1, NULL, 10);
INSERT INTO `question` VALUES (70, 'Thread类定义在下列哪个包中', '29', 'java.io				', 'java.lang	  		', 'java.util			', 'java.awt', 1002, 'B', 'Thread类定义在java.lang包中，因此使用时可以不用显式加载。', 1, NULL, 10);
INSERT INTO `question` VALUES (71, 'Thread类的常量NORM_PRIORITY代表的优先级是', '29', '最低优先级		', '最高优先级		', '普通优先级		', '不是优先级', 1002, 'C', 'NORM_PRIORITY代表的优先级是普通优先级。', 1, NULL, 10);
INSERT INTO `question` VALUES (72, '下列关于线程优先级的说法中，错误的一项是', '29', 'MIN_PRIORITY代表最低优先级		', 'MAX_PRIORITY代表最高优先级', 'NORM_PRIORITY代表普通优先级		', '代表优先级的常数值越大优先级越低', 1002, 'D', '代表优先级的常数值越大优先级越高', 1, NULL, 10);
INSERT INTO `question` VALUES (73, '要想保存具有映射关系的数据，可以使⽤以下哪些集合？', '30', 'ArrayList、TreeMap', 'TreeMap、HashMap', 'ArrayList、HashMap', 'TreeSet 、TreeMap', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (74, 'Java 语⾔中，集合类都位于哪个包中？', '31', 'java.util', 'java.lang', 'java.array', 'java.collections', 1003, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (75, '使⽤Iterator时，判断是否存在下⼀个元素可以使⽤以下哪个⽅法？', '31', 'next()', 'hash()', 'hasPrevious()', 'hasNext()', 1003, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (76, '关于foreach循环的特点，以下说法哪些是错误的？ ', '31', 'foreach循环在遍历集合时，⽆需获得容器的长度', 'foreach循环在遍历集合时，⽆需循环条件，也⽆需迭代语句', 'foreach循环在遍历集合时⾮常繁琐', 'foreach循环的语法格式为：for(容器中元素类型 临时变量：容器变量)。   ', 1003, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (77, '在程序开发中，经常会使⽤以下哪个类来存储程序中所 需的配置？', '31', 'HashMap', 'TreeSet', 'Properties', 'TreeMap', 1003, NULL, NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (78, '使⽤Enumeration遍历集合时，需要使⽤以下哪些⽅法？', '31', 'hasMoreElements()、nextElement()', 'nextElement()、next()', 'next()、hasMoreElements()', 'hashNext()、next()', 1003, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (79, '要想集合中保存的元素没有重复并且按照⼀定的顺序排列，  可以使⽤以下哪个集合？', '31', 'LinkedList', 'ArrayList', 'hashSet', ' TreeSet', 1003, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (80, '下列哪些说法是正确的', '31', 'LinkedList集合在增删元素时效率较⾼', 'ArrayList集合在查询元素时效率较低', 'HashMap不允许出现⼀对null键null值', ' HashSet集合中元素可重复并且⽆序', 1003, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (81, '以下哪些⽅法不是LinkedList集合中定义的？', '31', 'getLast()', 'getFirst()', ' remove (int index)', 'next()', 1003, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (82, '获取单列集合中元素的个数可以使⽤以下哪个⽅法？', '32', 'length()', 'size()', 'get(int index)', 'add(Object obj)', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (83, '下列数据流中，属于输入流的一项是', '32', '从内存流向硬盘的数据流			', '从键盘流向内存的数据流', '从键盘流向显示器的数据流			', '从网络流向显示器的数据流', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (84, 'Java语言提供处理不同类型流的类所在的包是', '32', 'java.sql		', 'java.util	  		', 'java.net			', 'java.io', 1003, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (85, '不属于java.io包中的接口的是', '33', 'DataInput		', 'DataOutput  		', 'DataInputStream	', 'ObjectInput', 1003, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (86, '下列流中哪一个使用了缓冲区技术', '33', 'BufferedOutputStream				', 'FileInputStream', 'DataOutputStream					', 'FileReader', 1003, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (87, '能读入字节数据进行Java基本数据类型判断过虑的类是', '33', 'BufferedInputStream					', 'FileInputStream', 'DataInputStream					', 'FileReader', 1003, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (88, '使用哪一个类可以实现在文件的任一个位置读写一个记录', '33', 'BufferedInputStream					', 'RandomAccessFile', 'FileWriter							', 'FileReader', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (89, '在通常情况下，下列哪个类的对象可以作为BufferedReader类构造方法的参数', '33', 'PrintStream						', 'FileInputStream', 'InputStreamReader					', 'FileReader', 1003, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (90, '若文件是RandomAccessFile的实例f，并且其基本文件长度大于0，则下面的语句实现的功能是', '33', '将文件指针指向文件的第一个字符后面		', '将文件指针指向文件的最后一个字符前面 ', '将文件指针指向文件的最后一个字符后面 ', '会导致seek()方法抛出一个IOException异常', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (91, '下列关于流类和File类的说法中错误的一项是', '33', 'File类可以重命名文件				', 'File类可以修改文件内容', '流类可以修改文件内容				', '流类不可以新建目录', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (92, '若要删除一个文件，应该使用下列哪个类的实例', '33', 'RandomAccessFile					', 'File', 'FileOutputStream					', 'FileReader', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (93, '下列哪一个是Java系统的标准输入流对象', '34', 'System.out	', 'System.in 		', 'System.exit		', 'System.err', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (94, 'Java系统标准输出对象System.out使用的输出流是', '34', 'PrintStream						', 'PrintWriter', 'DataOutputStream					', 'FileReader', 1003, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (95, 'Java网络程序位于TCP/IP参考模型的哪一层？', '34', '网络层互联层', '应用层', '传输层网络', '主机-网络层', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (96, '问题：以下哪个协议位于传输层？', '34', 'TCP  ', 'HTTP', 'SMTP  ', 'IP', 1003, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (97, '假定一个进程已经占用TCP的80端口，它还能否占用UDP的80端口？', '34', '可以', '不可以', '不清楚', '看情况', 1003, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (98, '有一种协议规定：如果客户端发送一行字符串“date”，服务器端就返回当前日期信息，如果客户端发送一行字符串“exit”，服务器端就结束与客户端的通信。这种协议应该属于哪一层的协议？', '34', '网络层互联层', '应用层', '传输层网络', '主机-网络层', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (99, 'HTTP协议规定，默认情况下，HTTP服务器占用的TCP端口号是什么？', '34', '21', '23', '80', '任意一个未被占用的端口号', 1003, 'C', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (100, '在客户/服务器通信模式中，对客户与服务器程序的主要任务描述不正确的是', '34', '客户程序在网络上找到一条到达服务器的路由。', '客户程序发送请求，并接收服务器的响应。', '服务器程序接收并处理客户请求，然后向客户发送响应结果。', '客户程序和服务器不都会保证发送的数据不会在传输途中丢失。', 1003, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (101, '从哪里可以找到描述TCP/IP协议的具体文档？', '34', 'JDK的JavaDoc文档', 'NIC的官方网站', '国际标准化组织（ISO）的官方网站', 'RFC的官方网站', 1003, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (102, '当客户端执行以下程序代码时：Socket socket=new Socket(\"angel\",80);如果远程服务器angel不存在，会出现什么情况？', '34', '构造方法抛出UnknownHostException异常。', '客户端一直等待连接，直到连接超时，从而抛出SocketTimeoutException。', '抛出BindException。', '构造方法返回一个Socket对象，但它不与任何服务器连接。', 1003, 'A', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (103, 'Socket类的哪个方法返回Socket对象绑定的本地端口？', '34', 'getPort()', 'getLocalPort()', 'getRemotePort()', '不存在这样的方法，因为Socket对象绑定的本地端口对程序是透明的。', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (104, '以下哪个选项设定Socket的接收数据时的等待超时时间？', '34', 'SO_LINGER', 'SO_RCVBUF', 'SO_KEEPALIVE', 'SO_TIMEOUT', 1003, 'D', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (105, '如何判断一个Socket对象当前是否处于连接状态？', '34', 'boolean isConnected=socket.isConnected() && socket.isBound();', 'boolean isConnected=socket.isConnected() && !socket.isClosed();', 'boolean isConnected=socket.isConnected() && !socket.isBound();', 'boolean isConnected=socket.isConnected() ||!socket.isBound();', 1003, 'B', NULL, 1, NULL, 10);
INSERT INTO `question` VALUES (107, 'Java是C++的语言之前问世的。', '1', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (108, 'Java语言具有较好的安全性和可移植性及与平台无关等特性。', '1', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (109, 'Java语言中取消了联合的概念，保留了结构概念。', '1', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (110, 'Java语言中数据类型占内在字节数与平台无关。', '1', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (111, 'Java语言中可用下标和指针两种方式表示数组元素。', '2', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (112, 'Java语言的源程序不是编译型的，而是编译解释型的。', '2', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (113, '操作系统中进程和线程两个概念是没有区别的。', '3', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (114, 'Java语言既是面向对象的又是面向网络的高级语言。', '3', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (115, 'Java程序分为两大类：一类是Application程序，另一类是Applet程序。前者又称Java应用程序，后者又称为Java小应用程序。', '3', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (116, 'Java Application程序是由多个文件组成的，其中可以有也可以没有主文件。', '3', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (117, '组成Java Application的若干类中，有且仅有一个主类，只有主类中含有主方法main()。', '3', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (118, 'Java Application程序中，必有一个主方法main()，该方法有没有参数都可以。', '3', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (119, 'Java程序中是不区分大小写字母的。', '3', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (120, '下述两个命令：javac和java是不同的，编译时用前者，运行时用后者。', '3', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (121, 'Java程序编译后生成的是字节码文件，其后缀是.exe。', '3', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (122, '字节码文件机器是不能直接识别的，它要经过解释器，边解释边执行。', '3', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (123, '在Java程序中，使用import语句引入类是在解释器中实现的。', '3', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (124, '在运行字节码文件时，使用java命令，一定要给出字节码文件的扩展名.class。', '4', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (125, 'Java程序中有多个类，编译后只生成一个字节码文件，其名字同主类名。', '4', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (126, 'Java程序中出现的输出方法println()和print()是完全一致的。', '4', NULL, NULL, NULL, '1', 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (127, '类是一种类型，也是对象的模板。', '4', NULL, NULL, NULL, '3', 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (128, 'Java语言只支持单重继承，不支持多重继承。', '4', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (129, '类中说明的方法可以定义在类体外。', '4', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (130, 'class 不是定义类的唯一关键字。', '4', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (131, '某类的对象可以作为另一个类的成员。', '4', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (132, '在类体内说明成员变量时不允许赋初值。', '5', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (133, '最终变量就是Java 语言中的符号常量。', '5', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (134, '静态变量的引用只能使用对象。', '5', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (135, '静态方法只能处理静态变量。', '5', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (136, '抽象方法是一种只有说明而无具体实现的方法。', '5', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (137, '最终方法是不能被当前子类重新定义的方法。', '5', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (138, 'Java语言中，方法调用一律都是传址的引用调用。', '6', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (139, '非静态方法中不能引用静态变量。', '7', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (140, '静态初始化器是在构造方法被自动调用之前运行的。', '8', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (141, '抽象方法仅有方法头，而无方法体。', '9', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (142, '抽象方法一定出现在抽象类中。', '10', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (143, '最终类，最终方法和最终变量的修饰符都用final 。', '11', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (144, '创建对象时系统将调用适当的构造方法给对象初始化。', '12', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (145, '使用运算符new 创建对象时，赋给对象的值实际上是一个地址值。', '13', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (146, '使用构造方法只能给非静态成员变量赋初值。', '14', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (147, '创建对象时，该对象占用的内存空间除了非静态的成员变量外，还有非静态的成员方法。', '15', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (148, '3-33  Java 语言中，对象成员的表示只使用运算符 “.”。', '16', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (149, 'Java 语言中，对象赋值实际上是同一个对象具有两个不同的名字，因为他们都有同一个地址值。', '17', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (150, '对象可作方法参数，对象数组不能作方法参数。', '17', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (151, 'Java语言中，所创建的子类都应有一个父类。', '17', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (152, 'ava语言中，类的继承是可以传递的。', '17', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (153, 'Java语言中，构造方法是可以继承的。', '18', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (154, '子类中构造方法应包含自身类的构造方法和直接父类的构造方法。', '18', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (155, '调用this 或 super 的构造方法的语句必须放在第一条语句。', '18', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (156, '子类对象可以直接赋值给父类对象；而父类对象不可以赋值给子类对象。', '18', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (157, '子类中所继承父类的成员都可以在子类中访问。', '18', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (158, '成员方法的重载和覆盖是一回事。', '18', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (159, '一个类可以实现多个接口。接口可以实现“多重继承”。', '18', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (160, '实现接口的类不能是抽象类。', '19', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (161, 'Applet程序是通过浏览器中内置的Java解释器来解释执行的。', '19', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (162, 'Applet程序是以.Java为扩展名的Java语言源程序，该程序经过编译器后便可成为可执行文件。', '19', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (163, '嵌入到HTML文件中的是Applet的源程序。', '19', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (164, '运行Applet程序是使用AppletViewer命令运行嵌入了字节码文件的HTML文件，从而获得运行结果。', '19', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (165, 'Applet程序中的主类必须是Applet类的子类。', '19', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (166, 'Applet类是Java语言类库中的一个重要的系统类，它被存放在包中。', '19', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (167, 'init()方法是用来完成初始化操作的，在Applet程序运行期间只执行一次。', '19', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (168, 'start()方法被系统自动调用来启动主线程运行。通常在Applet程序被重启动时，该方法被系统自动调用。', '19', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (169, 'paint()方法是在需要重画图形界面时被系统自动调用来显示输出结果的。', '19', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (170, 'stop()方法是用来暂停执行操作的，它与start()方法不同，只被调用一次。', '19', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (171, 'init()，start()，stop()和destroy()4个方法构成Applet程序的生命周期。', '20', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (172, 'HTML语言中<HEAD>和</HEAD>是用来表示HTML文件开始和结束的标记。', '21', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (173, 'HTML中多数标记是成对出现的，也有不成对出现的标记。', '22', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (174, 'HTML中是区分大小写字母的。', '22', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (175, '通过HTML文件中使用的PARAM标记可以向Applet程序传递参数的。', '22', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (176, 'parseInt()方法的功能是将int型数据转换成String型数据的。', '22', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (177, 'AWT提供了许多标准的GUI组件和布局管理等类。', '22', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (178, 'Java语言采用了16位颜色标准，Java的调色板保证138色。', '22', NULL, NULL, NULL, NULL, 1001, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (179, 'Graphics类提供了3种绘制文本的方法，其方法名都是drawString()。', '22', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (180, '绘制椭圆的方法是drawOval()，使用该方法也可以绘制圆。', '22', NULL, NULL, NULL, NULL, 1001, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (181, 'AWT是抽象窗口工具包的英文缩写。', '23', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (182, '容器中只能包含有组件，而不能再含有容器。', '23', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (183, '容器分可以独立的窗口和不可以独立的窗口两种。', '23', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (184, '单选按钮提供“多选一”的输入选择，下拉列表提供“多选多”的输入选择。', '23', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (185, '所有容器的默认布局都是FlowLayout。', '23', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (186, '所有的组件都是事件源。', '24', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (187, 'Java 3 的事件处理方法是采用委托事件处理模型。', '24', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (188, '事件组件都应注册一个事件监听者。', '24', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (189, '事件监听者除了得知事件的发生外，还应调用相应方法处理事件。', '24', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (190, '所有事件的父类是EventObject类。', '24', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (191, '图形用户界面是由用户自定义成分、控制组件和容器组成的。', '24', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (192, '所有GUI标准组件类的父类是Component类。', '24', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (193, '所有容器类的父类是Frame类。', '24', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (194, '标准和按钮都是事件源。', '25', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (195, '文本去和文本框都可以引发两种事件：文本改变事件和动作事件。', '25', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (196, '每个复选框有两种状态：“打开”和“关闭”状态。', '25', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (197, '复选框组(CheckboxGroup)是由若干个按钮组成的。在一组按钮中可选多个。', '25', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (198, '列表(List)是由多个选项组成的，只可在列表框的若干个选项选取一个。', '25', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (199, '下拉列表(Choice)是一种“多选多”的输入界面。', '25', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (200, '滚动条有两类：水平滚动条和垂直滚动条。', '25', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (201, '画布(Canvas)是一种可容纳多个组件的容器。', '25', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (202, '所有容器都采用顺序布局(FlowLayout)作为默认布局管理器。', '26', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (203, '边界布局(BorderLayout)将容器分为东、西、南、北共4个区域。', '26', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (204, '卡片布局(CardLayout)可使容器容纳多个组件，在同一时刻只显示若干个组件中的一个。', '26', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (205, '容器可容纳组件和容器，同一个容器中的组件可被同时显示或者同时隐藏。', '26', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (206, '所有容器都是有边框的。', '26', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (207, 'Panel容器是可以嵌套使用的。', '26', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (208, 'Applet实际是一种特殊的Panel容器。Java Applet程序只负责它拥有的Applet容器内的无边框区域。', '26', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (209, '窗口(Window)容器是一种独立窗口，但它不能作为程序的最外层容器。', '26', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (210, 'Frame容器是有边框的容器，它也是一种独立窗口，只能作为最外层容器。', '26', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (211, 'Frame容器可以容纳菜单组件，它实现了MenuContainer接口。', '26', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (212, 'MenuComponent类是菜单组件的父类。', '26', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (213, '菜单条(MunuBar)、菜单(Munu)、菜单项(MunuItem)是3中不同的菜单组件。', '26', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (214, '对话框(Dialog)不是一种独立使用的容器。', '26', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (215, '文件对话框(FileDialog)是对话框(Dialog)的子类，它是一种打开文件和保留文件的对话框窗口。', '26', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (216, '异常是一种特殊的运行错误的对象。', '27', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (217, '异常处理可以使整个系统更加安全和稳定。', '27', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (218, '异常处理是在编译时进行的。', '27', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (219, '语言中异常类都是的子类。', '27', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (220, '类有两个子类：Error类和Exception类。前者由系统保留，后者供应用程序使用。', '27', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (221, '异常通常是指Error类和Exception类。', '27', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (222, '类只有一个子类为RuntimeException。', '27', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (223, '在异常处理中，出现异常和抛出异常是一回事。', '28', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (224, '运行时异常是在运行时系统检测并处理的。', '28', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (225, '使用try-catch-finally语句只能捕获一个异常。', '29', NULL, NULL, NULL, NULL, 1002, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (226, '捕获异常时try语句后面通常跟有一个或多个catch()方法用来处理try块内生成的异常事件。', '29', NULL, NULL, NULL, NULL, 1002, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (227, '使用finally语句的程序代码为该程序提供一个统一的的出口。', '30', NULL, NULL, NULL, NULL, 1003, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (228, '抛出异常的方法说明中要加关键字throws，并在该方法中还应添加throw语句。', '31', NULL, NULL, NULL, NULL, 1003, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (229, '创建异常类时要给出该异常类的父类。', '32', NULL, NULL, NULL, NULL, 1003, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (230, '如果异常类没有被捕获将会产生不正常的终止。', '33', NULL, NULL, NULL, NULL, 1003, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (231, 'Set集合是通过键值对的⽅式来存储对象的。', '34', NULL, NULL, NULL, NULL, 1003, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (232, '集合中不能存放基本数据类型，⽽只能存放引⽤数据类型.', '34', NULL, NULL, NULL, NULL, 1003, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (233, '如果创建的TreeSet集合中没有传⼊⽐较器，则该集合中存⼊的元素需要实现Comparable接⼝。', '34', NULL, NULL, NULL, NULL, 1003, 'T', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (234, '使⽤Iterator迭代集合元素时，可以调⽤集合对象的⽅法增删元素。', '21', NULL, NULL, NULL, NULL, 1003, 'F', NULL, 3, NULL, 10);
INSERT INTO `question` VALUES (249, '编写一个Java Application程序，使该程序运行后输出字符串\"Hello!How are you.\"', '1', NULL, NULL, NULL, NULL, 1001, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (250, '编写一个Java Application程序，使该程序输出显示如下结果： Var1=10,var2=Ok!', '1', NULL, NULL, NULL, NULL, 1001, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (251, '编程将一个浮点型数的整数部分和小数分别输出显示。', '2', NULL, NULL, NULL, NULL, 1001, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (252, '编程求出自然数101~205中的所有素数。', '3', NULL, NULL, NULL, NULL, 1001, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (253, '使用switch语句根据考试成绩等级输出百分制的分数段。', '25', NULL, NULL, NULL, NULL, 1002, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (254, '编写Applet程序，在一个椭圆内填写一个字符串。椭圆大小和位置以及字符串内容和字体都由读者自定。', '25', NULL, NULL, NULL, NULL, 1002, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (255, '编写Applet程序，选择5种不同的字体写出字符串“I Love Beijing！”。', '26', NULL, NULL, NULL, NULL, 1002, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (256, '使用Java Application编写满足下列要求的程序：使用GridLayout布局；设计一个简单的计算器。包括数字按钮0~9，以及加、减、乘、除、清零、等于运算按钮和一个现实计算结果的文本区；', '27', NULL, NULL, NULL, NULL, 1002, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (257, '编写一个可以弹出对话框的程序。', '28', NULL, NULL, NULL, NULL, 1002, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (258, '编写一个图形用户界面的Application程序：有一个菜单条；菜单条中有5个菜单；每个菜单有2个菜单项，其中一个菜单项又具有2个菜单子项', '29', NULL, NULL, NULL, NULL, 1002, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (259, '定义一个circle类，其中有求面积的方法，当圆的半径小于0时，抛出一个自定义的异常。', '31', NULL, NULL, NULL, NULL, 1003, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (260, '编程实现数组下标越界异常，并输出显示适当的错误信息。', '32', NULL, NULL, NULL, NULL, 1003, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (261, '编写一个系统自动抛出的、系统自行处理的数组大小为负数的程序。', '33', NULL, NULL, NULL, NULL, 1003, NULL, NULL, 12, NULL, 10);
INSERT INTO `question` VALUES (262, '编写一个由throw抛出的、系统自行处理的数组下标越界的程序。', '34', NULL, NULL, NULL, NULL, 1003, NULL, NULL, 12, NULL, 10);

-- ----------------------------
-- Table structure for role
-- ----------------------------
DROP TABLE IF EXISTS `role`;
CREATE TABLE `role`  (
  `roleId` int(11) NOT NULL COMMENT 'id',
  `roleName` varchar(12) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '角色名',
  `sort` int(11) NULL DEFAULT NULL COMMENT '排序',
  `status` tinyint(4) NULL DEFAULT NULL COMMENT '标识',
  PRIMARY KEY (`roleId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of role
-- ----------------------------
INSERT INTO `role` VALUES (1, '管理员', 1, 1);
INSERT INTO `role` VALUES (2, '学生', 3, 1);
INSERT INTO `role` VALUES (3, '教师', 2, 1);

-- ----------------------------
-- Table structure for rolemenu
-- ----------------------------
DROP TABLE IF EXISTS `rolemenu`;
CREATE TABLE `rolemenu`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `roleId` int(11) NULL DEFAULT NULL COMMENT '角色id',
  `menuid` int(11) NULL DEFAULT NULL COMMENT '菜单id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `roleId`(`roleId`) USING BTREE,
  INDEX `menuid`(`menuid`) USING BTREE,
  CONSTRAINT `rolemenu_ibfk_1` FOREIGN KEY (`roleId`) REFERENCES `role` (`roleId`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `rolemenu_ibfk_2` FOREIGN KEY (`menuid`) REFERENCES `kidmenu` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 400 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of rolemenu
-- ----------------------------
INSERT INTO `rolemenu` VALUES (386, 2, 111);
INSERT INTO `rolemenu` VALUES (387, 2, 113);
INSERT INTO `rolemenu` VALUES (388, 3, 108);
INSERT INTO `rolemenu` VALUES (389, 3, 109);
INSERT INTO `rolemenu` VALUES (390, 3, 110);
INSERT INTO `rolemenu` VALUES (391, 3, 112);
INSERT INTO `rolemenu` VALUES (392, 1, 101);
INSERT INTO `rolemenu` VALUES (393, 1, 102);
INSERT INTO `rolemenu` VALUES (394, 1, 108);
INSERT INTO `rolemenu` VALUES (395, 1, 109);
INSERT INTO `rolemenu` VALUES (396, 1, 110);
INSERT INTO `rolemenu` VALUES (397, 1, 111);
INSERT INTO `rolemenu` VALUES (398, 1, 112);
INSERT INTO `rolemenu` VALUES (399, 1, 113);

-- ----------------------------
-- Table structure for study_record
-- ----------------------------
DROP TABLE IF EXISTS `study_record`;
CREATE TABLE `study_record`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名',
  `study_time` int(11) NULL DEFAULT NULL COMMENT '学习时长',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of study_record
-- ----------------------------
INSERT INTO `study_record` VALUES (2, '张三', 17);
INSERT INTO `study_record` VALUES (3, '张三', 15);
INSERT INTO `study_record` VALUES (4, '123', 27);
INSERT INTO `study_record` VALUES (5, '123', 5);
INSERT INTO `study_record` VALUES (6, '123', 29);
INSERT INTO `study_record` VALUES (7, '张三', 2);
INSERT INTO `study_record` VALUES (8, 'system', 3);

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `email` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'emial',
  `roleId` int(11) NULL DEFAULT NULL COMMENT '角色id',
  `state` tinyint(1) NULL DEFAULT NULL COMMENT '状态',
  `register_time` datetime NOT NULL COMMENT '注册时间',
  `phone` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '电话号码',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username_2`(`username`) USING BTREE,
  INDEX `roleId`(`roleId`) USING BTREE,
  INDEX `id`(`id`) USING BTREE,
  INDEX `username`(`username`) USING BTREE,
  CONSTRAINT `sys_user_ibfk_1` FOREIGN KEY (`roleId`) REFERENCES `role` (`roleId`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 116 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (1, 'coach', '123456', '111', 3, 1, '0000-00-00 00:00:00', '');
INSERT INTO `sys_user` VALUES (2, 'system', '123456', '1111', 1, 1, '0000-00-00 00:00:00', '');
INSERT INTO `sys_user` VALUES (4, 'admin', '123456', 'aaaas', 1, 1, '0000-00-00 00:00:00', '');
INSERT INTO `sys_user` VALUES (8, '张三', '123456', '222', 2, 1, '0000-00-00 00:00:00', '');
INSERT INTO `sys_user` VALUES (109, '123', '111111', '123', 2, 1, '0000-00-00 00:00:00', '');
INSERT INTO `sys_user` VALUES (111, 'teacher', '123456', '111', 3, 1, '0000-00-00 00:00:00', '');
INSERT INTO `sys_user` VALUES (112, 'test1', '123456', '1123', 2, 1, '0000-00-00 00:00:00', '');
INSERT INTO `sys_user` VALUES (113, 'aaaaa', '1234', NULL, NULL, NULL, '2022-12-05 00:00:00', '18964403537');
INSERT INTO `sys_user` VALUES (114, 'wwwwss', '123', NULL, NULL, NULL, '2022-12-06 00:00:00', '18964403537');
INSERT INTO `sys_user` VALUES (115, 'zhangsan', '123', NULL, NULL, NULL, '2022-12-08 21:33:32', '18964403537');

-- ----------------------------
-- Table structure for user_question
-- ----------------------------
DROP TABLE IF EXISTS `user_question`;
CREATE TABLE `user_question`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `paper_id` int(11) NULL DEFAULT NULL COMMENT '试卷id',
  `q_no` int(11) NULL DEFAULT NULL COMMENT '题目id',
  `answer` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '学生作答',
  `myState` char(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '是否正确 error：错误  right：正确  un：空',
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名称',
  `delete_if` int(11) UNSIGNED NULL DEFAULT 0 COMMENT '是否在错题集中被删除，被删除为1，未被删除为0',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 633 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;

-- ----------------------------
-- Records of user_question
-- ----------------------------
INSERT INTO `user_question` VALUES (1, 1000, 0, '0', '', '0', 0);
INSERT INTO `user_question` VALUES (152, 1001, 16, 'ad,ac', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (153, 1001, 113, 'F', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (154, 1001, 18, 'C', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (155, 1001, 4, 'B', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (156, 1001, 20, 'C', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (157, 1001, 5, 'A', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (158, 1001, 6, 'D', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (159, 1001, 118, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (160, 1002, 225, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (161, 1002, 3, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (162, 1002, 163, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (163, 1002, 101, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (164, 1002, 229, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (165, 1002, 7, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (166, 1002, 39, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (167, 1002, 263, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (168, 1002, 74, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (169, 1002, 140, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (170, 1002, 109, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (171, 1002, 16, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (172, 1002, 80, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (173, 1002, 17, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (174, 1002, 50, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (175, 1002, 87, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (176, 1002, 91, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (177, 1003, 16, ',', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (178, 1003, 2, 'D', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (179, 1003, 19, 'A', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (180, 1003, 21, 'C', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (181, 1003, 6, 'C', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (182, 1003, 22, 'A', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (183, 1003, 118, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (184, 1003, 126, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (185, 1004, 112, 'F', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (186, 1004, 1, 'A', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (187, 1004, 17, '1,2', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (188, 1004, 20, 'D', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (189, 1004, 5, 'B', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (190, 1004, 6, 'C', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (191, 1004, 7, 'B', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (192, 1004, 122, 'T', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (193, 1005, 17, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (194, 1005, 18, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (195, 1005, 20, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (196, 1005, 6, 'B', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (197, 1005, 22, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (198, 1005, 7, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (199, 1005, 108, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (200, 1005, 109, 'F', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (201, 1006, 16, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (202, 1006, 1, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (203, 1006, 18, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (204, 1006, 3, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (205, 1006, 22, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (206, 1006, 7, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (207, 1006, 107, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (208, 1006, 12, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (209, 1007, 1, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (210, 1007, 2, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (211, 1007, 3, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (212, 1007, 4, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (213, 1007, 5, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (214, 1007, 6, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (215, 1007, 7, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (216, 1007, 263, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (217, 1007, 74, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (218, 1007, 140, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (219, 1007, 16, ',', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (220, 1007, 80, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (221, 1007, 17, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (222, 1007, 18, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (223, 1007, 19, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (224, 1007, 20, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (225, 1007, 21, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (226, 1007, 22, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (227, 1007, 87, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (228, 1007, 91, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (229, 1007, 225, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (230, 1007, 163, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (231, 1007, 101, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (232, 1007, 229, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (233, 1007, 39, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (234, 1007, 108, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (235, 1007, 109, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (236, 1007, 112, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (237, 1007, 113, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (238, 1007, 50, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (239, 1007, 118, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (240, 1007, 122, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (241, 1007, 126, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (242, 1008, 1, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (243, 1008, 2, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (244, 1008, 3, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (245, 1008, 4, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (246, 1008, 5, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (247, 1008, 6, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (248, 1008, 7, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (249, 1008, 263, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (250, 1008, 74, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (251, 1008, 140, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (252, 1008, 16, ',', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (253, 1008, 80, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (254, 1008, 17, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (255, 1008, 18, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (256, 1008, 19, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (257, 1008, 20, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (258, 1008, 21, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (259, 1008, 22, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (260, 1008, 87, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (261, 1008, 91, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (262, 1008, 225, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (263, 1008, 163, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (264, 1008, 101, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (265, 1008, 229, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (266, 1008, 39, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (267, 1008, 108, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (268, 1008, 109, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (269, 1008, 112, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (270, 1008, 113, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (271, 1008, 50, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (272, 1008, 118, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (273, 1008, 122, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (274, 1008, 126, '', '', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (275, 1015, 1, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (276, 1015, 2, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (277, 1015, 3, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (278, 1015, 4, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (279, 1015, 5, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (280, 1016, 1, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (281, 1016, 2, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (282, 1016, 3, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (283, 1016, 4, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (284, 1016, 5, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (285, 1017, 1, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (286, 1017, 2, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (287, 1017, 3, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (288, 1017, 4, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (289, 1017, 5, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (290, 1018, 1, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (291, 1018, 2, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (292, 1018, 3, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (293, 1018, 4, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (294, 1018, 5, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (295, 1019, 1, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (296, 1019, 2, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (297, 1019, 3, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (298, 1019, 4, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (299, 1019, 5, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (300, 1020, 1, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (301, 1020, 2, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (302, 1020, 3, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (303, 1020, 4, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (304, 1020, 5, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (305, 1021, 1, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (306, 1021, 2, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (307, 1021, 3, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (308, 1021, 4, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (309, 1022, 1, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (310, 1022, 2, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (311, 1022, 3, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (312, 1022, 4, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (313, 1023, 1, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (314, 1023, 2, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (315, 1023, 3, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (316, 1023, 4, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (317, 1024, 1, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (318, 1024, 2, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (319, 1024, 3, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (320, 1024, 4, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (321, 1025, 1, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (322, 1025, 2, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (323, 1025, 3, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (324, 1025, 4, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (325, 1026, 1, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (326, 1026, 2, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (327, 1026, 3, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (328, 1026, 4, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (329, 1027, 1, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (330, 1027, 2, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (331, 1028, 1, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (332, 1028, 2, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (333, 1029, 1, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (334, 1029, 2, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (335, 1030, 1, 'A', 'right', '张三', 0);
INSERT INTO `user_question` VALUES (336, 1030, 2, 'B', 'error', '张三', 0);
INSERT INTO `user_question` VALUES (337, 1030, 3, 'B', 'error', '张三', 0);
INSERT INTO `user_question` VALUES (338, 1031, 1, '1', 'error', '123', 0);
INSERT INTO `user_question` VALUES (339, 1031, 2, '1', 'error', '123', 0);
INSERT INTO `user_question` VALUES (340, 1031, 3, '1', 'error', '123', 0);
INSERT INTO `user_question` VALUES (341, 1032, 1, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (342, 1032, 2, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (343, 1032, 3, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (344, 1033, 1, '1', 'error', '张三', 0);
INSERT INTO `user_question` VALUES (345, 1033, 2, '1', 'right', '张三', 0);
INSERT INTO `user_question` VALUES (346, 1033, 4, '1', 'right', '张三', 0);
INSERT INTO `user_question` VALUES (347, 1033, 8, '1', 'right', '张三', 0);
INSERT INTO `user_question` VALUES (348, 1033, 9, '1', 'right', '张三', 0);
INSERT INTO `user_question` VALUES (349, 1033, 5, '1', 'right', '张三', 0);
INSERT INTO `user_question` VALUES (350, 1034, 1, 'A', 'right', '123', 0);
INSERT INTO `user_question` VALUES (351, 1034, 2, 'A', 'error', '123', 0);
INSERT INTO `user_question` VALUES (352, 1034, 4, 'A', 'error', '123', 0);
INSERT INTO `user_question` VALUES (353, 1034, 8, 'T', NULL, '123', 0);
INSERT INTO `user_question` VALUES (354, 1034, 9, 'F', NULL, '123', 0);
INSERT INTO `user_question` VALUES (355, 1034, 5, 'A', NULL, '123', 0);
INSERT INTO `user_question` VALUES (356, 1035, 1, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (357, 1035, 2, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (358, 1035, 4, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (359, 1035, 8, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (360, 1035, 9, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (361, 1035, 5, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (362, 1036, 60, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (363, 1036, 62, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (364, 1036, 67, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (365, 1036, 71, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (366, 1036, 183, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (367, 1037, 60, '11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111', NULL, '123', 0);
INSERT INTO `user_question` VALUES (368, 1037, 62, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (369, 1037, 67, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (370, 1037, 71, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (371, 1037, 183, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (372, 1038, 60, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (373, 1038, 62, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (374, 1038, 67, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (375, 1038, 71, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (376, 1038, 183, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (377, 1039, 258, '1111', NULL, '张三', 0);
INSERT INTO `user_question` VALUES (378, 1039, 257, NULL, NULL, '张三', 0);
INSERT INTO `user_question` VALUES (379, 1040, 258, '1111111111111', 'error', '123', 0);
INSERT INTO `user_question` VALUES (380, 1040, 257, '111111', 'right', '123', 0);
INSERT INTO `user_question` VALUES (381, 1041, 258, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (382, 1041, 257, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (383, NULL, 20, 'a', 'error', '123', 0);
INSERT INTO `user_question` VALUES (384, NULL, 107, NULL, 'error', '123', 0);
INSERT INTO `user_question` VALUES (385, NULL, 5, NULL, 'error', '123', 0);
INSERT INTO `user_question` VALUES (386, NULL, 17, NULL, 'error', '123', 0);
INSERT INTO `user_question` VALUES (387, NULL, 14, NULL, 'error', '123', 0);
INSERT INTO `user_question` VALUES (388, NULL, 164, NULL, 'error', '123', 0);
INSERT INTO `user_question` VALUES (389, NULL, 37, NULL, 'error', '123', 0);
INSERT INTO `user_question` VALUES (390, NULL, 129, NULL, 'error', '123', 0);
INSERT INTO `user_question` VALUES (391, NULL, 54, NULL, 'error', '123', 0);
INSERT INTO `user_question` VALUES (392, NULL, 155, NULL, 'error', '123', 0);
INSERT INTO `user_question` VALUES (393, NULL, 1, 'A', 'right', '123', 0);
INSERT INTO `user_question` VALUES (394, NULL, 20, 'B', 'error', '123', 0);
INSERT INTO `user_question` VALUES (395, NULL, 19, 'C', 'error', '123', 0);
INSERT INTO `user_question` VALUES (396, NULL, 5, 'D', 'error', '123', 0);
INSERT INTO `user_question` VALUES (397, NULL, 23, 'A', 'error', '123', 0);
INSERT INTO `user_question` VALUES (398, NULL, 119, 'T', 'error', '123', 0);
INSERT INTO `user_question` VALUES (399, NULL, 52, 'F', 'error', '123', 0);
INSERT INTO `user_question` VALUES (400, NULL, 160, 'F', 'right', '123', 0);
INSERT INTO `user_question` VALUES (401, NULL, 18, 'B', 'right', '123', 0);
INSERT INTO `user_question` VALUES (402, NULL, 39, 'C', 'error', '123', 0);
INSERT INTO `user_question` VALUES (403, 1042, 1, 'C', 'error', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (404, 1042, 2, 'D', 'error', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (405, 1042, 3, 'B', 'right', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (406, 1042, 4, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (407, 1042, 5, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (408, 1042, 74, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (409, 1042, 12, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (410, 1042, 140, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (411, 1042, 16, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (412, 1042, 80, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (413, 1042, 17, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (414, 1042, 18, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (415, 1042, 19, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (416, 1042, 20, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (417, 1042, 21, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (418, 1042, 22, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (419, 1042, 87, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (420, 1042, 91, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (421, 1042, 225, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (422, 1042, 163, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (423, 1042, 101, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (424, 1042, 229, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (425, 1042, 39, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (426, 1042, 107, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (427, 1042, 108, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (428, 1042, 109, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (429, 1042, 112, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (430, 1042, 113, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (431, 1042, 50, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (432, 1043, 1, 'C', 'error', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (433, 1042, 118, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (434, 1043, 2, 'D', 'error', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (435, 1042, 122, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (436, 1043, 3, 'B', 'right', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (437, 1042, 126, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (438, 1043, 4, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (439, 1043, 5, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (440, 1043, 74, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (441, 1043, 12, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (442, 1043, 140, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (443, 1043, 16, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (444, 1043, 80, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (445, 1043, 17, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (446, 1043, 18, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (447, 1043, 19, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (448, 1043, 20, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (449, 1043, 21, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (450, 1043, 22, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (451, 1043, 87, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (452, 1043, 91, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (453, 1043, 225, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (454, 1043, 163, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (455, 1043, 101, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (456, 1043, 229, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (457, 1043, 39, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (458, 1043, 107, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (459, 1043, 108, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (460, 1043, 109, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (461, 1043, 112, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (462, 1043, 113, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (463, 1043, 50, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (464, 1043, 118, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (465, 1043, 122, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (466, 1043, 126, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (467, 1044, 1, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (468, 1044, 2, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (469, 1044, 3, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (470, 1044, 4, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (471, 1044, 5, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (472, 1044, 74, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (473, 1044, 12, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (474, 1044, 140, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (475, 1044, 16, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (476, 1044, 80, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (477, 1044, 17, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (478, 1044, 18, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (479, 1044, 19, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (480, 1044, 20, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (481, 1044, 21, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (482, 1044, 22, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (483, 1044, 87, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (484, 1044, 91, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (485, 1044, 225, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (486, 1044, 163, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (487, 1044, 101, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (488, 1044, 229, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (489, 1044, 39, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (490, 1044, 107, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (491, 1044, 108, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (492, 1044, 109, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (493, 1044, 112, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (494, 1044, 113, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (495, 1044, 50, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (496, 1044, 118, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (497, 1044, 122, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (498, 1044, 126, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (499, 1045, 1, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (500, 1045, 2, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (501, 1045, 3, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (502, 1045, 4, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (503, 1045, 5, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (504, 1045, 74, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (505, 1045, 12, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (506, 1045, 140, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (507, 1045, 16, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (508, 1045, 80, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (509, 1045, 17, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (510, 1045, 18, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (511, 1045, 19, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (512, 1045, 20, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (513, 1045, 21, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (514, 1045, 22, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (515, 1045, 87, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (516, 1045, 91, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (517, 1045, 225, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (518, 1045, 163, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (519, 1045, 101, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (520, 1045, 229, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (521, 1045, 39, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (522, 1045, 107, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (523, 1045, 108, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (524, 1045, 109, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (525, 1045, 112, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (526, 1045, 113, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (527, 1045, 50, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (528, 1045, 118, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (529, 1045, 122, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (530, 1045, 126, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (531, 1046, 1, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (532, 1046, 2, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (533, 1046, 3, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (534, 1046, 4, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (535, 1046, 5, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (536, 1046, 74, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (537, 1046, 12, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (538, 1046, 140, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (539, 1046, 16, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (540, 1046, 80, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (541, 1046, 17, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (542, 1046, 18, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (543, 1046, 19, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (544, 1046, 20, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (545, 1046, 21, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (546, 1046, 22, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (547, 1046, 87, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (548, 1046, 91, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (549, 1046, 225, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (550, 1046, 163, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (551, 1046, 101, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (552, 1046, 229, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (553, 1046, 39, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (554, 1046, 107, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (555, 1046, 108, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (556, 1046, 109, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (557, 1046, 112, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (558, 1046, 113, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (559, 1046, 50, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (560, 1046, 118, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (561, 1046, 122, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (562, 1046, 126, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (563, 1047, 1, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (564, 1047, 2, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (565, 1047, 3, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (566, 1047, 4, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (567, 1047, 5, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (568, 1047, 74, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (569, 1047, 12, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (570, 1047, 140, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (571, 1047, 16, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (572, 1047, 80, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (573, 1047, 17, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (574, 1047, 18, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (575, 1047, 19, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (576, 1047, 20, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (577, 1047, 21, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (578, 1047, 22, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (579, 1047, 87, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (580, 1047, 91, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (581, 1047, 225, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (582, 1047, 163, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (583, 1047, 101, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (584, 1047, 229, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (585, 1047, 39, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (586, 1047, 107, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (587, 1047, 108, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (588, 1047, 109, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (589, 1047, 112, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (590, 1047, 113, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (591, 1047, 50, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (592, 1047, 118, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (593, 1047, 122, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (594, 1047, 126, '', 'un', 'zhangsan', 0);
INSERT INTO `user_question` VALUES (595, 1048, 59, 'A', 'error', '张三', 0);
INSERT INTO `user_question` VALUES (596, 1048, 60, 'A', NULL, '张三', 0);
INSERT INTO `user_question` VALUES (597, 1048, 61, 'A', NULL, '张三', 0);
INSERT INTO `user_question` VALUES (598, 1048, 62, 'A', 'error', '张三', 0);
INSERT INTO `user_question` VALUES (599, 1049, 59, 'A', NULL, '123', 0);
INSERT INTO `user_question` VALUES (600, 1049, 60, 'A', NULL, '123', 0);
INSERT INTO `user_question` VALUES (601, 1049, 61, 'A', NULL, '123', 0);
INSERT INTO `user_question` VALUES (602, 1049, 62, 'A', NULL, '123', 0);
INSERT INTO `user_question` VALUES (603, 1050, 59, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (604, 1050, 60, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (605, 1050, 61, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (606, 1050, 62, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (607, 1051, 1, 'A', NULL, '张三', 0);
INSERT INTO `user_question` VALUES (608, 1051, 2, 'A', NULL, '张三', 0);
INSERT INTO `user_question` VALUES (609, 1052, 1, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (610, 1052, 2, NULL, NULL, '123', 0);
INSERT INTO `user_question` VALUES (611, 1053, 1, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (612, 1053, 2, NULL, NULL, 'test1', 0);
INSERT INTO `user_question` VALUES (613, NULL, 20, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (614, NULL, 249, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (615, NULL, 23, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (616, NULL, 109, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (617, NULL, 4, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (618, NULL, 11, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (619, NULL, 46, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (620, NULL, 39, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (621, NULL, 153, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (622, NULL, 117, NULL, 'error', '张三', 0);
INSERT INTO `user_question` VALUES (623, NULL, 216, NULL, 'error', 'system', 0);
INSERT INTO `user_question` VALUES (624, NULL, 204, NULL, 'error', 'system', 0);
INSERT INTO `user_question` VALUES (625, NULL, 183, NULL, 'error', 'system', 0);
INSERT INTO `user_question` VALUES (626, NULL, 210, NULL, 'error', 'system', 0);
INSERT INTO `user_question` VALUES (627, NULL, 254, NULL, 'error', 'system', 0);
INSERT INTO `user_question` VALUES (628, NULL, 219, NULL, 'error', 'system', 0);
INSERT INTO `user_question` VALUES (629, NULL, 217, NULL, 'error', 'system', 0);
INSERT INTO `user_question` VALUES (630, NULL, 191, NULL, 'error', 'system', 0);
INSERT INTO `user_question` VALUES (631, NULL, 66, NULL, 'error', 'system', 0);
INSERT INTO `user_question` VALUES (632, NULL, 62, NULL, 'error', 'system', 0);

SET FOREIGN_KEY_CHECKS = 1;
